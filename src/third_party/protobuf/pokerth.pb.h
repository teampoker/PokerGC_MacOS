// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pokerth.proto

#ifndef PROTOBUF_pokerth_2eproto__INCLUDED
#define PROTOBUF_pokerth_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pokerth_2eproto();
void protobuf_AssignDesc_pokerth_2eproto();
void protobuf_ShutdownFile_pokerth_2eproto();

class NetGameInfo;
class PlayerResult;
class AnnounceMessage;
class AnnounceMessage_Version;
class InitMessage;
class AuthServerChallengeMessage;
class AuthClientResponseMessage;
class AuthServerVerificationMessage;
class InitAckMessage;
class AvatarRequestMessage;
class AvatarHeaderMessage;
class AvatarDataMessage;
class AvatarEndMessage;
class UnknownAvatarMessage;
class PlayerListMessage;
class GameListNewMessage;
class GameListUpdateMessage;
class GameListPlayerJoinedMessage;
class GameListPlayerLeftMessage;
class GameListSpectatorJoinedMessage;
class GameListSpectatorLeftMessage;
class GameListAdminChangedMessage;
class PlayerInfoRequestMessage;
class PlayerInfoReplyMessage;
class PlayerInfoReplyMessage_PlayerInfoData;
class PlayerInfoReplyMessage_PlayerInfoData_AvatarData;
class SubscriptionRequestMessage;
class JoinExistingGameMessage;
class JoinNewGameMessage;
class RejoinExistingGameMessage;
class JoinGameAckMessage;
class JoinGameFailedMessage;
class GamePlayerJoinedMessage;
class GamePlayerLeftMessage;
class GameSpectatorJoinedMessage;
class GameSpectatorLeftMessage;
class GameAdminChangedMessage;
class RemovedFromGameMessage;
class KickPlayerRequestMessage;
class LeaveGameRequestMessage;
class InvitePlayerToGameMessage;
class InviteNotifyMessage;
class RejectGameInvitationMessage;
class RejectInvNotifyMessage;
class StartEventMessage;
class StartEventAckMessage;
class GameStartInitialMessage;
class GameStartRejoinMessage;
class GameStartRejoinMessage_RejoinPlayerData;
class HandStartMessage;
class HandStartMessage_PlainCards;
class PlayersTurnMessage;
class MyActionRequestMessage;
class YourActionRejectedMessage;
class PlayersActionDoneMessage;
class DealFlopCardsMessage;
class DealTurnCardMessage;
class DealRiverCardMessage;
class AllInShowCardsMessage;
class AllInShowCardsMessage_PlayerAllIn;
class EndOfHandShowCardsMessage;
class EndOfHandHideCardsMessage;
class ShowMyCardsRequestMessage;
class AfterHandShowCardsMessage;
class EndOfGameMessage;
class PlayerIdChangedMessage;
class AskKickPlayerMessage;
class AskKickDeniedMessage;
class StartKickPetitionMessage;
class VoteKickRequestMessage;
class VoteKickReplyMessage;
class KickPetitionUpdateMessage;
class EndKickPetitionMessage;
class StatisticsMessage;
class StatisticsMessage_StatisticsData;
class ChatRequestMessage;
class ChatMessage;
class ChatRejectMessage;
class DialogMessage;
class TimeoutWarningMessage;
class ResetTimeoutMessage;
class ReportAvatarMessage;
class ReportAvatarAckMessage;
class ReportGameMessage;
class ReportGameAckMessage;
class ErrorMessage;
class AdminRemoveGameMessage;
class AdminRemoveGameAckMessage;
class AdminBanPlayerMessage;
class AdminBanPlayerAckMessage;
class PokerTHMessage;

enum NetGameInfo_NetGameType {
  NetGameInfo_NetGameType_normalGame = 1,
  NetGameInfo_NetGameType_registeredOnlyGame = 2,
  NetGameInfo_NetGameType_inviteOnlyGame = 3,
  NetGameInfo_NetGameType_rankingGame = 4
};
bool NetGameInfo_NetGameType_IsValid(int value);
const NetGameInfo_NetGameType NetGameInfo_NetGameType_NetGameType_MIN = NetGameInfo_NetGameType_normalGame;
const NetGameInfo_NetGameType NetGameInfo_NetGameType_NetGameType_MAX = NetGameInfo_NetGameType_rankingGame;
const int NetGameInfo_NetGameType_NetGameType_ARRAYSIZE = NetGameInfo_NetGameType_NetGameType_MAX + 1;

enum NetGameInfo_RaiseIntervalMode {
  NetGameInfo_RaiseIntervalMode_raiseOnHandNum = 1,
  NetGameInfo_RaiseIntervalMode_raiseOnMinutes = 2
};
bool NetGameInfo_RaiseIntervalMode_IsValid(int value);
const NetGameInfo_RaiseIntervalMode NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MIN = NetGameInfo_RaiseIntervalMode_raiseOnHandNum;
const NetGameInfo_RaiseIntervalMode NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX = NetGameInfo_RaiseIntervalMode_raiseOnMinutes;
const int NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_ARRAYSIZE = NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX + 1;

enum NetGameInfo_EndRaiseMode {
  NetGameInfo_EndRaiseMode_doubleBlinds = 1,
  NetGameInfo_EndRaiseMode_raiseByEndValue = 2,
  NetGameInfo_EndRaiseMode_keepLastBlind = 3
};
bool NetGameInfo_EndRaiseMode_IsValid(int value);
const NetGameInfo_EndRaiseMode NetGameInfo_EndRaiseMode_EndRaiseMode_MIN = NetGameInfo_EndRaiseMode_doubleBlinds;
const NetGameInfo_EndRaiseMode NetGameInfo_EndRaiseMode_EndRaiseMode_MAX = NetGameInfo_EndRaiseMode_keepLastBlind;
const int NetGameInfo_EndRaiseMode_EndRaiseMode_ARRAYSIZE = NetGameInfo_EndRaiseMode_EndRaiseMode_MAX + 1;

enum AnnounceMessage_ServerType {
  AnnounceMessage_ServerType_serverTypeLAN = 0,
  AnnounceMessage_ServerType_serverTypeInternetNoAuth = 1,
  AnnounceMessage_ServerType_serverTypeInternetAuth = 2
};
bool AnnounceMessage_ServerType_IsValid(int value);
const AnnounceMessage_ServerType AnnounceMessage_ServerType_ServerType_MIN = AnnounceMessage_ServerType_serverTypeLAN;
const AnnounceMessage_ServerType AnnounceMessage_ServerType_ServerType_MAX = AnnounceMessage_ServerType_serverTypeInternetAuth;
const int AnnounceMessage_ServerType_ServerType_ARRAYSIZE = AnnounceMessage_ServerType_ServerType_MAX + 1;

enum InitMessage_LoginType {
  InitMessage_LoginType_guestLogin = 0,
  InitMessage_LoginType_authenticatedLogin = 1,
  InitMessage_LoginType_unauthenticatedLogin = 2
};
bool InitMessage_LoginType_IsValid(int value);
const InitMessage_LoginType InitMessage_LoginType_LoginType_MIN = InitMessage_LoginType_guestLogin;
const InitMessage_LoginType InitMessage_LoginType_LoginType_MAX = InitMessage_LoginType_unauthenticatedLogin;
const int InitMessage_LoginType_LoginType_ARRAYSIZE = InitMessage_LoginType_LoginType_MAX + 1;

enum PlayerListMessage_PlayerListNotification {
  PlayerListMessage_PlayerListNotification_playerListNew = 0,
  PlayerListMessage_PlayerListNotification_playerListLeft = 1
};
bool PlayerListMessage_PlayerListNotification_IsValid(int value);
const PlayerListMessage_PlayerListNotification PlayerListMessage_PlayerListNotification_PlayerListNotification_MIN = PlayerListMessage_PlayerListNotification_playerListNew;
const PlayerListMessage_PlayerListNotification PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX = PlayerListMessage_PlayerListNotification_playerListLeft;
const int PlayerListMessage_PlayerListNotification_PlayerListNotification_ARRAYSIZE = PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX + 1;

enum SubscriptionRequestMessage_SubscriptionAction {
  SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList = 1,
  SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList = 2
};
bool SubscriptionRequestMessage_SubscriptionAction_IsValid(int value);
const SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MIN = SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList;
const SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX = SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList;
const int SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_ARRAYSIZE = SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX + 1;

enum JoinGameFailedMessage_JoinGameFailureReason {
  JoinGameFailedMessage_JoinGameFailureReason_invalidGame = 1,
  JoinGameFailedMessage_JoinGameFailureReason_gameIsFull = 2,
  JoinGameFailedMessage_JoinGameFailureReason_gameIsRunning = 3,
  JoinGameFailedMessage_JoinGameFailureReason_invalidPassword = 4,
  JoinGameFailedMessage_JoinGameFailureReason_notAllowedAsGuest = 5,
  JoinGameFailedMessage_JoinGameFailureReason_notInvited = 6,
  JoinGameFailedMessage_JoinGameFailureReason_gameNameInUse = 7,
  JoinGameFailedMessage_JoinGameFailureReason_badGameName = 8,
  JoinGameFailedMessage_JoinGameFailureReason_invalidSettings = 9,
  JoinGameFailedMessage_JoinGameFailureReason_ipAddressBlocked = 10,
  JoinGameFailedMessage_JoinGameFailureReason_rejoinFailed = 11,
  JoinGameFailedMessage_JoinGameFailureReason_noSpectatorsAllowed = 12,
  JoinGameFailedMessage_JoinGameFailureReason_noContactRule = 13
};
bool JoinGameFailedMessage_JoinGameFailureReason_IsValid(int value);
const JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MIN = JoinGameFailedMessage_JoinGameFailureReason_invalidGame;
const JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX = JoinGameFailedMessage_JoinGameFailureReason_noSpectatorsAllowed;
const int JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_ARRAYSIZE = JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX + 1;

enum GamePlayerLeftMessage_GamePlayerLeftReason {
  GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest = 0,
  GamePlayerLeftMessage_GamePlayerLeftReason_leftKicked = 1,
  GamePlayerLeftMessage_GamePlayerLeftReason_leftError = 2
};
bool GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(int value);
const GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MIN = GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest;
const GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX = GamePlayerLeftMessage_GamePlayerLeftReason_leftError;
const int GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_ARRAYSIZE = GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX + 1;

enum RemovedFromGameMessage_RemovedFromGameReason {
  RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest = 0,
  RemovedFromGameMessage_RemovedFromGameReason_kickedFromGame = 1,
  RemovedFromGameMessage_RemovedFromGameReason_gameIsFull = 2,
  RemovedFromGameMessage_RemovedFromGameReason_gameIsRunning = 3,
  RemovedFromGameMessage_RemovedFromGameReason_gameTimeout = 4,
  RemovedFromGameMessage_RemovedFromGameReason_removedStartFailed = 5,
  RemovedFromGameMessage_RemovedFromGameReason_gameClosed = 6
};
bool RemovedFromGameMessage_RemovedFromGameReason_IsValid(int value);
const RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MIN = RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest;
const RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX = RemovedFromGameMessage_RemovedFromGameReason_gameClosed;
const int RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_ARRAYSIZE = RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX + 1;

enum RejectGameInvitationMessage_RejectGameInvReason {
  RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo = 0,
  RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy = 1
};
bool RejectGameInvitationMessage_RejectGameInvReason_IsValid(int value);
const RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MIN = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo;
const RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy;
const int RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_ARRAYSIZE = RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX + 1;

enum StartEventMessage_StartEventType {
  StartEventMessage_StartEventType_startEvent = 0,
  StartEventMessage_StartEventType_rejoinEvent = 1
};
bool StartEventMessage_StartEventType_IsValid(int value);
const StartEventMessage_StartEventType StartEventMessage_StartEventType_StartEventType_MIN = StartEventMessage_StartEventType_startEvent;
const StartEventMessage_StartEventType StartEventMessage_StartEventType_StartEventType_MAX = StartEventMessage_StartEventType_rejoinEvent;
const int StartEventMessage_StartEventType_StartEventType_ARRAYSIZE = StartEventMessage_StartEventType_StartEventType_MAX + 1;

enum YourActionRejectedMessage_RejectionReason {
  YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState = 1,
  YourActionRejectedMessage_RejectionReason_rejectedNotYourTurn = 2,
  YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed = 3
};
bool YourActionRejectedMessage_RejectionReason_IsValid(int value);
const YourActionRejectedMessage_RejectionReason YourActionRejectedMessage_RejectionReason_RejectionReason_MIN = YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState;
const YourActionRejectedMessage_RejectionReason YourActionRejectedMessage_RejectionReason_RejectionReason_MAX = YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed;
const int YourActionRejectedMessage_RejectionReason_RejectionReason_ARRAYSIZE = YourActionRejectedMessage_RejectionReason_RejectionReason_MAX + 1;

enum AskKickDeniedMessage_KickDeniedReason {
  AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState = 0,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedNotPossible = 1,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedTryAgainLater = 2,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedAlreadyInProgress = 3,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId = 4
};
bool AskKickDeniedMessage_KickDeniedReason_IsValid(int value);
const AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MIN = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState;
const AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId;
const int AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_ARRAYSIZE = AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX + 1;

enum VoteKickReplyMessage_VoteKickReplyType {
  VoteKickReplyMessage_VoteKickReplyType_voteKickAck = 0,
  VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedInvalid = 1,
  VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted = 2
};
bool VoteKickReplyMessage_VoteKickReplyType_IsValid(int value);
const VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MIN = VoteKickReplyMessage_VoteKickReplyType_voteKickAck;
const VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX = VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted;
const int VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_ARRAYSIZE = VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX + 1;

enum EndKickPetitionMessage_PetitionEndReason {
  EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes = 0,
  EndKickPetitionMessage_PetitionEndReason_petitionEndTooFewPlayers = 1,
  EndKickPetitionMessage_PetitionEndReason_petitionEndPlayerLeft = 2,
  EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout = 3
};
bool EndKickPetitionMessage_PetitionEndReason_IsValid(int value);
const EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MIN = EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes;
const EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX = EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout;
const int EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_ARRAYSIZE = EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX + 1;

enum StatisticsMessage_StatisticsData_StatisticsType {
  StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers = 1
};
bool StatisticsMessage_StatisticsData_StatisticsType_IsValid(int value);
const StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MIN = StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
const StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX = StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
const int StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_ARRAYSIZE = StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX + 1;

enum ChatMessage_ChatType {
  ChatMessage_ChatType_chatTypeLobby = 0,
  ChatMessage_ChatType_chatTypeGame = 1,
  ChatMessage_ChatType_chatTypeBot = 2,
  ChatMessage_ChatType_chatTypeBroadcast = 3,
  ChatMessage_ChatType_chatTypePrivate = 4
};
bool ChatMessage_ChatType_IsValid(int value);
const ChatMessage_ChatType ChatMessage_ChatType_ChatType_MIN = ChatMessage_ChatType_chatTypeLobby;
const ChatMessage_ChatType ChatMessage_ChatType_ChatType_MAX = ChatMessage_ChatType_chatTypePrivate;
const int ChatMessage_ChatType_ChatType_ARRAYSIZE = ChatMessage_ChatType_ChatType_MAX + 1;

enum TimeoutWarningMessage_TimeoutReason {
  TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived = 0,
  TimeoutWarningMessage_TimeoutReason_timeoutInactiveGame = 1,
  TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold = 2
};
bool TimeoutWarningMessage_TimeoutReason_IsValid(int value);
const TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage_TimeoutReason_TimeoutReason_MIN = TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived;
const TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX = TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold;
const int TimeoutWarningMessage_TimeoutReason_TimeoutReason_ARRAYSIZE = TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX + 1;

enum ReportAvatarAckMessage_ReportAvatarResult {
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted = 0,
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportDuplicate = 1,
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid = 2
};
bool ReportAvatarAckMessage_ReportAvatarResult_IsValid(int value);
const ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MIN = ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted;
const ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX = ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid;
const int ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_ARRAYSIZE = ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX + 1;

enum ReportGameAckMessage_ReportGameResult {
  ReportGameAckMessage_ReportGameResult_gameReportAccepted = 0,
  ReportGameAckMessage_ReportGameResult_gameReportDuplicate = 1,
  ReportGameAckMessage_ReportGameResult_gameReportInvalid = 2
};
bool ReportGameAckMessage_ReportGameResult_IsValid(int value);
const ReportGameAckMessage_ReportGameResult ReportGameAckMessage_ReportGameResult_ReportGameResult_MIN = ReportGameAckMessage_ReportGameResult_gameReportAccepted;
const ReportGameAckMessage_ReportGameResult ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX = ReportGameAckMessage_ReportGameResult_gameReportInvalid;
const int ReportGameAckMessage_ReportGameResult_ReportGameResult_ARRAYSIZE = ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX + 1;

enum ErrorMessage_ErrorReason {
  ErrorMessage_ErrorReason_reserved = 0,
  ErrorMessage_ErrorReason_initVersionNotSupported = 1,
  ErrorMessage_ErrorReason_initServerFull = 2,
  ErrorMessage_ErrorReason_initAuthFailure = 3,
  ErrorMessage_ErrorReason_initPlayerNameInUse = 4,
  ErrorMessage_ErrorReason_initInvalidPlayerName = 5,
  ErrorMessage_ErrorReason_initServerMaintenance = 6,
  ErrorMessage_ErrorReason_initBlocked = 7,
  ErrorMessage_ErrorReason_avatarTooLarge = 8,
  ErrorMessage_ErrorReason_invalidPacket = 9,
  ErrorMessage_ErrorReason_invalidState = 10,
  ErrorMessage_ErrorReason_kickedFromServer = 11,
  ErrorMessage_ErrorReason_bannedFromServer = 12,
  ErrorMessage_ErrorReason_blockedByServer = 13,
  ErrorMessage_ErrorReason_sessionTimeout = 14
};
bool ErrorMessage_ErrorReason_IsValid(int value);
const ErrorMessage_ErrorReason ErrorMessage_ErrorReason_ErrorReason_MIN = ErrorMessage_ErrorReason_reserved;
const ErrorMessage_ErrorReason ErrorMessage_ErrorReason_ErrorReason_MAX = ErrorMessage_ErrorReason_sessionTimeout;
const int ErrorMessage_ErrorReason_ErrorReason_ARRAYSIZE = ErrorMessage_ErrorReason_ErrorReason_MAX + 1;

enum AdminRemoveGameAckMessage_AdminRemoveGameResult {
  AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveAccepted = 0,
  AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveInvalid = 1
};
bool AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(int value);
const AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MIN = AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveAccepted;
const AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MAX = AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveInvalid;
const int AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_ARRAYSIZE = AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MAX + 1;

enum AdminBanPlayerAckMessage_AdminBanPlayerResult {
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerAccepted = 0,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerPending = 1,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerNoDB = 2,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerDBError = 3,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerInvalid = 4
};
bool AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(int value);
const AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MIN = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerAccepted;
const AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MAX = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerInvalid;
const int AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_ARRAYSIZE = AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MAX + 1;

enum PokerTHMessage_PokerTHMessageType {
  PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage = 1,
  PokerTHMessage_PokerTHMessageType_Type_InitMessage = 2,
  PokerTHMessage_PokerTHMessageType_Type_AuthServerChallengeMessage = 3,
  PokerTHMessage_PokerTHMessageType_Type_AuthClientResponseMessage = 4,
  PokerTHMessage_PokerTHMessageType_Type_AuthServerVerificationMessage = 5,
  PokerTHMessage_PokerTHMessageType_Type_InitAckMessage = 6,
  PokerTHMessage_PokerTHMessageType_Type_AvatarRequestMessage = 7,
  PokerTHMessage_PokerTHMessageType_Type_AvatarHeaderMessage = 8,
  PokerTHMessage_PokerTHMessageType_Type_AvatarDataMessage = 9,
  PokerTHMessage_PokerTHMessageType_Type_AvatarEndMessage = 10,
  PokerTHMessage_PokerTHMessageType_Type_UnknownAvatarMessage = 11,
  PokerTHMessage_PokerTHMessageType_Type_PlayerListMessage = 12,
  PokerTHMessage_PokerTHMessageType_Type_GameListNewMessage = 13,
  PokerTHMessage_PokerTHMessageType_Type_GameListUpdateMessage = 14,
  PokerTHMessage_PokerTHMessageType_Type_GameListPlayerJoinedMessage = 15,
  PokerTHMessage_PokerTHMessageType_Type_GameListPlayerLeftMessage = 16,
  PokerTHMessage_PokerTHMessageType_Type_GameListAdminChangedMessage = 17,
  PokerTHMessage_PokerTHMessageType_Type_PlayerInfoRequestMessage = 18,
  PokerTHMessage_PokerTHMessageType_Type_PlayerInfoReplyMessage = 19,
  PokerTHMessage_PokerTHMessageType_Type_SubscriptionRequestMessage = 20,
  PokerTHMessage_PokerTHMessageType_Type_JoinExistingGameMessage = 21,
  PokerTHMessage_PokerTHMessageType_Type_JoinNewGameMessage = 22,
  PokerTHMessage_PokerTHMessageType_Type_RejoinExistingGameMessage = 23,
  PokerTHMessage_PokerTHMessageType_Type_JoinGameAckMessage = 24,
  PokerTHMessage_PokerTHMessageType_Type_JoinGameFailedMessage = 25,
  PokerTHMessage_PokerTHMessageType_Type_GamePlayerJoinedMessage = 26,
  PokerTHMessage_PokerTHMessageType_Type_GamePlayerLeftMessage = 27,
  PokerTHMessage_PokerTHMessageType_Type_GameAdminChangedMessage = 28,
  PokerTHMessage_PokerTHMessageType_Type_RemovedFromGameMessage = 29,
  PokerTHMessage_PokerTHMessageType_Type_KickPlayerRequestMessage = 30,
  PokerTHMessage_PokerTHMessageType_Type_LeaveGameRequestMessage = 31,
  PokerTHMessage_PokerTHMessageType_Type_InvitePlayerToGameMessage = 32,
  PokerTHMessage_PokerTHMessageType_Type_InviteNotifyMessage = 33,
  PokerTHMessage_PokerTHMessageType_Type_RejectGameInvitationMessage = 34,
  PokerTHMessage_PokerTHMessageType_Type_RejectInvNotifyMessage = 35,
  PokerTHMessage_PokerTHMessageType_Type_StartEventMessage = 36,
  PokerTHMessage_PokerTHMessageType_Type_StartEventAckMessage = 37,
  PokerTHMessage_PokerTHMessageType_Type_GameStartInitialMessage = 38,
  PokerTHMessage_PokerTHMessageType_Type_GameStartRejoinMessage = 39,
  PokerTHMessage_PokerTHMessageType_Type_HandStartMessage = 40,
  PokerTHMessage_PokerTHMessageType_Type_PlayersTurnMessage = 41,
  PokerTHMessage_PokerTHMessageType_Type_MyActionRequestMessage = 42,
  PokerTHMessage_PokerTHMessageType_Type_YourActionRejectedMessage = 43,
  PokerTHMessage_PokerTHMessageType_Type_PlayersActionDoneMessage = 44,
  PokerTHMessage_PokerTHMessageType_Type_DealFlopCardsMessage = 45,
  PokerTHMessage_PokerTHMessageType_Type_DealTurnCardMessage = 46,
  PokerTHMessage_PokerTHMessageType_Type_DealRiverCardMessage = 47,
  PokerTHMessage_PokerTHMessageType_Type_AllInShowCardsMessage = 48,
  PokerTHMessage_PokerTHMessageType_Type_EndOfHandShowCardsMessage = 49,
  PokerTHMessage_PokerTHMessageType_Type_EndOfHandHideCardsMessage = 50,
  PokerTHMessage_PokerTHMessageType_Type_ShowMyCardsRequestMessage = 51,
  PokerTHMessage_PokerTHMessageType_Type_AfterHandShowCardsMessage = 52,
  PokerTHMessage_PokerTHMessageType_Type_EndOfGameMessage = 53,
  PokerTHMessage_PokerTHMessageType_Type_PlayerIdChangedMessage = 54,
  PokerTHMessage_PokerTHMessageType_Type_AskKickPlayerMessage = 55,
  PokerTHMessage_PokerTHMessageType_Type_AskKickDeniedMessage = 56,
  PokerTHMessage_PokerTHMessageType_Type_StartKickPetitionMessage = 57,
  PokerTHMessage_PokerTHMessageType_Type_VoteKickRequestMessage = 58,
  PokerTHMessage_PokerTHMessageType_Type_VoteKickReplyMessage = 59,
  PokerTHMessage_PokerTHMessageType_Type_KickPetitionUpdateMessage = 60,
  PokerTHMessage_PokerTHMessageType_Type_EndKickPetitionMessage = 61,
  PokerTHMessage_PokerTHMessageType_Type_StatisticsMessage = 62,
  PokerTHMessage_PokerTHMessageType_Type_ChatRequestMessage = 63,
  PokerTHMessage_PokerTHMessageType_Type_ChatMessage = 64,
  PokerTHMessage_PokerTHMessageType_Type_ChatRejectMessage = 65,
  PokerTHMessage_PokerTHMessageType_Type_DialogMessage = 66,
  PokerTHMessage_PokerTHMessageType_Type_TimeoutWarningMessage = 67,
  PokerTHMessage_PokerTHMessageType_Type_ResetTimeoutMessage = 68,
  PokerTHMessage_PokerTHMessageType_Type_ReportAvatarMessage = 69,
  PokerTHMessage_PokerTHMessageType_Type_ReportAvatarAckMessage = 70,
  PokerTHMessage_PokerTHMessageType_Type_ReportGameMessage = 71,
  PokerTHMessage_PokerTHMessageType_Type_ReportGameAckMessage = 72,
  PokerTHMessage_PokerTHMessageType_Type_ErrorMessage = 73,
  PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameMessage = 74,
  PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameAckMessage = 75,
  PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerMessage = 76,
  PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerAckMessage = 77,
  PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorJoinedMessage = 78,
  PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorLeftMessage = 79,
  PokerTHMessage_PokerTHMessageType_Type_GameSpectatorJoinedMessage = 80,
  PokerTHMessage_PokerTHMessageType_Type_GameSpectatorLeftMessage = 81
};
bool PokerTHMessage_PokerTHMessageType_IsValid(int value);
const PokerTHMessage_PokerTHMessageType PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MIN = PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage;
const PokerTHMessage_PokerTHMessageType PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX = PokerTHMessage_PokerTHMessageType_Type_GameSpectatorLeftMessage;
const int PokerTHMessage_PokerTHMessageType_PokerTHMessageType_ARRAYSIZE = PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX + 1;

enum NetGameMode {
  netGameCreated = 1,
  netGameStarted = 2,
  netGameClosed = 3
};
bool NetGameMode_IsValid(int value);
const NetGameMode NetGameMode_MIN = netGameCreated;
const NetGameMode NetGameMode_MAX = netGameClosed;
const int NetGameMode_ARRAYSIZE = NetGameMode_MAX + 1;

enum NetGameState {
  netStatePreflop = 0,
  netStateFlop = 1,
  netStateTurn = 2,
  netStateRiver = 3,
  netStatePreflopSmallBlind = 4,
  netStatePreflopBigBlind = 5
};
bool NetGameState_IsValid(int value);
const NetGameState NetGameState_MIN = netStatePreflop;
const NetGameState NetGameState_MAX = netStatePreflopBigBlind;
const int NetGameState_ARRAYSIZE = NetGameState_MAX + 1;

enum NetPlayerAction {
  netActionNone = 0,
  netActionFold = 1,
  netActionCheck = 2,
  netActionCall = 3,
  netActionBet = 4,
  netActionRaise = 5,
  netActionAllIn = 6
};
bool NetPlayerAction_IsValid(int value);
const NetPlayerAction NetPlayerAction_MIN = netActionNone;
const NetPlayerAction NetPlayerAction_MAX = netActionAllIn;
const int NetPlayerAction_ARRAYSIZE = NetPlayerAction_MAX + 1;

enum NetPlayerState {
  netPlayerStateNormal = 0,
  netPlayerStateSessionInactive = 1,
  netPlayerStateNoMoney = 2
};
bool NetPlayerState_IsValid(int value);
const NetPlayerState NetPlayerState_MIN = netPlayerStateNormal;
const NetPlayerState NetPlayerState_MAX = netPlayerStateNoMoney;
const int NetPlayerState_ARRAYSIZE = NetPlayerState_MAX + 1;

enum NetPlayerInfoRights {
  netPlayerRightsGuest = 1,
  netPlayerRightsNormal = 2,
  netPlayerRightsAdmin = 3
};
bool NetPlayerInfoRights_IsValid(int value);
const NetPlayerInfoRights NetPlayerInfoRights_MIN = netPlayerRightsGuest;
const NetPlayerInfoRights NetPlayerInfoRights_MAX = netPlayerRightsAdmin;
const int NetPlayerInfoRights_ARRAYSIZE = NetPlayerInfoRights_MAX + 1;

enum NetAvatarType {
  netAvatarImagePng = 1,
  netAvatarImageJpg = 2,
  netAvatarImageGif = 3
};
bool NetAvatarType_IsValid(int value);
const NetAvatarType NetAvatarType_MIN = netAvatarImagePng;
const NetAvatarType NetAvatarType_MAX = netAvatarImageGif;
const int NetAvatarType_ARRAYSIZE = NetAvatarType_MAX + 1;

// ===================================================================

class NetGameInfo : public ::google::protobuf::MessageLite {
 public:
  NetGameInfo();
  virtual ~NetGameInfo();

  NetGameInfo(const NetGameInfo& from);

  inline NetGameInfo& operator=(const NetGameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NetGameInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NetGameInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NetGameInfo* other);

  // implements Message ----------------------------------------------

  NetGameInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NetGameInfo& from);
  void MergeFrom(const NetGameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef NetGameInfo_NetGameType NetGameType;
  static const NetGameType normalGame = NetGameInfo_NetGameType_normalGame;
  static const NetGameType registeredOnlyGame = NetGameInfo_NetGameType_registeredOnlyGame;
  static const NetGameType inviteOnlyGame = NetGameInfo_NetGameType_inviteOnlyGame;
  static const NetGameType rankingGame = NetGameInfo_NetGameType_rankingGame;
  static inline bool NetGameType_IsValid(int value) {
    return NetGameInfo_NetGameType_IsValid(value);
  }
  static const NetGameType NetGameType_MIN =
    NetGameInfo_NetGameType_NetGameType_MIN;
  static const NetGameType NetGameType_MAX =
    NetGameInfo_NetGameType_NetGameType_MAX;
  static const int NetGameType_ARRAYSIZE =
    NetGameInfo_NetGameType_NetGameType_ARRAYSIZE;

  typedef NetGameInfo_RaiseIntervalMode RaiseIntervalMode;
  static const RaiseIntervalMode raiseOnHandNum = NetGameInfo_RaiseIntervalMode_raiseOnHandNum;
  static const RaiseIntervalMode raiseOnMinutes = NetGameInfo_RaiseIntervalMode_raiseOnMinutes;
  static inline bool RaiseIntervalMode_IsValid(int value) {
    return NetGameInfo_RaiseIntervalMode_IsValid(value);
  }
  static const RaiseIntervalMode RaiseIntervalMode_MIN =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MIN;
  static const RaiseIntervalMode RaiseIntervalMode_MAX =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX;
  static const int RaiseIntervalMode_ARRAYSIZE =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_ARRAYSIZE;

  typedef NetGameInfo_EndRaiseMode EndRaiseMode;
  static const EndRaiseMode doubleBlinds = NetGameInfo_EndRaiseMode_doubleBlinds;
  static const EndRaiseMode raiseByEndValue = NetGameInfo_EndRaiseMode_raiseByEndValue;
  static const EndRaiseMode keepLastBlind = NetGameInfo_EndRaiseMode_keepLastBlind;
  static inline bool EndRaiseMode_IsValid(int value) {
    return NetGameInfo_EndRaiseMode_IsValid(value);
  }
  static const EndRaiseMode EndRaiseMode_MIN =
    NetGameInfo_EndRaiseMode_EndRaiseMode_MIN;
  static const EndRaiseMode EndRaiseMode_MAX =
    NetGameInfo_EndRaiseMode_EndRaiseMode_MAX;
  static const int EndRaiseMode_ARRAYSIZE =
    NetGameInfo_EndRaiseMode_EndRaiseMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string gameName = 1;
  inline bool has_gamename() const;
  inline void clear_gamename();
  static const int kGameNameFieldNumber = 1;
  inline const ::std::string& gamename() const;
  inline void set_gamename(const ::std::string& value);
  inline void set_gamename(const char* value);
  inline void set_gamename(const char* value, size_t size);
  inline ::std::string* mutable_gamename();
  inline ::std::string* release_gamename();
  inline void set_allocated_gamename(::std::string* gamename);

  // required .NetGameInfo.NetGameType netGameType = 2;
  inline bool has_netgametype() const;
  inline void clear_netgametype();
  static const int kNetGameTypeFieldNumber = 2;
  inline ::NetGameInfo_NetGameType netgametype() const;
  inline void set_netgametype(::NetGameInfo_NetGameType value);

  // required uint32 maxNumPlayers = 3;
  inline bool has_maxnumplayers() const;
  inline void clear_maxnumplayers();
  static const int kMaxNumPlayersFieldNumber = 3;
  inline ::google::protobuf::uint32 maxnumplayers() const;
  inline void set_maxnumplayers(::google::protobuf::uint32 value);

  // required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
  inline bool has_raiseintervalmode() const;
  inline void clear_raiseintervalmode();
  static const int kRaiseIntervalModeFieldNumber = 4;
  inline ::NetGameInfo_RaiseIntervalMode raiseintervalmode() const;
  inline void set_raiseintervalmode(::NetGameInfo_RaiseIntervalMode value);

  // optional uint32 raiseEveryHands = 5;
  inline bool has_raiseeveryhands() const;
  inline void clear_raiseeveryhands();
  static const int kRaiseEveryHandsFieldNumber = 5;
  inline ::google::protobuf::uint32 raiseeveryhands() const;
  inline void set_raiseeveryhands(::google::protobuf::uint32 value);

  // optional uint32 raiseEveryMinutes = 6;
  inline bool has_raiseeveryminutes() const;
  inline void clear_raiseeveryminutes();
  static const int kRaiseEveryMinutesFieldNumber = 6;
  inline ::google::protobuf::uint32 raiseeveryminutes() const;
  inline void set_raiseeveryminutes(::google::protobuf::uint32 value);

  // required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
  inline bool has_endraisemode() const;
  inline void clear_endraisemode();
  static const int kEndRaiseModeFieldNumber = 7;
  inline ::NetGameInfo_EndRaiseMode endraisemode() const;
  inline void set_endraisemode(::NetGameInfo_EndRaiseMode value);

  // optional uint32 endRaiseSmallBlindValue = 8;
  inline bool has_endraisesmallblindvalue() const;
  inline void clear_endraisesmallblindvalue();
  static const int kEndRaiseSmallBlindValueFieldNumber = 8;
  inline ::google::protobuf::uint32 endraisesmallblindvalue() const;
  inline void set_endraisesmallblindvalue(::google::protobuf::uint32 value);

  // required uint32 proposedGuiSpeed = 9;
  inline bool has_proposedguispeed() const;
  inline void clear_proposedguispeed();
  static const int kProposedGuiSpeedFieldNumber = 9;
  inline ::google::protobuf::uint32 proposedguispeed() const;
  inline void set_proposedguispeed(::google::protobuf::uint32 value);

  // required uint32 delayBetweenHands = 10;
  inline bool has_delaybetweenhands() const;
  inline void clear_delaybetweenhands();
  static const int kDelayBetweenHandsFieldNumber = 10;
  inline ::google::protobuf::uint32 delaybetweenhands() const;
  inline void set_delaybetweenhands(::google::protobuf::uint32 value);

  // required uint32 playerActionTimeout = 11;
  inline bool has_playeractiontimeout() const;
  inline void clear_playeractiontimeout();
  static const int kPlayerActionTimeoutFieldNumber = 11;
  inline ::google::protobuf::uint32 playeractiontimeout() const;
  inline void set_playeractiontimeout(::google::protobuf::uint32 value);

  // required uint32 firstSmallBlind = 12;
  inline bool has_firstsmallblind() const;
  inline void clear_firstsmallblind();
  static const int kFirstSmallBlindFieldNumber = 12;
  inline ::google::protobuf::uint32 firstsmallblind() const;
  inline void set_firstsmallblind(::google::protobuf::uint32 value);

  // required uint32 startMoney = 13;
  inline bool has_startmoney() const;
  inline void clear_startmoney();
  static const int kStartMoneyFieldNumber = 13;
  inline ::google::protobuf::uint32 startmoney() const;
  inline void set_startmoney(::google::protobuf::uint32 value);

  // repeated uint32 manualBlinds = 14 [packed = true];
  inline int manualblinds_size() const;
  inline void clear_manualblinds();
  static const int kManualBlindsFieldNumber = 14;
  inline ::google::protobuf::uint32 manualblinds(int index) const;
  inline void set_manualblinds(int index, ::google::protobuf::uint32 value);
  inline void add_manualblinds(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      manualblinds() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_manualblinds();

  // optional bool allowSpectators = 15 [default = true];
  inline bool has_allowspectators() const;
  inline void clear_allowspectators();
  static const int kAllowSpectatorsFieldNumber = 15;
  inline bool allowspectators() const;
  inline void set_allowspectators(bool value);

  // @@protoc_insertion_point(class_scope:NetGameInfo)
 private:
  inline void set_has_gamename();
  inline void clear_has_gamename();
  inline void set_has_netgametype();
  inline void clear_has_netgametype();
  inline void set_has_maxnumplayers();
  inline void clear_has_maxnumplayers();
  inline void set_has_raiseintervalmode();
  inline void clear_has_raiseintervalmode();
  inline void set_has_raiseeveryhands();
  inline void clear_has_raiseeveryhands();
  inline void set_has_raiseeveryminutes();
  inline void clear_has_raiseeveryminutes();
  inline void set_has_endraisemode();
  inline void clear_has_endraisemode();
  inline void set_has_endraisesmallblindvalue();
  inline void clear_has_endraisesmallblindvalue();
  inline void set_has_proposedguispeed();
  inline void clear_has_proposedguispeed();
  inline void set_has_delaybetweenhands();
  inline void clear_has_delaybetweenhands();
  inline void set_has_playeractiontimeout();
  inline void clear_has_playeractiontimeout();
  inline void set_has_firstsmallblind();
  inline void clear_has_firstsmallblind();
  inline void set_has_startmoney();
  inline void clear_has_startmoney();
  inline void set_has_allowspectators();
  inline void clear_has_allowspectators();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gamename_;
  int netgametype_;
  ::google::protobuf::uint32 maxnumplayers_;
  int raiseintervalmode_;
  ::google::protobuf::uint32 raiseeveryhands_;
  ::google::protobuf::uint32 raiseeveryminutes_;
  int endraisemode_;
  ::google::protobuf::uint32 endraisesmallblindvalue_;
  ::google::protobuf::uint32 proposedguispeed_;
  ::google::protobuf::uint32 delaybetweenhands_;
  ::google::protobuf::uint32 playeractiontimeout_;
  ::google::protobuf::uint32 firstsmallblind_;
  ::google::protobuf::uint32 startmoney_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > manualblinds_;
  mutable int _manualblinds_cached_byte_size_;
  bool allowspectators_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static NetGameInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerResult : public ::google::protobuf::MessageLite {
 public:
  PlayerResult();
  virtual ~PlayerResult();

  PlayerResult(const PlayerResult& from);

  inline PlayerResult& operator=(const PlayerResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerResult* other);

  // implements Message ----------------------------------------------

  PlayerResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerResult& from);
  void MergeFrom(const PlayerResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required uint32 resultCard1 = 2;
  inline bool has_resultcard1() const;
  inline void clear_resultcard1();
  static const int kResultCard1FieldNumber = 2;
  inline ::google::protobuf::uint32 resultcard1() const;
  inline void set_resultcard1(::google::protobuf::uint32 value);

  // required uint32 resultCard2 = 3;
  inline bool has_resultcard2() const;
  inline void clear_resultcard2();
  static const int kResultCard2FieldNumber = 3;
  inline ::google::protobuf::uint32 resultcard2() const;
  inline void set_resultcard2(::google::protobuf::uint32 value);

  // repeated uint32 bestHandPosition = 4 [packed = true];
  inline int besthandposition_size() const;
  inline void clear_besthandposition();
  static const int kBestHandPositionFieldNumber = 4;
  inline ::google::protobuf::uint32 besthandposition(int index) const;
  inline void set_besthandposition(int index, ::google::protobuf::uint32 value);
  inline void add_besthandposition(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      besthandposition() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_besthandposition();

  // required uint32 moneyWon = 5;
  inline bool has_moneywon() const;
  inline void clear_moneywon();
  static const int kMoneyWonFieldNumber = 5;
  inline ::google::protobuf::uint32 moneywon() const;
  inline void set_moneywon(::google::protobuf::uint32 value);

  // required uint32 playerMoney = 6;
  inline bool has_playermoney() const;
  inline void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 6;
  inline ::google::protobuf::uint32 playermoney() const;
  inline void set_playermoney(::google::protobuf::uint32 value);

  // optional uint32 cardsValue = 7;
  inline bool has_cardsvalue() const;
  inline void clear_cardsvalue();
  static const int kCardsValueFieldNumber = 7;
  inline ::google::protobuf::uint32 cardsvalue() const;
  inline void set_cardsvalue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PlayerResult)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_resultcard1();
  inline void clear_has_resultcard1();
  inline void set_has_resultcard2();
  inline void clear_has_resultcard2();
  inline void set_has_moneywon();
  inline void clear_has_moneywon();
  inline void set_has_playermoney();
  inline void clear_has_playermoney();
  inline void set_has_cardsvalue();
  inline void clear_has_cardsvalue();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 resultcard1_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > besthandposition_;
  mutable int _besthandposition_cached_byte_size_;
  ::google::protobuf::uint32 resultcard2_;
  ::google::protobuf::uint32 moneywon_;
  ::google::protobuf::uint32 playermoney_;
  ::google::protobuf::uint32 cardsvalue_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static PlayerResult* default_instance_;
};
// -------------------------------------------------------------------

class AnnounceMessage_Version : public ::google::protobuf::MessageLite {
 public:
  AnnounceMessage_Version();
  virtual ~AnnounceMessage_Version();

  AnnounceMessage_Version(const AnnounceMessage_Version& from);

  inline AnnounceMessage_Version& operator=(const AnnounceMessage_Version& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AnnounceMessage_Version& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AnnounceMessage_Version* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AnnounceMessage_Version* other);

  // implements Message ----------------------------------------------

  AnnounceMessage_Version* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnnounceMessage_Version& from);
  void MergeFrom(const AnnounceMessage_Version& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 majorVersion = 1;
  inline bool has_majorversion() const;
  inline void clear_majorversion();
  static const int kMajorVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 majorversion() const;
  inline void set_majorversion(::google::protobuf::uint32 value);

  // required uint32 minorVersion = 2;
  inline bool has_minorversion() const;
  inline void clear_minorversion();
  static const int kMinorVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 minorversion() const;
  inline void set_minorversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AnnounceMessage.Version)
 private:
  inline void set_has_majorversion();
  inline void clear_has_majorversion();
  inline void set_has_minorversion();
  inline void clear_has_minorversion();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 majorversion_;
  ::google::protobuf::uint32 minorversion_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AnnounceMessage_Version* default_instance_;
};
// -------------------------------------------------------------------

class AnnounceMessage : public ::google::protobuf::MessageLite {
 public:
  AnnounceMessage();
  virtual ~AnnounceMessage();

  AnnounceMessage(const AnnounceMessage& from);

  inline AnnounceMessage& operator=(const AnnounceMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AnnounceMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AnnounceMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AnnounceMessage* other);

  // implements Message ----------------------------------------------

  AnnounceMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnnounceMessage& from);
  void MergeFrom(const AnnounceMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AnnounceMessage_Version Version;

  typedef AnnounceMessage_ServerType ServerType;
  static const ServerType serverTypeLAN = AnnounceMessage_ServerType_serverTypeLAN;
  static const ServerType serverTypeInternetNoAuth = AnnounceMessage_ServerType_serverTypeInternetNoAuth;
  static const ServerType serverTypeInternetAuth = AnnounceMessage_ServerType_serverTypeInternetAuth;
  static inline bool ServerType_IsValid(int value) {
    return AnnounceMessage_ServerType_IsValid(value);
  }
  static const ServerType ServerType_MIN =
    AnnounceMessage_ServerType_ServerType_MIN;
  static const ServerType ServerType_MAX =
    AnnounceMessage_ServerType_ServerType_MAX;
  static const int ServerType_ARRAYSIZE =
    AnnounceMessage_ServerType_ServerType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .AnnounceMessage.Version protocolVersion = 1;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  inline const ::AnnounceMessage_Version& protocolversion() const;
  inline ::AnnounceMessage_Version* mutable_protocolversion();
  inline ::AnnounceMessage_Version* release_protocolversion();
  inline void set_allocated_protocolversion(::AnnounceMessage_Version* protocolversion);

  // required .AnnounceMessage.Version latestGameVersion = 2;
  inline bool has_latestgameversion() const;
  inline void clear_latestgameversion();
  static const int kLatestGameVersionFieldNumber = 2;
  inline const ::AnnounceMessage_Version& latestgameversion() const;
  inline ::AnnounceMessage_Version* mutable_latestgameversion();
  inline ::AnnounceMessage_Version* release_latestgameversion();
  inline void set_allocated_latestgameversion(::AnnounceMessage_Version* latestgameversion);

  // required uint32 latestBetaRevision = 3;
  inline bool has_latestbetarevision() const;
  inline void clear_latestbetarevision();
  static const int kLatestBetaRevisionFieldNumber = 3;
  inline ::google::protobuf::uint32 latestbetarevision() const;
  inline void set_latestbetarevision(::google::protobuf::uint32 value);

  // required .AnnounceMessage.ServerType serverType = 4;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 4;
  inline ::AnnounceMessage_ServerType servertype() const;
  inline void set_servertype(::AnnounceMessage_ServerType value);

  // required uint32 numPlayersOnServer = 5;
  inline bool has_numplayersonserver() const;
  inline void clear_numplayersonserver();
  static const int kNumPlayersOnServerFieldNumber = 5;
  inline ::google::protobuf::uint32 numplayersonserver() const;
  inline void set_numplayersonserver(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AnnounceMessage)
 private:
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();
  inline void set_has_latestgameversion();
  inline void clear_has_latestgameversion();
  inline void set_has_latestbetarevision();
  inline void clear_has_latestbetarevision();
  inline void set_has_servertype();
  inline void clear_has_servertype();
  inline void set_has_numplayersonserver();
  inline void clear_has_numplayersonserver();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::AnnounceMessage_Version* protocolversion_;
  ::AnnounceMessage_Version* latestgameversion_;
  ::google::protobuf::uint32 latestbetarevision_;
  int servertype_;
  ::google::protobuf::uint32 numplayersonserver_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AnnounceMessage* default_instance_;
};
// -------------------------------------------------------------------

class InitMessage : public ::google::protobuf::MessageLite {
 public:
  InitMessage();
  virtual ~InitMessage();

  InitMessage(const InitMessage& from);

  inline InitMessage& operator=(const InitMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InitMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InitMessage* other);

  // implements Message ----------------------------------------------

  InitMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitMessage& from);
  void MergeFrom(const InitMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InitMessage_LoginType LoginType;
  static const LoginType guestLogin = InitMessage_LoginType_guestLogin;
  static const LoginType authenticatedLogin = InitMessage_LoginType_authenticatedLogin;
  static const LoginType unauthenticatedLogin = InitMessage_LoginType_unauthenticatedLogin;
  static inline bool LoginType_IsValid(int value) {
    return InitMessage_LoginType_IsValid(value);
  }
  static const LoginType LoginType_MIN =
    InitMessage_LoginType_LoginType_MIN;
  static const LoginType LoginType_MAX =
    InitMessage_LoginType_LoginType_MAX;
  static const int LoginType_ARRAYSIZE =
    InitMessage_LoginType_LoginType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .AnnounceMessage.Version requestedVersion = 1;
  inline bool has_requestedversion() const;
  inline void clear_requestedversion();
  static const int kRequestedVersionFieldNumber = 1;
  inline const ::AnnounceMessage_Version& requestedversion() const;
  inline ::AnnounceMessage_Version* mutable_requestedversion();
  inline ::AnnounceMessage_Version* release_requestedversion();
  inline void set_allocated_requestedversion(::AnnounceMessage_Version* requestedversion);

  // required uint32 buildId = 2;
  inline bool has_buildid() const;
  inline void clear_buildid();
  static const int kBuildIdFieldNumber = 2;
  inline ::google::protobuf::uint32 buildid() const;
  inline void set_buildid(::google::protobuf::uint32 value);

  // optional bytes myLastSessionId = 3;
  inline bool has_mylastsessionid() const;
  inline void clear_mylastsessionid();
  static const int kMyLastSessionIdFieldNumber = 3;
  inline const ::std::string& mylastsessionid() const;
  inline void set_mylastsessionid(const ::std::string& value);
  inline void set_mylastsessionid(const char* value);
  inline void set_mylastsessionid(const void* value, size_t size);
  inline ::std::string* mutable_mylastsessionid();
  inline ::std::string* release_mylastsessionid();
  inline void set_allocated_mylastsessionid(::std::string* mylastsessionid);

  // optional string authServerPassword = 4;
  inline bool has_authserverpassword() const;
  inline void clear_authserverpassword();
  static const int kAuthServerPasswordFieldNumber = 4;
  inline const ::std::string& authserverpassword() const;
  inline void set_authserverpassword(const ::std::string& value);
  inline void set_authserverpassword(const char* value);
  inline void set_authserverpassword(const char* value, size_t size);
  inline ::std::string* mutable_authserverpassword();
  inline ::std::string* release_authserverpassword();
  inline void set_allocated_authserverpassword(::std::string* authserverpassword);

  // required .InitMessage.LoginType login = 5;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 5;
  inline ::InitMessage_LoginType login() const;
  inline void set_login(::InitMessage_LoginType value);

  // optional string nickName = 6;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 6;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional bytes clientUserData = 7;
  inline bool has_clientuserdata() const;
  inline void clear_clientuserdata();
  static const int kClientUserDataFieldNumber = 7;
  inline const ::std::string& clientuserdata() const;
  inline void set_clientuserdata(const ::std::string& value);
  inline void set_clientuserdata(const char* value);
  inline void set_clientuserdata(const void* value, size_t size);
  inline ::std::string* mutable_clientuserdata();
  inline ::std::string* release_clientuserdata();
  inline void set_allocated_clientuserdata(::std::string* clientuserdata);

  // optional bytes avatarHash = 8;
  inline bool has_avatarhash() const;
  inline void clear_avatarhash();
  static const int kAvatarHashFieldNumber = 8;
  inline const ::std::string& avatarhash() const;
  inline void set_avatarhash(const ::std::string& value);
  inline void set_avatarhash(const char* value);
  inline void set_avatarhash(const void* value, size_t size);
  inline ::std::string* mutable_avatarhash();
  inline ::std::string* release_avatarhash();
  inline void set_allocated_avatarhash(::std::string* avatarhash);

  // @@protoc_insertion_point(class_scope:InitMessage)
 private:
  inline void set_has_requestedversion();
  inline void clear_has_requestedversion();
  inline void set_has_buildid();
  inline void clear_has_buildid();
  inline void set_has_mylastsessionid();
  inline void clear_has_mylastsessionid();
  inline void set_has_authserverpassword();
  inline void clear_has_authserverpassword();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_clientuserdata();
  inline void clear_has_clientuserdata();
  inline void set_has_avatarhash();
  inline void clear_has_avatarhash();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::AnnounceMessage_Version* requestedversion_;
  ::std::string* mylastsessionid_;
  ::google::protobuf::uint32 buildid_;
  int login_;
  ::std::string* authserverpassword_;
  ::std::string* nickname_;
  ::std::string* clientuserdata_;
  ::std::string* avatarhash_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static InitMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthServerChallengeMessage : public ::google::protobuf::MessageLite {
 public:
  AuthServerChallengeMessage();
  virtual ~AuthServerChallengeMessage();

  AuthServerChallengeMessage(const AuthServerChallengeMessage& from);

  inline AuthServerChallengeMessage& operator=(const AuthServerChallengeMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthServerChallengeMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthServerChallengeMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthServerChallengeMessage* other);

  // implements Message ----------------------------------------------

  AuthServerChallengeMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthServerChallengeMessage& from);
  void MergeFrom(const AuthServerChallengeMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serverChallenge = 1;
  inline bool has_serverchallenge() const;
  inline void clear_serverchallenge();
  static const int kServerChallengeFieldNumber = 1;
  inline const ::std::string& serverchallenge() const;
  inline void set_serverchallenge(const ::std::string& value);
  inline void set_serverchallenge(const char* value);
  inline void set_serverchallenge(const void* value, size_t size);
  inline ::std::string* mutable_serverchallenge();
  inline ::std::string* release_serverchallenge();
  inline void set_allocated_serverchallenge(::std::string* serverchallenge);

  // @@protoc_insertion_point(class_scope:AuthServerChallengeMessage)
 private:
  inline void set_has_serverchallenge();
  inline void clear_has_serverchallenge();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* serverchallenge_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AuthServerChallengeMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthClientResponseMessage : public ::google::protobuf::MessageLite {
 public:
  AuthClientResponseMessage();
  virtual ~AuthClientResponseMessage();

  AuthClientResponseMessage(const AuthClientResponseMessage& from);

  inline AuthClientResponseMessage& operator=(const AuthClientResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthClientResponseMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthClientResponseMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthClientResponseMessage* other);

  // implements Message ----------------------------------------------

  AuthClientResponseMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthClientResponseMessage& from);
  void MergeFrom(const AuthClientResponseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes clientResponse = 1;
  inline bool has_clientresponse() const;
  inline void clear_clientresponse();
  static const int kClientResponseFieldNumber = 1;
  inline const ::std::string& clientresponse() const;
  inline void set_clientresponse(const ::std::string& value);
  inline void set_clientresponse(const char* value);
  inline void set_clientresponse(const void* value, size_t size);
  inline ::std::string* mutable_clientresponse();
  inline ::std::string* release_clientresponse();
  inline void set_allocated_clientresponse(::std::string* clientresponse);

  // @@protoc_insertion_point(class_scope:AuthClientResponseMessage)
 private:
  inline void set_has_clientresponse();
  inline void clear_has_clientresponse();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* clientresponse_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AuthClientResponseMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthServerVerificationMessage : public ::google::protobuf::MessageLite {
 public:
  AuthServerVerificationMessage();
  virtual ~AuthServerVerificationMessage();

  AuthServerVerificationMessage(const AuthServerVerificationMessage& from);

  inline AuthServerVerificationMessage& operator=(const AuthServerVerificationMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthServerVerificationMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthServerVerificationMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthServerVerificationMessage* other);

  // implements Message ----------------------------------------------

  AuthServerVerificationMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthServerVerificationMessage& from);
  void MergeFrom(const AuthServerVerificationMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serverVerification = 1;
  inline bool has_serververification() const;
  inline void clear_serververification();
  static const int kServerVerificationFieldNumber = 1;
  inline const ::std::string& serververification() const;
  inline void set_serververification(const ::std::string& value);
  inline void set_serververification(const char* value);
  inline void set_serververification(const void* value, size_t size);
  inline ::std::string* mutable_serververification();
  inline ::std::string* release_serververification();
  inline void set_allocated_serververification(::std::string* serververification);

  // @@protoc_insertion_point(class_scope:AuthServerVerificationMessage)
 private:
  inline void set_has_serververification();
  inline void clear_has_serververification();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* serververification_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AuthServerVerificationMessage* default_instance_;
};
// -------------------------------------------------------------------

class InitAckMessage : public ::google::protobuf::MessageLite {
 public:
  InitAckMessage();
  virtual ~InitAckMessage();

  InitAckMessage(const InitAckMessage& from);

  inline InitAckMessage& operator=(const InitAckMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InitAckMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitAckMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InitAckMessage* other);

  // implements Message ----------------------------------------------

  InitAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitAckMessage& from);
  void MergeFrom(const InitAckMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes yourSessionId = 1;
  inline bool has_yoursessionid() const;
  inline void clear_yoursessionid();
  static const int kYourSessionIdFieldNumber = 1;
  inline const ::std::string& yoursessionid() const;
  inline void set_yoursessionid(const ::std::string& value);
  inline void set_yoursessionid(const char* value);
  inline void set_yoursessionid(const void* value, size_t size);
  inline ::std::string* mutable_yoursessionid();
  inline ::std::string* release_yoursessionid();
  inline void set_allocated_yoursessionid(::std::string* yoursessionid);

  // required uint32 yourPlayerId = 2;
  inline bool has_yourplayerid() const;
  inline void clear_yourplayerid();
  static const int kYourPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 yourplayerid() const;
  inline void set_yourplayerid(::google::protobuf::uint32 value);

  // optional bytes yourAvatarHash = 3;
  inline bool has_youravatarhash() const;
  inline void clear_youravatarhash();
  static const int kYourAvatarHashFieldNumber = 3;
  inline const ::std::string& youravatarhash() const;
  inline void set_youravatarhash(const ::std::string& value);
  inline void set_youravatarhash(const char* value);
  inline void set_youravatarhash(const void* value, size_t size);
  inline ::std::string* mutable_youravatarhash();
  inline ::std::string* release_youravatarhash();
  inline void set_allocated_youravatarhash(::std::string* youravatarhash);

  // optional uint32 rejoinGameId = 4;
  inline bool has_rejoingameid() const;
  inline void clear_rejoingameid();
  static const int kRejoinGameIdFieldNumber = 4;
  inline ::google::protobuf::uint32 rejoingameid() const;
  inline void set_rejoingameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:InitAckMessage)
 private:
  inline void set_has_yoursessionid();
  inline void clear_has_yoursessionid();
  inline void set_has_yourplayerid();
  inline void clear_has_yourplayerid();
  inline void set_has_youravatarhash();
  inline void clear_has_youravatarhash();
  inline void set_has_rejoingameid();
  inline void clear_has_rejoingameid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* yoursessionid_;
  ::std::string* youravatarhash_;
  ::google::protobuf::uint32 yourplayerid_;
  ::google::protobuf::uint32 rejoingameid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static InitAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class AvatarRequestMessage : public ::google::protobuf::MessageLite {
 public:
  AvatarRequestMessage();
  virtual ~AvatarRequestMessage();

  AvatarRequestMessage(const AvatarRequestMessage& from);

  inline AvatarRequestMessage& operator=(const AvatarRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AvatarRequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AvatarRequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AvatarRequestMessage* other);

  // implements Message ----------------------------------------------

  AvatarRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvatarRequestMessage& from);
  void MergeFrom(const AvatarRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);

  // required bytes avatarHash = 2;
  inline bool has_avatarhash() const;
  inline void clear_avatarhash();
  static const int kAvatarHashFieldNumber = 2;
  inline const ::std::string& avatarhash() const;
  inline void set_avatarhash(const ::std::string& value);
  inline void set_avatarhash(const char* value);
  inline void set_avatarhash(const void* value, size_t size);
  inline ::std::string* mutable_avatarhash();
  inline ::std::string* release_avatarhash();
  inline void set_allocated_avatarhash(::std::string* avatarhash);

  // @@protoc_insertion_point(class_scope:AvatarRequestMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_avatarhash();
  inline void clear_has_avatarhash();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatarhash_;
  ::google::protobuf::uint32 requestid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AvatarRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class AvatarHeaderMessage : public ::google::protobuf::MessageLite {
 public:
  AvatarHeaderMessage();
  virtual ~AvatarHeaderMessage();

  AvatarHeaderMessage(const AvatarHeaderMessage& from);

  inline AvatarHeaderMessage& operator=(const AvatarHeaderMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AvatarHeaderMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AvatarHeaderMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AvatarHeaderMessage* other);

  // implements Message ----------------------------------------------

  AvatarHeaderMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvatarHeaderMessage& from);
  void MergeFrom(const AvatarHeaderMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);

  // required .NetAvatarType avatarType = 2;
  inline bool has_avatartype() const;
  inline void clear_avatartype();
  static const int kAvatarTypeFieldNumber = 2;
  inline ::NetAvatarType avatartype() const;
  inline void set_avatartype(::NetAvatarType value);

  // required uint32 avatarSize = 3;
  inline bool has_avatarsize() const;
  inline void clear_avatarsize();
  static const int kAvatarSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 avatarsize() const;
  inline void set_avatarsize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AvatarHeaderMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_avatartype();
  inline void clear_has_avatartype();
  inline void set_has_avatarsize();
  inline void clear_has_avatarsize();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 requestid_;
  int avatartype_;
  ::google::protobuf::uint32 avatarsize_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AvatarHeaderMessage* default_instance_;
};
// -------------------------------------------------------------------

class AvatarDataMessage : public ::google::protobuf::MessageLite {
 public:
  AvatarDataMessage();
  virtual ~AvatarDataMessage();

  AvatarDataMessage(const AvatarDataMessage& from);

  inline AvatarDataMessage& operator=(const AvatarDataMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AvatarDataMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AvatarDataMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AvatarDataMessage* other);

  // implements Message ----------------------------------------------

  AvatarDataMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvatarDataMessage& from);
  void MergeFrom(const AvatarDataMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);

  // required bytes avatarBlock = 2;
  inline bool has_avatarblock() const;
  inline void clear_avatarblock();
  static const int kAvatarBlockFieldNumber = 2;
  inline const ::std::string& avatarblock() const;
  inline void set_avatarblock(const ::std::string& value);
  inline void set_avatarblock(const char* value);
  inline void set_avatarblock(const void* value, size_t size);
  inline ::std::string* mutable_avatarblock();
  inline ::std::string* release_avatarblock();
  inline void set_allocated_avatarblock(::std::string* avatarblock);

  // @@protoc_insertion_point(class_scope:AvatarDataMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_avatarblock();
  inline void clear_has_avatarblock();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatarblock_;
  ::google::protobuf::uint32 requestid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AvatarDataMessage* default_instance_;
};
// -------------------------------------------------------------------

class AvatarEndMessage : public ::google::protobuf::MessageLite {
 public:
  AvatarEndMessage();
  virtual ~AvatarEndMessage();

  AvatarEndMessage(const AvatarEndMessage& from);

  inline AvatarEndMessage& operator=(const AvatarEndMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AvatarEndMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AvatarEndMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AvatarEndMessage* other);

  // implements Message ----------------------------------------------

  AvatarEndMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvatarEndMessage& from);
  void MergeFrom(const AvatarEndMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AvatarEndMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 requestid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AvatarEndMessage* default_instance_;
};
// -------------------------------------------------------------------

class UnknownAvatarMessage : public ::google::protobuf::MessageLite {
 public:
  UnknownAvatarMessage();
  virtual ~UnknownAvatarMessage();

  UnknownAvatarMessage(const UnknownAvatarMessage& from);

  inline UnknownAvatarMessage& operator=(const UnknownAvatarMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UnknownAvatarMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnknownAvatarMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnknownAvatarMessage* other);

  // implements Message ----------------------------------------------

  UnknownAvatarMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnknownAvatarMessage& from);
  void MergeFrom(const UnknownAvatarMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UnknownAvatarMessage)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 requestid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static UnknownAvatarMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayerListMessage : public ::google::protobuf::MessageLite {
 public:
  PlayerListMessage();
  virtual ~PlayerListMessage();

  PlayerListMessage(const PlayerListMessage& from);

  inline PlayerListMessage& operator=(const PlayerListMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerListMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerListMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerListMessage* other);

  // implements Message ----------------------------------------------

  PlayerListMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerListMessage& from);
  void MergeFrom(const PlayerListMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PlayerListMessage_PlayerListNotification PlayerListNotification;
  static const PlayerListNotification playerListNew = PlayerListMessage_PlayerListNotification_playerListNew;
  static const PlayerListNotification playerListLeft = PlayerListMessage_PlayerListNotification_playerListLeft;
  static inline bool PlayerListNotification_IsValid(int value) {
    return PlayerListMessage_PlayerListNotification_IsValid(value);
  }
  static const PlayerListNotification PlayerListNotification_MIN =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_MIN;
  static const PlayerListNotification PlayerListNotification_MAX =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX;
  static const int PlayerListNotification_ARRAYSIZE =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
  inline bool has_playerlistnotification() const;
  inline void clear_playerlistnotification();
  static const int kPlayerListNotificationFieldNumber = 2;
  inline ::PlayerListMessage_PlayerListNotification playerlistnotification() const;
  inline void set_playerlistnotification(::PlayerListMessage_PlayerListNotification value);

  // @@protoc_insertion_point(class_scope:PlayerListMessage)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playerlistnotification();
  inline void clear_has_playerlistnotification();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  int playerlistnotification_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static PlayerListMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListNewMessage : public ::google::protobuf::MessageLite {
 public:
  GameListNewMessage();
  virtual ~GameListNewMessage();

  GameListNewMessage(const GameListNewMessage& from);

  inline GameListNewMessage& operator=(const GameListNewMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameListNewMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameListNewMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameListNewMessage* other);

  // implements Message ----------------------------------------------

  GameListNewMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListNewMessage& from);
  void MergeFrom(const GameListNewMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required .NetGameMode gameMode = 2;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 2;
  inline ::NetGameMode gamemode() const;
  inline void set_gamemode(::NetGameMode value);

  // required bool isPrivate = 3;
  inline bool has_isprivate() const;
  inline void clear_isprivate();
  static const int kIsPrivateFieldNumber = 3;
  inline bool isprivate() const;
  inline void set_isprivate(bool value);

  // repeated uint32 playerIds = 4 [packed = true];
  inline int playerids_size() const;
  inline void clear_playerids();
  static const int kPlayerIdsFieldNumber = 4;
  inline ::google::protobuf::uint32 playerids(int index) const;
  inline void set_playerids(int index, ::google::protobuf::uint32 value);
  inline void add_playerids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      playerids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_playerids();

  // required uint32 adminPlayerId = 5;
  inline bool has_adminplayerid() const;
  inline void clear_adminplayerid();
  static const int kAdminPlayerIdFieldNumber = 5;
  inline ::google::protobuf::uint32 adminplayerid() const;
  inline void set_adminplayerid(::google::protobuf::uint32 value);

  // required .NetGameInfo gameInfo = 6;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 6;
  inline const ::NetGameInfo& gameinfo() const;
  inline ::NetGameInfo* mutable_gameinfo();
  inline ::NetGameInfo* release_gameinfo();
  inline void set_allocated_gameinfo(::NetGameInfo* gameinfo);

  // repeated uint32 spectatorIds = 7 [packed = true];
  inline int spectatorids_size() const;
  inline void clear_spectatorids();
  static const int kSpectatorIdsFieldNumber = 7;
  inline ::google::protobuf::uint32 spectatorids(int index) const;
  inline void set_spectatorids(int index, ::google::protobuf::uint32 value);
  inline void add_spectatorids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      spectatorids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_spectatorids();

  // @@protoc_insertion_point(class_scope:GameListNewMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  inline void set_has_isprivate();
  inline void clear_has_isprivate();
  inline void set_has_adminplayerid();
  inline void clear_has_adminplayerid();
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int gamemode_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > playerids_;
  mutable int _playerids_cached_byte_size_;
  bool isprivate_;
  ::google::protobuf::uint32 adminplayerid_;
  ::NetGameInfo* gameinfo_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > spectatorids_;
  mutable int _spectatorids_cached_byte_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameListNewMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListUpdateMessage : public ::google::protobuf::MessageLite {
 public:
  GameListUpdateMessage();
  virtual ~GameListUpdateMessage();

  GameListUpdateMessage(const GameListUpdateMessage& from);

  inline GameListUpdateMessage& operator=(const GameListUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameListUpdateMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameListUpdateMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameListUpdateMessage* other);

  // implements Message ----------------------------------------------

  GameListUpdateMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListUpdateMessage& from);
  void MergeFrom(const GameListUpdateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required .NetGameMode gameMode = 2;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 2;
  inline ::NetGameMode gamemode() const;
  inline void set_gamemode(::NetGameMode value);

  // @@protoc_insertion_point(class_scope:GameListUpdateMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamemode();
  inline void clear_has_gamemode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int gamemode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameListUpdateMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListPlayerJoinedMessage : public ::google::protobuf::MessageLite {
 public:
  GameListPlayerJoinedMessage();
  virtual ~GameListPlayerJoinedMessage();

  GameListPlayerJoinedMessage(const GameListPlayerJoinedMessage& from);

  inline GameListPlayerJoinedMessage& operator=(const GameListPlayerJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameListPlayerJoinedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameListPlayerJoinedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameListPlayerJoinedMessage* other);

  // implements Message ----------------------------------------------

  GameListPlayerJoinedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListPlayerJoinedMessage& from);
  void MergeFrom(const GameListPlayerJoinedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameListPlayerJoinedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameListPlayerJoinedMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListPlayerLeftMessage : public ::google::protobuf::MessageLite {
 public:
  GameListPlayerLeftMessage();
  virtual ~GameListPlayerLeftMessage();

  GameListPlayerLeftMessage(const GameListPlayerLeftMessage& from);

  inline GameListPlayerLeftMessage& operator=(const GameListPlayerLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameListPlayerLeftMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameListPlayerLeftMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameListPlayerLeftMessage* other);

  // implements Message ----------------------------------------------

  GameListPlayerLeftMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListPlayerLeftMessage& from);
  void MergeFrom(const GameListPlayerLeftMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameListPlayerLeftMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameListPlayerLeftMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListSpectatorJoinedMessage : public ::google::protobuf::MessageLite {
 public:
  GameListSpectatorJoinedMessage();
  virtual ~GameListSpectatorJoinedMessage();

  GameListSpectatorJoinedMessage(const GameListSpectatorJoinedMessage& from);

  inline GameListSpectatorJoinedMessage& operator=(const GameListSpectatorJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameListSpectatorJoinedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameListSpectatorJoinedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameListSpectatorJoinedMessage* other);

  // implements Message ----------------------------------------------

  GameListSpectatorJoinedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListSpectatorJoinedMessage& from);
  void MergeFrom(const GameListSpectatorJoinedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameListSpectatorJoinedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameListSpectatorJoinedMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListSpectatorLeftMessage : public ::google::protobuf::MessageLite {
 public:
  GameListSpectatorLeftMessage();
  virtual ~GameListSpectatorLeftMessage();

  GameListSpectatorLeftMessage(const GameListSpectatorLeftMessage& from);

  inline GameListSpectatorLeftMessage& operator=(const GameListSpectatorLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameListSpectatorLeftMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameListSpectatorLeftMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameListSpectatorLeftMessage* other);

  // implements Message ----------------------------------------------

  GameListSpectatorLeftMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListSpectatorLeftMessage& from);
  void MergeFrom(const GameListSpectatorLeftMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameListSpectatorLeftMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameListSpectatorLeftMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameListAdminChangedMessage : public ::google::protobuf::MessageLite {
 public:
  GameListAdminChangedMessage();
  virtual ~GameListAdminChangedMessage();

  GameListAdminChangedMessage(const GameListAdminChangedMessage& from);

  inline GameListAdminChangedMessage& operator=(const GameListAdminChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameListAdminChangedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameListAdminChangedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameListAdminChangedMessage* other);

  // implements Message ----------------------------------------------

  GameListAdminChangedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameListAdminChangedMessage& from);
  void MergeFrom(const GameListAdminChangedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 newAdminPlayerId = 2;
  inline bool has_newadminplayerid() const;
  inline void clear_newadminplayerid();
  static const int kNewAdminPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 newadminplayerid() const;
  inline void set_newadminplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameListAdminChangedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_newadminplayerid();
  inline void clear_has_newadminplayerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 newadminplayerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameListAdminChangedMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfoRequestMessage : public ::google::protobuf::MessageLite {
 public:
  PlayerInfoRequestMessage();
  virtual ~PlayerInfoRequestMessage();

  PlayerInfoRequestMessage(const PlayerInfoRequestMessage& from);

  inline PlayerInfoRequestMessage& operator=(const PlayerInfoRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerInfoRequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerInfoRequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerInfoRequestMessage* other);

  // implements Message ----------------------------------------------

  PlayerInfoRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerInfoRequestMessage& from);
  void MergeFrom(const PlayerInfoRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 playerId = 1 [packed = true];
  inline int playerid_size() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid(int index) const;
  inline void set_playerid(int index, ::google::protobuf::uint32 value);
  inline void add_playerid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      playerid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_playerid();

  // @@protoc_insertion_point(class_scope:PlayerInfoRequestMessage)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > playerid_;
  mutable int _playerid_cached_byte_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfoRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage_PlayerInfoData_AvatarData : public ::google::protobuf::MessageLite {
 public:
  PlayerInfoReplyMessage_PlayerInfoData_AvatarData();
  virtual ~PlayerInfoReplyMessage_PlayerInfoData_AvatarData();

  PlayerInfoReplyMessage_PlayerInfoData_AvatarData(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);

  inline PlayerInfoReplyMessage_PlayerInfoData_AvatarData& operator=(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerInfoReplyMessage_PlayerInfoData_AvatarData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerInfoReplyMessage_PlayerInfoData_AvatarData* other);

  // implements Message ----------------------------------------------

  PlayerInfoReplyMessage_PlayerInfoData_AvatarData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);
  void MergeFrom(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetAvatarType avatarType = 1;
  inline bool has_avatartype() const;
  inline void clear_avatartype();
  static const int kAvatarTypeFieldNumber = 1;
  inline ::NetAvatarType avatartype() const;
  inline void set_avatartype(::NetAvatarType value);

  // required bytes avatarHash = 2;
  inline bool has_avatarhash() const;
  inline void clear_avatarhash();
  static const int kAvatarHashFieldNumber = 2;
  inline const ::std::string& avatarhash() const;
  inline void set_avatarhash(const ::std::string& value);
  inline void set_avatarhash(const char* value);
  inline void set_avatarhash(const void* value, size_t size);
  inline ::std::string* mutable_avatarhash();
  inline ::std::string* release_avatarhash();
  inline void set_allocated_avatarhash(::std::string* avatarhash);

  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
 private:
  inline void set_has_avatartype();
  inline void clear_has_avatartype();
  inline void set_has_avatarhash();
  inline void clear_has_avatarhash();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatarhash_;
  int avatartype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfoReplyMessage_PlayerInfoData_AvatarData* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage_PlayerInfoData : public ::google::protobuf::MessageLite {
 public:
  PlayerInfoReplyMessage_PlayerInfoData();
  virtual ~PlayerInfoReplyMessage_PlayerInfoData();

  PlayerInfoReplyMessage_PlayerInfoData(const PlayerInfoReplyMessage_PlayerInfoData& from);

  inline PlayerInfoReplyMessage_PlayerInfoData& operator=(const PlayerInfoReplyMessage_PlayerInfoData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerInfoReplyMessage_PlayerInfoData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerInfoReplyMessage_PlayerInfoData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerInfoReplyMessage_PlayerInfoData* other);

  // implements Message ----------------------------------------------

  PlayerInfoReplyMessage_PlayerInfoData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerInfoReplyMessage_PlayerInfoData& from);
  void MergeFrom(const PlayerInfoReplyMessage_PlayerInfoData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PlayerInfoReplyMessage_PlayerInfoData_AvatarData AvatarData;

  // accessors -------------------------------------------------------

  // required string playerName = 1;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayerNameFieldNumber = 1;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  inline void set_allocated_playername(::std::string* playername);

  // required bool isHuman = 2;
  inline bool has_ishuman() const;
  inline void clear_ishuman();
  static const int kIsHumanFieldNumber = 2;
  inline bool ishuman() const;
  inline void set_ishuman(bool value);

  // required .NetPlayerInfoRights playerRights = 3;
  inline bool has_playerrights() const;
  inline void clear_playerrights();
  static const int kPlayerRightsFieldNumber = 3;
  inline ::NetPlayerInfoRights playerrights() const;
  inline void set_playerrights(::NetPlayerInfoRights value);

  // optional string countryCode = 4;
  inline bool has_countrycode() const;
  inline void clear_countrycode();
  static const int kCountryCodeFieldNumber = 4;
  inline const ::std::string& countrycode() const;
  inline void set_countrycode(const ::std::string& value);
  inline void set_countrycode(const char* value);
  inline void set_countrycode(const char* value, size_t size);
  inline ::std::string* mutable_countrycode();
  inline ::std::string* release_countrycode();
  inline void set_allocated_countrycode(::std::string* countrycode);

  // optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
  inline bool has_avatardata() const;
  inline void clear_avatardata();
  static const int kAvatarDataFieldNumber = 5;
  inline const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& avatardata() const;
  inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* mutable_avatardata();
  inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* release_avatardata();
  inline void set_allocated_avatardata(::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata);

  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage.PlayerInfoData)
 private:
  inline void set_has_playername();
  inline void clear_has_playername();
  inline void set_has_ishuman();
  inline void clear_has_ishuman();
  inline void set_has_playerrights();
  inline void clear_has_playerrights();
  inline void set_has_countrycode();
  inline void clear_has_countrycode();
  inline void set_has_avatardata();
  inline void clear_has_avatardata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* playername_;
  bool ishuman_;
  int playerrights_;
  ::std::string* countrycode_;
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfoReplyMessage_PlayerInfoData* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage : public ::google::protobuf::MessageLite {
 public:
  PlayerInfoReplyMessage();
  virtual ~PlayerInfoReplyMessage();

  PlayerInfoReplyMessage(const PlayerInfoReplyMessage& from);

  inline PlayerInfoReplyMessage& operator=(const PlayerInfoReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerInfoReplyMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerInfoReplyMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerInfoReplyMessage* other);

  // implements Message ----------------------------------------------

  PlayerInfoReplyMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerInfoReplyMessage& from);
  void MergeFrom(const PlayerInfoReplyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PlayerInfoReplyMessage_PlayerInfoData PlayerInfoData;

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
  inline bool has_playerinfodata() const;
  inline void clear_playerinfodata();
  static const int kPlayerInfoDataFieldNumber = 2;
  inline const ::PlayerInfoReplyMessage_PlayerInfoData& playerinfodata() const;
  inline ::PlayerInfoReplyMessage_PlayerInfoData* mutable_playerinfodata();
  inline ::PlayerInfoReplyMessage_PlayerInfoData* release_playerinfodata();
  inline void set_allocated_playerinfodata(::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata);

  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playerinfodata();
  inline void clear_has_playerinfodata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata_;
  ::google::protobuf::uint32 playerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfoReplyMessage* default_instance_;
};
// -------------------------------------------------------------------

class SubscriptionRequestMessage : public ::google::protobuf::MessageLite {
 public:
  SubscriptionRequestMessage();
  virtual ~SubscriptionRequestMessage();

  SubscriptionRequestMessage(const SubscriptionRequestMessage& from);

  inline SubscriptionRequestMessage& operator=(const SubscriptionRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SubscriptionRequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SubscriptionRequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SubscriptionRequestMessage* other);

  // implements Message ----------------------------------------------

  SubscriptionRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SubscriptionRequestMessage& from);
  void MergeFrom(const SubscriptionRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SubscriptionRequestMessage_SubscriptionAction SubscriptionAction;
  static const SubscriptionAction unsubscribeGameList = SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList;
  static const SubscriptionAction resubscribeGameList = SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList;
  static inline bool SubscriptionAction_IsValid(int value) {
    return SubscriptionRequestMessage_SubscriptionAction_IsValid(value);
  }
  static const SubscriptionAction SubscriptionAction_MIN =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MIN;
  static const SubscriptionAction SubscriptionAction_MAX =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX;
  static const int SubscriptionAction_ARRAYSIZE =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
  inline bool has_subscriptionaction() const;
  inline void clear_subscriptionaction();
  static const int kSubscriptionActionFieldNumber = 1;
  inline ::SubscriptionRequestMessage_SubscriptionAction subscriptionaction() const;
  inline void set_subscriptionaction(::SubscriptionRequestMessage_SubscriptionAction value);

  // @@protoc_insertion_point(class_scope:SubscriptionRequestMessage)
 private:
  inline void set_has_subscriptionaction();
  inline void clear_has_subscriptionaction();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int subscriptionaction_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static SubscriptionRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class JoinExistingGameMessage : public ::google::protobuf::MessageLite {
 public:
  JoinExistingGameMessage();
  virtual ~JoinExistingGameMessage();

  JoinExistingGameMessage(const JoinExistingGameMessage& from);

  inline JoinExistingGameMessage& operator=(const JoinExistingGameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const JoinExistingGameMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinExistingGameMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinExistingGameMessage* other);

  // implements Message ----------------------------------------------

  JoinExistingGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinExistingGameMessage& from);
  void MergeFrom(const JoinExistingGameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool autoLeave = 3 [default = false];
  inline bool has_autoleave() const;
  inline void clear_autoleave();
  static const int kAutoLeaveFieldNumber = 3;
  inline bool autoleave() const;
  inline void set_autoleave(bool value);

  // optional bool spectateOnly = 4 [default = false];
  inline bool has_spectateonly() const;
  inline void clear_spectateonly();
  static const int kSpectateOnlyFieldNumber = 4;
  inline bool spectateonly() const;
  inline void set_spectateonly(bool value);

  // @@protoc_insertion_point(class_scope:JoinExistingGameMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_autoleave();
  inline void clear_has_autoleave();
  inline void set_has_spectateonly();
  inline void clear_has_spectateonly();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* password_;
  ::google::protobuf::uint32 gameid_;
  bool autoleave_;
  bool spectateonly_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static JoinExistingGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class JoinNewGameMessage : public ::google::protobuf::MessageLite {
 public:
  JoinNewGameMessage();
  virtual ~JoinNewGameMessage();

  JoinNewGameMessage(const JoinNewGameMessage& from);

  inline JoinNewGameMessage& operator=(const JoinNewGameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const JoinNewGameMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinNewGameMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinNewGameMessage* other);

  // implements Message ----------------------------------------------

  JoinNewGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinNewGameMessage& from);
  void MergeFrom(const JoinNewGameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetGameInfo gameInfo = 1;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 1;
  inline const ::NetGameInfo& gameinfo() const;
  inline ::NetGameInfo* mutable_gameinfo();
  inline ::NetGameInfo* release_gameinfo();
  inline void set_allocated_gameinfo(::NetGameInfo* gameinfo);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool autoLeave = 3;
  inline bool has_autoleave() const;
  inline void clear_autoleave();
  static const int kAutoLeaveFieldNumber = 3;
  inline bool autoleave() const;
  inline void set_autoleave(bool value);

  // @@protoc_insertion_point(class_scope:JoinNewGameMessage)
 private:
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_autoleave();
  inline void clear_has_autoleave();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetGameInfo* gameinfo_;
  ::std::string* password_;
  bool autoleave_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static JoinNewGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class RejoinExistingGameMessage : public ::google::protobuf::MessageLite {
 public:
  RejoinExistingGameMessage();
  virtual ~RejoinExistingGameMessage();

  RejoinExistingGameMessage(const RejoinExistingGameMessage& from);

  inline RejoinExistingGameMessage& operator=(const RejoinExistingGameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RejoinExistingGameMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RejoinExistingGameMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RejoinExistingGameMessage* other);

  // implements Message ----------------------------------------------

  RejoinExistingGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RejoinExistingGameMessage& from);
  void MergeFrom(const RejoinExistingGameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional bool autoLeave = 2;
  inline bool has_autoleave() const;
  inline void clear_autoleave();
  static const int kAutoLeaveFieldNumber = 2;
  inline bool autoleave() const;
  inline void set_autoleave(bool value);

  // @@protoc_insertion_point(class_scope:RejoinExistingGameMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_autoleave();
  inline void clear_has_autoleave();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  bool autoleave_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static RejoinExistingGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class JoinGameAckMessage : public ::google::protobuf::MessageLite {
 public:
  JoinGameAckMessage();
  virtual ~JoinGameAckMessage();

  JoinGameAckMessage(const JoinGameAckMessage& from);

  inline JoinGameAckMessage& operator=(const JoinGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const JoinGameAckMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinGameAckMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinGameAckMessage* other);

  // implements Message ----------------------------------------------

  JoinGameAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinGameAckMessage& from);
  void MergeFrom(const JoinGameAckMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required bool areYouGameAdmin = 2;
  inline bool has_areyougameadmin() const;
  inline void clear_areyougameadmin();
  static const int kAreYouGameAdminFieldNumber = 2;
  inline bool areyougameadmin() const;
  inline void set_areyougameadmin(bool value);

  // required .NetGameInfo gameInfo = 3;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 3;
  inline const ::NetGameInfo& gameinfo() const;
  inline ::NetGameInfo* mutable_gameinfo();
  inline ::NetGameInfo* release_gameinfo();
  inline void set_allocated_gameinfo(::NetGameInfo* gameinfo);

  // optional bool spectateOnly = 4;
  inline bool has_spectateonly() const;
  inline void clear_spectateonly();
  static const int kSpectateOnlyFieldNumber = 4;
  inline bool spectateonly() const;
  inline void set_spectateonly(bool value);

  // @@protoc_insertion_point(class_scope:JoinGameAckMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_areyougameadmin();
  inline void clear_has_areyougameadmin();
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_spectateonly();
  inline void clear_has_spectateonly();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  bool areyougameadmin_;
  bool spectateonly_;
  ::NetGameInfo* gameinfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static JoinGameAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class JoinGameFailedMessage : public ::google::protobuf::MessageLite {
 public:
  JoinGameFailedMessage();
  virtual ~JoinGameFailedMessage();

  JoinGameFailedMessage(const JoinGameFailedMessage& from);

  inline JoinGameFailedMessage& operator=(const JoinGameFailedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const JoinGameFailedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinGameFailedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinGameFailedMessage* other);

  // implements Message ----------------------------------------------

  JoinGameFailedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinGameFailedMessage& from);
  void MergeFrom(const JoinGameFailedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef JoinGameFailedMessage_JoinGameFailureReason JoinGameFailureReason;
  static const JoinGameFailureReason invalidGame = JoinGameFailedMessage_JoinGameFailureReason_invalidGame;
  static const JoinGameFailureReason gameIsFull = JoinGameFailedMessage_JoinGameFailureReason_gameIsFull;
  static const JoinGameFailureReason gameIsRunning = JoinGameFailedMessage_JoinGameFailureReason_gameIsRunning;
  static const JoinGameFailureReason invalidPassword = JoinGameFailedMessage_JoinGameFailureReason_invalidPassword;
  static const JoinGameFailureReason notAllowedAsGuest = JoinGameFailedMessage_JoinGameFailureReason_notAllowedAsGuest;
  static const JoinGameFailureReason notInvited = JoinGameFailedMessage_JoinGameFailureReason_notInvited;
  static const JoinGameFailureReason gameNameInUse = JoinGameFailedMessage_JoinGameFailureReason_gameNameInUse;
  static const JoinGameFailureReason badGameName = JoinGameFailedMessage_JoinGameFailureReason_badGameName;
  static const JoinGameFailureReason invalidSettings = JoinGameFailedMessage_JoinGameFailureReason_invalidSettings;
  static const JoinGameFailureReason ipAddressBlocked = JoinGameFailedMessage_JoinGameFailureReason_ipAddressBlocked;
  static const JoinGameFailureReason rejoinFailed = JoinGameFailedMessage_JoinGameFailureReason_rejoinFailed;
  static const JoinGameFailureReason noSpectatorsAllowed = JoinGameFailedMessage_JoinGameFailureReason_noSpectatorsAllowed;
  static const JoinGameFailureReason noContactRule = JoinGameFailedMessage_JoinGameFailureReason_noContactRule;
  static inline bool JoinGameFailureReason_IsValid(int value) {
    return JoinGameFailedMessage_JoinGameFailureReason_IsValid(value);
  }
  static const JoinGameFailureReason JoinGameFailureReason_MIN =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MIN;
  static const JoinGameFailureReason JoinGameFailureReason_MAX =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX;
  static const int JoinGameFailureReason_ARRAYSIZE =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
  inline bool has_joingamefailurereason() const;
  inline void clear_joingamefailurereason();
  static const int kJoinGameFailureReasonFieldNumber = 2;
  inline ::JoinGameFailedMessage_JoinGameFailureReason joingamefailurereason() const;
  inline void set_joingamefailurereason(::JoinGameFailedMessage_JoinGameFailureReason value);

  // @@protoc_insertion_point(class_scope:JoinGameFailedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_joingamefailurereason();
  inline void clear_has_joingamefailurereason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int joingamefailurereason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static JoinGameFailedMessage* default_instance_;
};
// -------------------------------------------------------------------

class GamePlayerJoinedMessage : public ::google::protobuf::MessageLite {
 public:
  GamePlayerJoinedMessage();
  virtual ~GamePlayerJoinedMessage();

  GamePlayerJoinedMessage(const GamePlayerJoinedMessage& from);

  inline GamePlayerJoinedMessage& operator=(const GamePlayerJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GamePlayerJoinedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GamePlayerJoinedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GamePlayerJoinedMessage* other);

  // implements Message ----------------------------------------------

  GamePlayerJoinedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GamePlayerJoinedMessage& from);
  void MergeFrom(const GamePlayerJoinedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required bool isGameAdmin = 3;
  inline bool has_isgameadmin() const;
  inline void clear_isgameadmin();
  static const int kIsGameAdminFieldNumber = 3;
  inline bool isgameadmin() const;
  inline void set_isgameadmin(bool value);

  // @@protoc_insertion_point(class_scope:GamePlayerJoinedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_isgameadmin();
  inline void clear_has_isgameadmin();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  bool isgameadmin_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GamePlayerJoinedMessage* default_instance_;
};
// -------------------------------------------------------------------

class GamePlayerLeftMessage : public ::google::protobuf::MessageLite {
 public:
  GamePlayerLeftMessage();
  virtual ~GamePlayerLeftMessage();

  GamePlayerLeftMessage(const GamePlayerLeftMessage& from);

  inline GamePlayerLeftMessage& operator=(const GamePlayerLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GamePlayerLeftMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GamePlayerLeftMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GamePlayerLeftMessage* other);

  // implements Message ----------------------------------------------

  GamePlayerLeftMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GamePlayerLeftMessage& from);
  void MergeFrom(const GamePlayerLeftMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftReason;
  static const GamePlayerLeftReason leftOnRequest = GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest;
  static const GamePlayerLeftReason leftKicked = GamePlayerLeftMessage_GamePlayerLeftReason_leftKicked;
  static const GamePlayerLeftReason leftError = GamePlayerLeftMessage_GamePlayerLeftReason_leftError;
  static inline bool GamePlayerLeftReason_IsValid(int value) {
    return GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value);
  }
  static const GamePlayerLeftReason GamePlayerLeftReason_MIN =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MIN;
  static const GamePlayerLeftReason GamePlayerLeftReason_MAX =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX;
  static const int GamePlayerLeftReason_ARRAYSIZE =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
  inline bool has_gameplayerleftreason() const;
  inline void clear_gameplayerleftreason();
  static const int kGamePlayerLeftReasonFieldNumber = 3;
  inline ::GamePlayerLeftMessage_GamePlayerLeftReason gameplayerleftreason() const;
  inline void set_gameplayerleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value);

  // @@protoc_insertion_point(class_scope:GamePlayerLeftMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gameplayerleftreason();
  inline void clear_has_gameplayerleftreason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gameplayerleftreason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GamePlayerLeftMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameSpectatorJoinedMessage : public ::google::protobuf::MessageLite {
 public:
  GameSpectatorJoinedMessage();
  virtual ~GameSpectatorJoinedMessage();

  GameSpectatorJoinedMessage(const GameSpectatorJoinedMessage& from);

  inline GameSpectatorJoinedMessage& operator=(const GameSpectatorJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameSpectatorJoinedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameSpectatorJoinedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameSpectatorJoinedMessage* other);

  // implements Message ----------------------------------------------

  GameSpectatorJoinedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameSpectatorJoinedMessage& from);
  void MergeFrom(const GameSpectatorJoinedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameSpectatorJoinedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameSpectatorJoinedMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameSpectatorLeftMessage : public ::google::protobuf::MessageLite {
 public:
  GameSpectatorLeftMessage();
  virtual ~GameSpectatorLeftMessage();

  GameSpectatorLeftMessage(const GameSpectatorLeftMessage& from);

  inline GameSpectatorLeftMessage& operator=(const GameSpectatorLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameSpectatorLeftMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameSpectatorLeftMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameSpectatorLeftMessage* other);

  // implements Message ----------------------------------------------

  GameSpectatorLeftMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameSpectatorLeftMessage& from);
  void MergeFrom(const GameSpectatorLeftMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required .GamePlayerLeftMessage.GamePlayerLeftReason gameSpectatorLeftReason = 3;
  inline bool has_gamespectatorleftreason() const;
  inline void clear_gamespectatorleftreason();
  static const int kGameSpectatorLeftReasonFieldNumber = 3;
  inline ::GamePlayerLeftMessage_GamePlayerLeftReason gamespectatorleftreason() const;
  inline void set_gamespectatorleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value);

  // @@protoc_insertion_point(class_scope:GameSpectatorLeftMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gamespectatorleftreason();
  inline void clear_has_gamespectatorleftreason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gamespectatorleftreason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameSpectatorLeftMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameAdminChangedMessage : public ::google::protobuf::MessageLite {
 public:
  GameAdminChangedMessage();
  virtual ~GameAdminChangedMessage();

  GameAdminChangedMessage(const GameAdminChangedMessage& from);

  inline GameAdminChangedMessage& operator=(const GameAdminChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameAdminChangedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameAdminChangedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameAdminChangedMessage* other);

  // implements Message ----------------------------------------------

  GameAdminChangedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameAdminChangedMessage& from);
  void MergeFrom(const GameAdminChangedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 newAdminPlayerId = 2;
  inline bool has_newadminplayerid() const;
  inline void clear_newadminplayerid();
  static const int kNewAdminPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 newadminplayerid() const;
  inline void set_newadminplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameAdminChangedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_newadminplayerid();
  inline void clear_has_newadminplayerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 newadminplayerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameAdminChangedMessage* default_instance_;
};
// -------------------------------------------------------------------

class RemovedFromGameMessage : public ::google::protobuf::MessageLite {
 public:
  RemovedFromGameMessage();
  virtual ~RemovedFromGameMessage();

  RemovedFromGameMessage(const RemovedFromGameMessage& from);

  inline RemovedFromGameMessage& operator=(const RemovedFromGameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RemovedFromGameMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemovedFromGameMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemovedFromGameMessage* other);

  // implements Message ----------------------------------------------

  RemovedFromGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemovedFromGameMessage& from);
  void MergeFrom(const RemovedFromGameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameReason;
  static const RemovedFromGameReason removedOnRequest = RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest;
  static const RemovedFromGameReason kickedFromGame = RemovedFromGameMessage_RemovedFromGameReason_kickedFromGame;
  static const RemovedFromGameReason gameIsFull = RemovedFromGameMessage_RemovedFromGameReason_gameIsFull;
  static const RemovedFromGameReason gameIsRunning = RemovedFromGameMessage_RemovedFromGameReason_gameIsRunning;
  static const RemovedFromGameReason gameTimeout = RemovedFromGameMessage_RemovedFromGameReason_gameTimeout;
  static const RemovedFromGameReason removedStartFailed = RemovedFromGameMessage_RemovedFromGameReason_removedStartFailed;
  static const RemovedFromGameReason gameClosed = RemovedFromGameMessage_RemovedFromGameReason_gameClosed;
  static inline bool RemovedFromGameReason_IsValid(int value) {
    return RemovedFromGameMessage_RemovedFromGameReason_IsValid(value);
  }
  static const RemovedFromGameReason RemovedFromGameReason_MIN =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MIN;
  static const RemovedFromGameReason RemovedFromGameReason_MAX =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX;
  static const int RemovedFromGameReason_ARRAYSIZE =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
  inline bool has_removedfromgamereason() const;
  inline void clear_removedfromgamereason();
  static const int kRemovedFromGameReasonFieldNumber = 2;
  inline ::RemovedFromGameMessage_RemovedFromGameReason removedfromgamereason() const;
  inline void set_removedfromgamereason(::RemovedFromGameMessage_RemovedFromGameReason value);

  // @@protoc_insertion_point(class_scope:RemovedFromGameMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_removedfromgamereason();
  inline void clear_has_removedfromgamereason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int removedfromgamereason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static RemovedFromGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class KickPlayerRequestMessage : public ::google::protobuf::MessageLite {
 public:
  KickPlayerRequestMessage();
  virtual ~KickPlayerRequestMessage();

  KickPlayerRequestMessage(const KickPlayerRequestMessage& from);

  inline KickPlayerRequestMessage& operator=(const KickPlayerRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KickPlayerRequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KickPlayerRequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KickPlayerRequestMessage* other);

  // implements Message ----------------------------------------------

  KickPlayerRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KickPlayerRequestMessage& from);
  void MergeFrom(const KickPlayerRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KickPlayerRequestMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static KickPlayerRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class LeaveGameRequestMessage : public ::google::protobuf::MessageLite {
 public:
  LeaveGameRequestMessage();
  virtual ~LeaveGameRequestMessage();

  LeaveGameRequestMessage(const LeaveGameRequestMessage& from);

  inline LeaveGameRequestMessage& operator=(const LeaveGameRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LeaveGameRequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LeaveGameRequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LeaveGameRequestMessage* other);

  // implements Message ----------------------------------------------

  LeaveGameRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LeaveGameRequestMessage& from);
  void MergeFrom(const LeaveGameRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LeaveGameRequestMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static LeaveGameRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class InvitePlayerToGameMessage : public ::google::protobuf::MessageLite {
 public:
  InvitePlayerToGameMessage();
  virtual ~InvitePlayerToGameMessage();

  InvitePlayerToGameMessage(const InvitePlayerToGameMessage& from);

  inline InvitePlayerToGameMessage& operator=(const InvitePlayerToGameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InvitePlayerToGameMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InvitePlayerToGameMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InvitePlayerToGameMessage* other);

  // implements Message ----------------------------------------------

  InvitePlayerToGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InvitePlayerToGameMessage& from);
  void MergeFrom(const InvitePlayerToGameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:InvitePlayerToGameMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static InvitePlayerToGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class InviteNotifyMessage : public ::google::protobuf::MessageLite {
 public:
  InviteNotifyMessage();
  virtual ~InviteNotifyMessage();

  InviteNotifyMessage(const InviteNotifyMessage& from);

  inline InviteNotifyMessage& operator=(const InviteNotifyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InviteNotifyMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InviteNotifyMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InviteNotifyMessage* other);

  // implements Message ----------------------------------------------

  InviteNotifyMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InviteNotifyMessage& from);
  void MergeFrom(const InviteNotifyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerIdWho = 2;
  inline bool has_playeridwho() const;
  inline void clear_playeridwho();
  static const int kPlayerIdWhoFieldNumber = 2;
  inline ::google::protobuf::uint32 playeridwho() const;
  inline void set_playeridwho(::google::protobuf::uint32 value);

  // required uint32 playerIdByWhom = 3;
  inline bool has_playeridbywhom() const;
  inline void clear_playeridbywhom();
  static const int kPlayerIdByWhomFieldNumber = 3;
  inline ::google::protobuf::uint32 playeridbywhom() const;
  inline void set_playeridbywhom(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:InviteNotifyMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playeridwho();
  inline void clear_has_playeridwho();
  inline void set_has_playeridbywhom();
  inline void clear_has_playeridbywhom();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playeridwho_;
  ::google::protobuf::uint32 playeridbywhom_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static InviteNotifyMessage* default_instance_;
};
// -------------------------------------------------------------------

class RejectGameInvitationMessage : public ::google::protobuf::MessageLite {
 public:
  RejectGameInvitationMessage();
  virtual ~RejectGameInvitationMessage();

  RejectGameInvitationMessage(const RejectGameInvitationMessage& from);

  inline RejectGameInvitationMessage& operator=(const RejectGameInvitationMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RejectGameInvitationMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RejectGameInvitationMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RejectGameInvitationMessage* other);

  // implements Message ----------------------------------------------

  RejectGameInvitationMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RejectGameInvitationMessage& from);
  void MergeFrom(const RejectGameInvitationMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RejectGameInvitationMessage_RejectGameInvReason RejectGameInvReason;
  static const RejectGameInvReason rejectReasonNo = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo;
  static const RejectGameInvReason rejectReasonBusy = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy;
  static inline bool RejectGameInvReason_IsValid(int value) {
    return RejectGameInvitationMessage_RejectGameInvReason_IsValid(value);
  }
  static const RejectGameInvReason RejectGameInvReason_MIN =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MIN;
  static const RejectGameInvReason RejectGameInvReason_MAX =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX;
  static const int RejectGameInvReason_ARRAYSIZE =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
  inline bool has_myrejectreason() const;
  inline void clear_myrejectreason();
  static const int kMyRejectReasonFieldNumber = 2;
  inline ::RejectGameInvitationMessage_RejectGameInvReason myrejectreason() const;
  inline void set_myrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value);

  // @@protoc_insertion_point(class_scope:RejectGameInvitationMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_myrejectreason();
  inline void clear_has_myrejectreason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int myrejectreason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static RejectGameInvitationMessage* default_instance_;
};
// -------------------------------------------------------------------

class RejectInvNotifyMessage : public ::google::protobuf::MessageLite {
 public:
  RejectInvNotifyMessage();
  virtual ~RejectInvNotifyMessage();

  RejectInvNotifyMessage(const RejectInvNotifyMessage& from);

  inline RejectInvNotifyMessage& operator=(const RejectInvNotifyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RejectInvNotifyMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RejectInvNotifyMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RejectInvNotifyMessage* other);

  // implements Message ----------------------------------------------

  RejectInvNotifyMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RejectInvNotifyMessage& from);
  void MergeFrom(const RejectInvNotifyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
  inline bool has_playerrejectreason() const;
  inline void clear_playerrejectreason();
  static const int kPlayerRejectReasonFieldNumber = 3;
  inline ::RejectGameInvitationMessage_RejectGameInvReason playerrejectreason() const;
  inline void set_playerrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value);

  // @@protoc_insertion_point(class_scope:RejectInvNotifyMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playerrejectreason();
  inline void clear_has_playerrejectreason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int playerrejectreason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static RejectInvNotifyMessage* default_instance_;
};
// -------------------------------------------------------------------

class StartEventMessage : public ::google::protobuf::MessageLite {
 public:
  StartEventMessage();
  virtual ~StartEventMessage();

  StartEventMessage(const StartEventMessage& from);

  inline StartEventMessage& operator=(const StartEventMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartEventMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartEventMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartEventMessage* other);

  // implements Message ----------------------------------------------

  StartEventMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartEventMessage& from);
  void MergeFrom(const StartEventMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef StartEventMessage_StartEventType StartEventType;
  static const StartEventType startEvent = StartEventMessage_StartEventType_startEvent;
  static const StartEventType rejoinEvent = StartEventMessage_StartEventType_rejoinEvent;
  static inline bool StartEventType_IsValid(int value) {
    return StartEventMessage_StartEventType_IsValid(value);
  }
  static const StartEventType StartEventType_MIN =
    StartEventMessage_StartEventType_StartEventType_MIN;
  static const StartEventType StartEventType_MAX =
    StartEventMessage_StartEventType_StartEventType_MAX;
  static const int StartEventType_ARRAYSIZE =
    StartEventMessage_StartEventType_StartEventType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required .StartEventMessage.StartEventType startEventType = 2;
  inline bool has_starteventtype() const;
  inline void clear_starteventtype();
  static const int kStartEventTypeFieldNumber = 2;
  inline ::StartEventMessage_StartEventType starteventtype() const;
  inline void set_starteventtype(::StartEventMessage_StartEventType value);

  // optional bool fillWithComputerPlayers = 3;
  inline bool has_fillwithcomputerplayers() const;
  inline void clear_fillwithcomputerplayers();
  static const int kFillWithComputerPlayersFieldNumber = 3;
  inline bool fillwithcomputerplayers() const;
  inline void set_fillwithcomputerplayers(bool value);

  // @@protoc_insertion_point(class_scope:StartEventMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_starteventtype();
  inline void clear_has_starteventtype();
  inline void set_has_fillwithcomputerplayers();
  inline void clear_has_fillwithcomputerplayers();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int starteventtype_;
  bool fillwithcomputerplayers_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static StartEventMessage* default_instance_;
};
// -------------------------------------------------------------------

class StartEventAckMessage : public ::google::protobuf::MessageLite {
 public:
  StartEventAckMessage();
  virtual ~StartEventAckMessage();

  StartEventAckMessage(const StartEventAckMessage& from);

  inline StartEventAckMessage& operator=(const StartEventAckMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartEventAckMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartEventAckMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartEventAckMessage* other);

  // implements Message ----------------------------------------------

  StartEventAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartEventAckMessage& from);
  void MergeFrom(const StartEventAckMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:StartEventAckMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static StartEventAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameStartInitialMessage : public ::google::protobuf::MessageLite {
 public:
  GameStartInitialMessage();
  virtual ~GameStartInitialMessage();

  GameStartInitialMessage(const GameStartInitialMessage& from);

  inline GameStartInitialMessage& operator=(const GameStartInitialMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameStartInitialMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameStartInitialMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameStartInitialMessage* other);

  // implements Message ----------------------------------------------

  GameStartInitialMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameStartInitialMessage& from);
  void MergeFrom(const GameStartInitialMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 startDealerPlayerId = 2;
  inline bool has_startdealerplayerid() const;
  inline void clear_startdealerplayerid();
  static const int kStartDealerPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 startdealerplayerid() const;
  inline void set_startdealerplayerid(::google::protobuf::uint32 value);

  // repeated uint32 playerSeats = 3 [packed = true];
  inline int playerseats_size() const;
  inline void clear_playerseats();
  static const int kPlayerSeatsFieldNumber = 3;
  inline ::google::protobuf::uint32 playerseats(int index) const;
  inline void set_playerseats(int index, ::google::protobuf::uint32 value);
  inline void add_playerseats(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      playerseats() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_playerseats();

  // @@protoc_insertion_point(class_scope:GameStartInitialMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_startdealerplayerid();
  inline void clear_has_startdealerplayerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 startdealerplayerid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > playerseats_;
  mutable int _playerseats_cached_byte_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameStartInitialMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameStartRejoinMessage_RejoinPlayerData : public ::google::protobuf::MessageLite {
 public:
  GameStartRejoinMessage_RejoinPlayerData();
  virtual ~GameStartRejoinMessage_RejoinPlayerData();

  GameStartRejoinMessage_RejoinPlayerData(const GameStartRejoinMessage_RejoinPlayerData& from);

  inline GameStartRejoinMessage_RejoinPlayerData& operator=(const GameStartRejoinMessage_RejoinPlayerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameStartRejoinMessage_RejoinPlayerData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameStartRejoinMessage_RejoinPlayerData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameStartRejoinMessage_RejoinPlayerData* other);

  // implements Message ----------------------------------------------

  GameStartRejoinMessage_RejoinPlayerData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameStartRejoinMessage_RejoinPlayerData& from);
  void MergeFrom(const GameStartRejoinMessage_RejoinPlayerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required uint32 playerMoney = 2;
  inline bool has_playermoney() const;
  inline void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 2;
  inline ::google::protobuf::uint32 playermoney() const;
  inline void set_playermoney(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameStartRejoinMessage.RejoinPlayerData)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playermoney();
  inline void clear_has_playermoney();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 playermoney_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameStartRejoinMessage_RejoinPlayerData* default_instance_;
};
// -------------------------------------------------------------------

class GameStartRejoinMessage : public ::google::protobuf::MessageLite {
 public:
  GameStartRejoinMessage();
  virtual ~GameStartRejoinMessage();

  GameStartRejoinMessage(const GameStartRejoinMessage& from);

  inline GameStartRejoinMessage& operator=(const GameStartRejoinMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GameStartRejoinMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameStartRejoinMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameStartRejoinMessage* other);

  // implements Message ----------------------------------------------

  GameStartRejoinMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameStartRejoinMessage& from);
  void MergeFrom(const GameStartRejoinMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GameStartRejoinMessage_RejoinPlayerData RejoinPlayerData;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 startDealerPlayerId = 2;
  inline bool has_startdealerplayerid() const;
  inline void clear_startdealerplayerid();
  static const int kStartDealerPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 startdealerplayerid() const;
  inline void set_startdealerplayerid(::google::protobuf::uint32 value);

  // required uint32 handNum = 3;
  inline bool has_handnum() const;
  inline void clear_handnum();
  static const int kHandNumFieldNumber = 3;
  inline ::google::protobuf::uint32 handnum() const;
  inline void set_handnum(::google::protobuf::uint32 value);

  // repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
  inline int rejoinplayerdata_size() const;
  inline void clear_rejoinplayerdata();
  static const int kRejoinPlayerDataFieldNumber = 4;
  inline const ::GameStartRejoinMessage_RejoinPlayerData& rejoinplayerdata(int index) const;
  inline ::GameStartRejoinMessage_RejoinPlayerData* mutable_rejoinplayerdata(int index);
  inline ::GameStartRejoinMessage_RejoinPlayerData* add_rejoinplayerdata();
  inline const ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >&
      rejoinplayerdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >*
      mutable_rejoinplayerdata();

  // @@protoc_insertion_point(class_scope:GameStartRejoinMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_startdealerplayerid();
  inline void clear_has_startdealerplayerid();
  inline void set_has_handnum();
  inline void clear_has_handnum();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 startdealerplayerid_;
  ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData > rejoinplayerdata_;
  ::google::protobuf::uint32 handnum_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static GameStartRejoinMessage* default_instance_;
};
// -------------------------------------------------------------------

class HandStartMessage_PlainCards : public ::google::protobuf::MessageLite {
 public:
  HandStartMessage_PlainCards();
  virtual ~HandStartMessage_PlainCards();

  HandStartMessage_PlainCards(const HandStartMessage_PlainCards& from);

  inline HandStartMessage_PlainCards& operator=(const HandStartMessage_PlainCards& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HandStartMessage_PlainCards& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HandStartMessage_PlainCards* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HandStartMessage_PlainCards* other);

  // implements Message ----------------------------------------------

  HandStartMessage_PlainCards* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HandStartMessage_PlainCards& from);
  void MergeFrom(const HandStartMessage_PlainCards& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 plainCard1 = 1;
  inline bool has_plaincard1() const;
  inline void clear_plaincard1();
  static const int kPlainCard1FieldNumber = 1;
  inline ::google::protobuf::uint32 plaincard1() const;
  inline void set_plaincard1(::google::protobuf::uint32 value);

  // required uint32 plainCard2 = 2;
  inline bool has_plaincard2() const;
  inline void clear_plaincard2();
  static const int kPlainCard2FieldNumber = 2;
  inline ::google::protobuf::uint32 plaincard2() const;
  inline void set_plaincard2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HandStartMessage.PlainCards)
 private:
  inline void set_has_plaincard1();
  inline void clear_has_plaincard1();
  inline void set_has_plaincard2();
  inline void clear_has_plaincard2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 plaincard1_;
  ::google::protobuf::uint32 plaincard2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static HandStartMessage_PlainCards* default_instance_;
};
// -------------------------------------------------------------------

class HandStartMessage : public ::google::protobuf::MessageLite {
 public:
  HandStartMessage();
  virtual ~HandStartMessage();

  HandStartMessage(const HandStartMessage& from);

  inline HandStartMessage& operator=(const HandStartMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HandStartMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HandStartMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HandStartMessage* other);

  // implements Message ----------------------------------------------

  HandStartMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HandStartMessage& from);
  void MergeFrom(const HandStartMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HandStartMessage_PlainCards PlainCards;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional .HandStartMessage.PlainCards plainCards = 2;
  inline bool has_plaincards() const;
  inline void clear_plaincards();
  static const int kPlainCardsFieldNumber = 2;
  inline const ::HandStartMessage_PlainCards& plaincards() const;
  inline ::HandStartMessage_PlainCards* mutable_plaincards();
  inline ::HandStartMessage_PlainCards* release_plaincards();
  inline void set_allocated_plaincards(::HandStartMessage_PlainCards* plaincards);

  // optional bytes encryptedCards = 3;
  inline bool has_encryptedcards() const;
  inline void clear_encryptedcards();
  static const int kEncryptedCardsFieldNumber = 3;
  inline const ::std::string& encryptedcards() const;
  inline void set_encryptedcards(const ::std::string& value);
  inline void set_encryptedcards(const char* value);
  inline void set_encryptedcards(const void* value, size_t size);
  inline ::std::string* mutable_encryptedcards();
  inline ::std::string* release_encryptedcards();
  inline void set_allocated_encryptedcards(::std::string* encryptedcards);

  // required uint32 smallBlind = 4;
  inline bool has_smallblind() const;
  inline void clear_smallblind();
  static const int kSmallBlindFieldNumber = 4;
  inline ::google::protobuf::uint32 smallblind() const;
  inline void set_smallblind(::google::protobuf::uint32 value);

  // repeated .NetPlayerState seatStates = 5;
  inline int seatstates_size() const;
  inline void clear_seatstates();
  static const int kSeatStatesFieldNumber = 5;
  inline ::NetPlayerState seatstates(int index) const;
  inline void set_seatstates(int index, ::NetPlayerState value);
  inline void add_seatstates(::NetPlayerState value);
  inline const ::google::protobuf::RepeatedField<int>& seatstates() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_seatstates();

  // optional uint32 dealerPlayerId = 6;
  inline bool has_dealerplayerid() const;
  inline void clear_dealerplayerid();
  static const int kDealerPlayerIdFieldNumber = 6;
  inline ::google::protobuf::uint32 dealerplayerid() const;
  inline void set_dealerplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HandStartMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_plaincards();
  inline void clear_has_plaincards();
  inline void set_has_encryptedcards();
  inline void clear_has_encryptedcards();
  inline void set_has_smallblind();
  inline void clear_has_smallblind();
  inline void set_has_dealerplayerid();
  inline void clear_has_dealerplayerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::HandStartMessage_PlainCards* plaincards_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 smallblind_;
  ::std::string* encryptedcards_;
  ::google::protobuf::RepeatedField<int> seatstates_;
  ::google::protobuf::uint32 dealerplayerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static HandStartMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayersTurnMessage : public ::google::protobuf::MessageLite {
 public:
  PlayersTurnMessage();
  virtual ~PlayersTurnMessage();

  PlayersTurnMessage(const PlayersTurnMessage& from);

  inline PlayersTurnMessage& operator=(const PlayersTurnMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayersTurnMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayersTurnMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayersTurnMessage* other);

  // implements Message ----------------------------------------------

  PlayersTurnMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayersTurnMessage& from);
  void MergeFrom(const PlayersTurnMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required .NetGameState gameState = 3;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 3;
  inline ::NetGameState gamestate() const;
  inline void set_gamestate(::NetGameState value);

  // @@protoc_insertion_point(class_scope:PlayersTurnMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gamestate_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static PlayersTurnMessage* default_instance_;
};
// -------------------------------------------------------------------

class MyActionRequestMessage : public ::google::protobuf::MessageLite {
 public:
  MyActionRequestMessage();
  virtual ~MyActionRequestMessage();

  MyActionRequestMessage(const MyActionRequestMessage& from);

  inline MyActionRequestMessage& operator=(const MyActionRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MyActionRequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MyActionRequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MyActionRequestMessage* other);

  // implements Message ----------------------------------------------

  MyActionRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MyActionRequestMessage& from);
  void MergeFrom(const MyActionRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 handNum = 2;
  inline bool has_handnum() const;
  inline void clear_handnum();
  static const int kHandNumFieldNumber = 2;
  inline ::google::protobuf::uint32 handnum() const;
  inline void set_handnum(::google::protobuf::uint32 value);

  // required .NetGameState gameState = 3;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 3;
  inline ::NetGameState gamestate() const;
  inline void set_gamestate(::NetGameState value);

  // required .NetPlayerAction myAction = 4;
  inline bool has_myaction() const;
  inline void clear_myaction();
  static const int kMyActionFieldNumber = 4;
  inline ::NetPlayerAction myaction() const;
  inline void set_myaction(::NetPlayerAction value);

  // required uint32 myRelativeBet = 5;
  inline bool has_myrelativebet() const;
  inline void clear_myrelativebet();
  static const int kMyRelativeBetFieldNumber = 5;
  inline ::google::protobuf::uint32 myrelativebet() const;
  inline void set_myrelativebet(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MyActionRequestMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_handnum();
  inline void clear_has_handnum();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  inline void set_has_myaction();
  inline void clear_has_myaction();
  inline void set_has_myrelativebet();
  inline void clear_has_myrelativebet();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 handnum_;
  int gamestate_;
  int myaction_;
  ::google::protobuf::uint32 myrelativebet_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static MyActionRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class YourActionRejectedMessage : public ::google::protobuf::MessageLite {
 public:
  YourActionRejectedMessage();
  virtual ~YourActionRejectedMessage();

  YourActionRejectedMessage(const YourActionRejectedMessage& from);

  inline YourActionRejectedMessage& operator=(const YourActionRejectedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const YourActionRejectedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const YourActionRejectedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(YourActionRejectedMessage* other);

  // implements Message ----------------------------------------------

  YourActionRejectedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const YourActionRejectedMessage& from);
  void MergeFrom(const YourActionRejectedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef YourActionRejectedMessage_RejectionReason RejectionReason;
  static const RejectionReason rejectedInvalidGameState = YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState;
  static const RejectionReason rejectedNotYourTurn = YourActionRejectedMessage_RejectionReason_rejectedNotYourTurn;
  static const RejectionReason rejectedActionNotAllowed = YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed;
  static inline bool RejectionReason_IsValid(int value) {
    return YourActionRejectedMessage_RejectionReason_IsValid(value);
  }
  static const RejectionReason RejectionReason_MIN =
    YourActionRejectedMessage_RejectionReason_RejectionReason_MIN;
  static const RejectionReason RejectionReason_MAX =
    YourActionRejectedMessage_RejectionReason_RejectionReason_MAX;
  static const int RejectionReason_ARRAYSIZE =
    YourActionRejectedMessage_RejectionReason_RejectionReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required .NetGameState gameState = 2;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 2;
  inline ::NetGameState gamestate() const;
  inline void set_gamestate(::NetGameState value);

  // required .NetPlayerAction yourAction = 3;
  inline bool has_youraction() const;
  inline void clear_youraction();
  static const int kYourActionFieldNumber = 3;
  inline ::NetPlayerAction youraction() const;
  inline void set_youraction(::NetPlayerAction value);

  // required uint32 yourRelativeBet = 4;
  inline bool has_yourrelativebet() const;
  inline void clear_yourrelativebet();
  static const int kYourRelativeBetFieldNumber = 4;
  inline ::google::protobuf::uint32 yourrelativebet() const;
  inline void set_yourrelativebet(::google::protobuf::uint32 value);

  // required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
  inline bool has_rejectionreason() const;
  inline void clear_rejectionreason();
  static const int kRejectionReasonFieldNumber = 5;
  inline ::YourActionRejectedMessage_RejectionReason rejectionreason() const;
  inline void set_rejectionreason(::YourActionRejectedMessage_RejectionReason value);

  // @@protoc_insertion_point(class_scope:YourActionRejectedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  inline void set_has_youraction();
  inline void clear_has_youraction();
  inline void set_has_yourrelativebet();
  inline void clear_has_yourrelativebet();
  inline void set_has_rejectionreason();
  inline void clear_has_rejectionreason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int gamestate_;
  int youraction_;
  ::google::protobuf::uint32 yourrelativebet_;
  int rejectionreason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static YourActionRejectedMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayersActionDoneMessage : public ::google::protobuf::MessageLite {
 public:
  PlayersActionDoneMessage();
  virtual ~PlayersActionDoneMessage();

  PlayersActionDoneMessage(const PlayersActionDoneMessage& from);

  inline PlayersActionDoneMessage& operator=(const PlayersActionDoneMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayersActionDoneMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayersActionDoneMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayersActionDoneMessage* other);

  // implements Message ----------------------------------------------

  PlayersActionDoneMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayersActionDoneMessage& from);
  void MergeFrom(const PlayersActionDoneMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required .NetGameState gameState = 3;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 3;
  inline ::NetGameState gamestate() const;
  inline void set_gamestate(::NetGameState value);

  // required .NetPlayerAction playerAction = 4;
  inline bool has_playeraction() const;
  inline void clear_playeraction();
  static const int kPlayerActionFieldNumber = 4;
  inline ::NetPlayerAction playeraction() const;
  inline void set_playeraction(::NetPlayerAction value);

  // required uint32 totalPlayerBet = 5;
  inline bool has_totalplayerbet() const;
  inline void clear_totalplayerbet();
  static const int kTotalPlayerBetFieldNumber = 5;
  inline ::google::protobuf::uint32 totalplayerbet() const;
  inline void set_totalplayerbet(::google::protobuf::uint32 value);

  // required uint32 playerMoney = 6;
  inline bool has_playermoney() const;
  inline void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 6;
  inline ::google::protobuf::uint32 playermoney() const;
  inline void set_playermoney(::google::protobuf::uint32 value);

  // required uint32 highestSet = 7;
  inline bool has_highestset() const;
  inline void clear_highestset();
  static const int kHighestSetFieldNumber = 7;
  inline ::google::protobuf::uint32 highestset() const;
  inline void set_highestset(::google::protobuf::uint32 value);

  // required uint32 minimumRaise = 8;
  inline bool has_minimumraise() const;
  inline void clear_minimumraise();
  static const int kMinimumRaiseFieldNumber = 8;
  inline ::google::protobuf::uint32 minimumraise() const;
  inline void set_minimumraise(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PlayersActionDoneMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  inline void set_has_playeraction();
  inline void clear_has_playeraction();
  inline void set_has_totalplayerbet();
  inline void clear_has_totalplayerbet();
  inline void set_has_playermoney();
  inline void clear_has_playermoney();
  inline void set_has_highestset();
  inline void clear_has_highestset();
  inline void set_has_minimumraise();
  inline void clear_has_minimumraise();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gamestate_;
  int playeraction_;
  ::google::protobuf::uint32 totalplayerbet_;
  ::google::protobuf::uint32 playermoney_;
  ::google::protobuf::uint32 highestset_;
  ::google::protobuf::uint32 minimumraise_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static PlayersActionDoneMessage* default_instance_;
};
// -------------------------------------------------------------------

class DealFlopCardsMessage : public ::google::protobuf::MessageLite {
 public:
  DealFlopCardsMessage();
  virtual ~DealFlopCardsMessage();

  DealFlopCardsMessage(const DealFlopCardsMessage& from);

  inline DealFlopCardsMessage& operator=(const DealFlopCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DealFlopCardsMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DealFlopCardsMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DealFlopCardsMessage* other);

  // implements Message ----------------------------------------------

  DealFlopCardsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DealFlopCardsMessage& from);
  void MergeFrom(const DealFlopCardsMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 flopCard1 = 2;
  inline bool has_flopcard1() const;
  inline void clear_flopcard1();
  static const int kFlopCard1FieldNumber = 2;
  inline ::google::protobuf::uint32 flopcard1() const;
  inline void set_flopcard1(::google::protobuf::uint32 value);

  // required uint32 flopCard2 = 3;
  inline bool has_flopcard2() const;
  inline void clear_flopcard2();
  static const int kFlopCard2FieldNumber = 3;
  inline ::google::protobuf::uint32 flopcard2() const;
  inline void set_flopcard2(::google::protobuf::uint32 value);

  // required uint32 flopCard3 = 4;
  inline bool has_flopcard3() const;
  inline void clear_flopcard3();
  static const int kFlopCard3FieldNumber = 4;
  inline ::google::protobuf::uint32 flopcard3() const;
  inline void set_flopcard3(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DealFlopCardsMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_flopcard1();
  inline void clear_has_flopcard1();
  inline void set_has_flopcard2();
  inline void clear_has_flopcard2();
  inline void set_has_flopcard3();
  inline void clear_has_flopcard3();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 flopcard1_;
  ::google::protobuf::uint32 flopcard2_;
  ::google::protobuf::uint32 flopcard3_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static DealFlopCardsMessage* default_instance_;
};
// -------------------------------------------------------------------

class DealTurnCardMessage : public ::google::protobuf::MessageLite {
 public:
  DealTurnCardMessage();
  virtual ~DealTurnCardMessage();

  DealTurnCardMessage(const DealTurnCardMessage& from);

  inline DealTurnCardMessage& operator=(const DealTurnCardMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DealTurnCardMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DealTurnCardMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DealTurnCardMessage* other);

  // implements Message ----------------------------------------------

  DealTurnCardMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DealTurnCardMessage& from);
  void MergeFrom(const DealTurnCardMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 turnCard = 2;
  inline bool has_turncard() const;
  inline void clear_turncard();
  static const int kTurnCardFieldNumber = 2;
  inline ::google::protobuf::uint32 turncard() const;
  inline void set_turncard(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DealTurnCardMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_turncard();
  inline void clear_has_turncard();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 turncard_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static DealTurnCardMessage* default_instance_;
};
// -------------------------------------------------------------------

class DealRiverCardMessage : public ::google::protobuf::MessageLite {
 public:
  DealRiverCardMessage();
  virtual ~DealRiverCardMessage();

  DealRiverCardMessage(const DealRiverCardMessage& from);

  inline DealRiverCardMessage& operator=(const DealRiverCardMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DealRiverCardMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DealRiverCardMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DealRiverCardMessage* other);

  // implements Message ----------------------------------------------

  DealRiverCardMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DealRiverCardMessage& from);
  void MergeFrom(const DealRiverCardMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 riverCard = 2;
  inline bool has_rivercard() const;
  inline void clear_rivercard();
  static const int kRiverCardFieldNumber = 2;
  inline ::google::protobuf::uint32 rivercard() const;
  inline void set_rivercard(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DealRiverCardMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_rivercard();
  inline void clear_has_rivercard();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 rivercard_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static DealRiverCardMessage* default_instance_;
};
// -------------------------------------------------------------------

class AllInShowCardsMessage_PlayerAllIn : public ::google::protobuf::MessageLite {
 public:
  AllInShowCardsMessage_PlayerAllIn();
  virtual ~AllInShowCardsMessage_PlayerAllIn();

  AllInShowCardsMessage_PlayerAllIn(const AllInShowCardsMessage_PlayerAllIn& from);

  inline AllInShowCardsMessage_PlayerAllIn& operator=(const AllInShowCardsMessage_PlayerAllIn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AllInShowCardsMessage_PlayerAllIn& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AllInShowCardsMessage_PlayerAllIn* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AllInShowCardsMessage_PlayerAllIn* other);

  // implements Message ----------------------------------------------

  AllInShowCardsMessage_PlayerAllIn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AllInShowCardsMessage_PlayerAllIn& from);
  void MergeFrom(const AllInShowCardsMessage_PlayerAllIn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required uint32 allInCard1 = 2;
  inline bool has_allincard1() const;
  inline void clear_allincard1();
  static const int kAllInCard1FieldNumber = 2;
  inline ::google::protobuf::uint32 allincard1() const;
  inline void set_allincard1(::google::protobuf::uint32 value);

  // required uint32 allInCard2 = 3;
  inline bool has_allincard2() const;
  inline void clear_allincard2();
  static const int kAllInCard2FieldNumber = 3;
  inline ::google::protobuf::uint32 allincard2() const;
  inline void set_allincard2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AllInShowCardsMessage.PlayerAllIn)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_allincard1();
  inline void clear_has_allincard1();
  inline void set_has_allincard2();
  inline void clear_has_allincard2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 allincard1_;
  ::google::protobuf::uint32 allincard2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AllInShowCardsMessage_PlayerAllIn* default_instance_;
};
// -------------------------------------------------------------------

class AllInShowCardsMessage : public ::google::protobuf::MessageLite {
 public:
  AllInShowCardsMessage();
  virtual ~AllInShowCardsMessage();

  AllInShowCardsMessage(const AllInShowCardsMessage& from);

  inline AllInShowCardsMessage& operator=(const AllInShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AllInShowCardsMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AllInShowCardsMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AllInShowCardsMessage* other);

  // implements Message ----------------------------------------------

  AllInShowCardsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AllInShowCardsMessage& from);
  void MergeFrom(const AllInShowCardsMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AllInShowCardsMessage_PlayerAllIn PlayerAllIn;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
  inline int playersallin_size() const;
  inline void clear_playersallin();
  static const int kPlayersAllInFieldNumber = 2;
  inline const ::AllInShowCardsMessage_PlayerAllIn& playersallin(int index) const;
  inline ::AllInShowCardsMessage_PlayerAllIn* mutable_playersallin(int index);
  inline ::AllInShowCardsMessage_PlayerAllIn* add_playersallin();
  inline const ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >&
      playersallin() const;
  inline ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >*
      mutable_playersallin();

  // @@protoc_insertion_point(class_scope:AllInShowCardsMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn > playersallin_;
  ::google::protobuf::uint32 gameid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AllInShowCardsMessage* default_instance_;
};
// -------------------------------------------------------------------

class EndOfHandShowCardsMessage : public ::google::protobuf::MessageLite {
 public:
  EndOfHandShowCardsMessage();
  virtual ~EndOfHandShowCardsMessage();

  EndOfHandShowCardsMessage(const EndOfHandShowCardsMessage& from);

  inline EndOfHandShowCardsMessage& operator=(const EndOfHandShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EndOfHandShowCardsMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EndOfHandShowCardsMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EndOfHandShowCardsMessage* other);

  // implements Message ----------------------------------------------

  EndOfHandShowCardsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EndOfHandShowCardsMessage& from);
  void MergeFrom(const EndOfHandShowCardsMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // repeated .PlayerResult playerResults = 2;
  inline int playerresults_size() const;
  inline void clear_playerresults();
  static const int kPlayerResultsFieldNumber = 2;
  inline const ::PlayerResult& playerresults(int index) const;
  inline ::PlayerResult* mutable_playerresults(int index);
  inline ::PlayerResult* add_playerresults();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerResult >&
      playerresults() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerResult >*
      mutable_playerresults();

  // @@protoc_insertion_point(class_scope:EndOfHandShowCardsMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PlayerResult > playerresults_;
  ::google::protobuf::uint32 gameid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static EndOfHandShowCardsMessage* default_instance_;
};
// -------------------------------------------------------------------

class EndOfHandHideCardsMessage : public ::google::protobuf::MessageLite {
 public:
  EndOfHandHideCardsMessage();
  virtual ~EndOfHandHideCardsMessage();

  EndOfHandHideCardsMessage(const EndOfHandHideCardsMessage& from);

  inline EndOfHandHideCardsMessage& operator=(const EndOfHandHideCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EndOfHandHideCardsMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EndOfHandHideCardsMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EndOfHandHideCardsMessage* other);

  // implements Message ----------------------------------------------

  EndOfHandHideCardsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EndOfHandHideCardsMessage& from);
  void MergeFrom(const EndOfHandHideCardsMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required uint32 moneyWon = 3;
  inline bool has_moneywon() const;
  inline void clear_moneywon();
  static const int kMoneyWonFieldNumber = 3;
  inline ::google::protobuf::uint32 moneywon() const;
  inline void set_moneywon(::google::protobuf::uint32 value);

  // required uint32 playerMoney = 4;
  inline bool has_playermoney() const;
  inline void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 4;
  inline ::google::protobuf::uint32 playermoney() const;
  inline void set_playermoney(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EndOfHandHideCardsMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_moneywon();
  inline void clear_has_moneywon();
  inline void set_has_playermoney();
  inline void clear_has_playermoney();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 moneywon_;
  ::google::protobuf::uint32 playermoney_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static EndOfHandHideCardsMessage* default_instance_;
};
// -------------------------------------------------------------------

class ShowMyCardsRequestMessage : public ::google::protobuf::MessageLite {
 public:
  ShowMyCardsRequestMessage();
  virtual ~ShowMyCardsRequestMessage();

  ShowMyCardsRequestMessage(const ShowMyCardsRequestMessage& from);

  inline ShowMyCardsRequestMessage& operator=(const ShowMyCardsRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ShowMyCardsRequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShowMyCardsRequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShowMyCardsRequestMessage* other);

  // implements Message ----------------------------------------------

  ShowMyCardsRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShowMyCardsRequestMessage& from);
  void MergeFrom(const ShowMyCardsRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ShowMyCardsRequestMessage)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static ShowMyCardsRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class AfterHandShowCardsMessage : public ::google::protobuf::MessageLite {
 public:
  AfterHandShowCardsMessage();
  virtual ~AfterHandShowCardsMessage();

  AfterHandShowCardsMessage(const AfterHandShowCardsMessage& from);

  inline AfterHandShowCardsMessage& operator=(const AfterHandShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AfterHandShowCardsMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AfterHandShowCardsMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AfterHandShowCardsMessage* other);

  // implements Message ----------------------------------------------

  AfterHandShowCardsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AfterHandShowCardsMessage& from);
  void MergeFrom(const AfterHandShowCardsMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PlayerResult playerResult = 1;
  inline bool has_playerresult() const;
  inline void clear_playerresult();
  static const int kPlayerResultFieldNumber = 1;
  inline const ::PlayerResult& playerresult() const;
  inline ::PlayerResult* mutable_playerresult();
  inline ::PlayerResult* release_playerresult();
  inline void set_allocated_playerresult(::PlayerResult* playerresult);

  // @@protoc_insertion_point(class_scope:AfterHandShowCardsMessage)
 private:
  inline void set_has_playerresult();
  inline void clear_has_playerresult();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::PlayerResult* playerresult_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AfterHandShowCardsMessage* default_instance_;
};
// -------------------------------------------------------------------

class EndOfGameMessage : public ::google::protobuf::MessageLite {
 public:
  EndOfGameMessage();
  virtual ~EndOfGameMessage();

  EndOfGameMessage(const EndOfGameMessage& from);

  inline EndOfGameMessage& operator=(const EndOfGameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EndOfGameMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EndOfGameMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EndOfGameMessage* other);

  // implements Message ----------------------------------------------

  EndOfGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EndOfGameMessage& from);
  void MergeFrom(const EndOfGameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 winnerPlayerId = 2;
  inline bool has_winnerplayerid() const;
  inline void clear_winnerplayerid();
  static const int kWinnerPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 winnerplayerid() const;
  inline void set_winnerplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EndOfGameMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_winnerplayerid();
  inline void clear_has_winnerplayerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 winnerplayerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static EndOfGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayerIdChangedMessage : public ::google::protobuf::MessageLite {
 public:
  PlayerIdChangedMessage();
  virtual ~PlayerIdChangedMessage();

  PlayerIdChangedMessage(const PlayerIdChangedMessage& from);

  inline PlayerIdChangedMessage& operator=(const PlayerIdChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerIdChangedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerIdChangedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerIdChangedMessage* other);

  // implements Message ----------------------------------------------

  PlayerIdChangedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerIdChangedMessage& from);
  void MergeFrom(const PlayerIdChangedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 oldPlayerId = 1;
  inline bool has_oldplayerid() const;
  inline void clear_oldplayerid();
  static const int kOldPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 oldplayerid() const;
  inline void set_oldplayerid(::google::protobuf::uint32 value);

  // required uint32 newPlayerId = 2;
  inline bool has_newplayerid() const;
  inline void clear_newplayerid();
  static const int kNewPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 newplayerid() const;
  inline void set_newplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PlayerIdChangedMessage)
 private:
  inline void set_has_oldplayerid();
  inline void clear_has_oldplayerid();
  inline void set_has_newplayerid();
  inline void clear_has_newplayerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 oldplayerid_;
  ::google::protobuf::uint32 newplayerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static PlayerIdChangedMessage* default_instance_;
};
// -------------------------------------------------------------------

class AskKickPlayerMessage : public ::google::protobuf::MessageLite {
 public:
  AskKickPlayerMessage();
  virtual ~AskKickPlayerMessage();

  AskKickPlayerMessage(const AskKickPlayerMessage& from);

  inline AskKickPlayerMessage& operator=(const AskKickPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AskKickPlayerMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AskKickPlayerMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AskKickPlayerMessage* other);

  // implements Message ----------------------------------------------

  AskKickPlayerMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AskKickPlayerMessage& from);
  void MergeFrom(const AskKickPlayerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AskKickPlayerMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AskKickPlayerMessage* default_instance_;
};
// -------------------------------------------------------------------

class AskKickDeniedMessage : public ::google::protobuf::MessageLite {
 public:
  AskKickDeniedMessage();
  virtual ~AskKickDeniedMessage();

  AskKickDeniedMessage(const AskKickDeniedMessage& from);

  inline AskKickDeniedMessage& operator=(const AskKickDeniedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AskKickDeniedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AskKickDeniedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AskKickDeniedMessage* other);

  // implements Message ----------------------------------------------

  AskKickDeniedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AskKickDeniedMessage& from);
  void MergeFrom(const AskKickDeniedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AskKickDeniedMessage_KickDeniedReason KickDeniedReason;
  static const KickDeniedReason kickDeniedInvalidGameState = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState;
  static const KickDeniedReason kickDeniedNotPossible = AskKickDeniedMessage_KickDeniedReason_kickDeniedNotPossible;
  static const KickDeniedReason kickDeniedTryAgainLater = AskKickDeniedMessage_KickDeniedReason_kickDeniedTryAgainLater;
  static const KickDeniedReason kickDeniedAlreadyInProgress = AskKickDeniedMessage_KickDeniedReason_kickDeniedAlreadyInProgress;
  static const KickDeniedReason kickDeniedInvalidPlayerId = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId;
  static inline bool KickDeniedReason_IsValid(int value) {
    return AskKickDeniedMessage_KickDeniedReason_IsValid(value);
  }
  static const KickDeniedReason KickDeniedReason_MIN =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MIN;
  static const KickDeniedReason KickDeniedReason_MAX =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX;
  static const int KickDeniedReason_ARRAYSIZE =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
  inline bool has_kickdeniedreason() const;
  inline void clear_kickdeniedreason();
  static const int kKickDeniedReasonFieldNumber = 3;
  inline ::AskKickDeniedMessage_KickDeniedReason kickdeniedreason() const;
  inline void set_kickdeniedreason(::AskKickDeniedMessage_KickDeniedReason value);

  // @@protoc_insertion_point(class_scope:AskKickDeniedMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_kickdeniedreason();
  inline void clear_has_kickdeniedreason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int kickdeniedreason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AskKickDeniedMessage* default_instance_;
};
// -------------------------------------------------------------------

class StartKickPetitionMessage : public ::google::protobuf::MessageLite {
 public:
  StartKickPetitionMessage();
  virtual ~StartKickPetitionMessage();

  StartKickPetitionMessage(const StartKickPetitionMessage& from);

  inline StartKickPetitionMessage& operator=(const StartKickPetitionMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartKickPetitionMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartKickPetitionMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartKickPetitionMessage* other);

  // implements Message ----------------------------------------------

  StartKickPetitionMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartKickPetitionMessage& from);
  void MergeFrom(const StartKickPetitionMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 petitionId = 2;
  inline bool has_petitionid() const;
  inline void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 petitionid() const;
  inline void set_petitionid(::google::protobuf::uint32 value);

  // required uint32 proposingPlayerId = 3;
  inline bool has_proposingplayerid() const;
  inline void clear_proposingplayerid();
  static const int kProposingPlayerIdFieldNumber = 3;
  inline ::google::protobuf::uint32 proposingplayerid() const;
  inline void set_proposingplayerid(::google::protobuf::uint32 value);

  // required uint32 kickPlayerId = 4;
  inline bool has_kickplayerid() const;
  inline void clear_kickplayerid();
  static const int kKickPlayerIdFieldNumber = 4;
  inline ::google::protobuf::uint32 kickplayerid() const;
  inline void set_kickplayerid(::google::protobuf::uint32 value);

  // required uint32 kickTimeoutSec = 5;
  inline bool has_kicktimeoutsec() const;
  inline void clear_kicktimeoutsec();
  static const int kKickTimeoutSecFieldNumber = 5;
  inline ::google::protobuf::uint32 kicktimeoutsec() const;
  inline void set_kicktimeoutsec(::google::protobuf::uint32 value);

  // required uint32 numVotesNeededToKick = 6;
  inline bool has_numvotesneededtokick() const;
  inline void clear_numvotesneededtokick();
  static const int kNumVotesNeededToKickFieldNumber = 6;
  inline ::google::protobuf::uint32 numvotesneededtokick() const;
  inline void set_numvotesneededtokick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:StartKickPetitionMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_petitionid();
  inline void clear_has_petitionid();
  inline void set_has_proposingplayerid();
  inline void clear_has_proposingplayerid();
  inline void set_has_kickplayerid();
  inline void clear_has_kickplayerid();
  inline void set_has_kicktimeoutsec();
  inline void clear_has_kicktimeoutsec();
  inline void set_has_numvotesneededtokick();
  inline void clear_has_numvotesneededtokick();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  ::google::protobuf::uint32 proposingplayerid_;
  ::google::protobuf::uint32 kickplayerid_;
  ::google::protobuf::uint32 kicktimeoutsec_;
  ::google::protobuf::uint32 numvotesneededtokick_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static StartKickPetitionMessage* default_instance_;
};
// -------------------------------------------------------------------

class VoteKickRequestMessage : public ::google::protobuf::MessageLite {
 public:
  VoteKickRequestMessage();
  virtual ~VoteKickRequestMessage();

  VoteKickRequestMessage(const VoteKickRequestMessage& from);

  inline VoteKickRequestMessage& operator=(const VoteKickRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const VoteKickRequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VoteKickRequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VoteKickRequestMessage* other);

  // implements Message ----------------------------------------------

  VoteKickRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VoteKickRequestMessage& from);
  void MergeFrom(const VoteKickRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 petitionId = 2;
  inline bool has_petitionid() const;
  inline void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 petitionid() const;
  inline void set_petitionid(::google::protobuf::uint32 value);

  // required bool voteKick = 3;
  inline bool has_votekick() const;
  inline void clear_votekick();
  static const int kVoteKickFieldNumber = 3;
  inline bool votekick() const;
  inline void set_votekick(bool value);

  // @@protoc_insertion_point(class_scope:VoteKickRequestMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_petitionid();
  inline void clear_has_petitionid();
  inline void set_has_votekick();
  inline void clear_has_votekick();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  bool votekick_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static VoteKickRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class VoteKickReplyMessage : public ::google::protobuf::MessageLite {
 public:
  VoteKickReplyMessage();
  virtual ~VoteKickReplyMessage();

  VoteKickReplyMessage(const VoteKickReplyMessage& from);

  inline VoteKickReplyMessage& operator=(const VoteKickReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const VoteKickReplyMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VoteKickReplyMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VoteKickReplyMessage* other);

  // implements Message ----------------------------------------------

  VoteKickReplyMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VoteKickReplyMessage& from);
  void MergeFrom(const VoteKickReplyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef VoteKickReplyMessage_VoteKickReplyType VoteKickReplyType;
  static const VoteKickReplyType voteKickAck = VoteKickReplyMessage_VoteKickReplyType_voteKickAck;
  static const VoteKickReplyType voteKickDeniedInvalid = VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedInvalid;
  static const VoteKickReplyType voteKickDeniedAlreadyVoted = VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted;
  static inline bool VoteKickReplyType_IsValid(int value) {
    return VoteKickReplyMessage_VoteKickReplyType_IsValid(value);
  }
  static const VoteKickReplyType VoteKickReplyType_MIN =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MIN;
  static const VoteKickReplyType VoteKickReplyType_MAX =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX;
  static const int VoteKickReplyType_ARRAYSIZE =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 petitionId = 2;
  inline bool has_petitionid() const;
  inline void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 petitionid() const;
  inline void set_petitionid(::google::protobuf::uint32 value);

  // required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
  inline bool has_votekickreplytype() const;
  inline void clear_votekickreplytype();
  static const int kVoteKickReplyTypeFieldNumber = 3;
  inline ::VoteKickReplyMessage_VoteKickReplyType votekickreplytype() const;
  inline void set_votekickreplytype(::VoteKickReplyMessage_VoteKickReplyType value);

  // @@protoc_insertion_point(class_scope:VoteKickReplyMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_petitionid();
  inline void clear_has_petitionid();
  inline void set_has_votekickreplytype();
  inline void clear_has_votekickreplytype();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  int votekickreplytype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static VoteKickReplyMessage* default_instance_;
};
// -------------------------------------------------------------------

class KickPetitionUpdateMessage : public ::google::protobuf::MessageLite {
 public:
  KickPetitionUpdateMessage();
  virtual ~KickPetitionUpdateMessage();

  KickPetitionUpdateMessage(const KickPetitionUpdateMessage& from);

  inline KickPetitionUpdateMessage& operator=(const KickPetitionUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KickPetitionUpdateMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KickPetitionUpdateMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KickPetitionUpdateMessage* other);

  // implements Message ----------------------------------------------

  KickPetitionUpdateMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KickPetitionUpdateMessage& from);
  void MergeFrom(const KickPetitionUpdateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 petitionId = 2;
  inline bool has_petitionid() const;
  inline void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 petitionid() const;
  inline void set_petitionid(::google::protobuf::uint32 value);

  // required uint32 numVotesAgainstKicking = 3;
  inline bool has_numvotesagainstkicking() const;
  inline void clear_numvotesagainstkicking();
  static const int kNumVotesAgainstKickingFieldNumber = 3;
  inline ::google::protobuf::uint32 numvotesagainstkicking() const;
  inline void set_numvotesagainstkicking(::google::protobuf::uint32 value);

  // required uint32 numVotesInFavourOfKicking = 4;
  inline bool has_numvotesinfavourofkicking() const;
  inline void clear_numvotesinfavourofkicking();
  static const int kNumVotesInFavourOfKickingFieldNumber = 4;
  inline ::google::protobuf::uint32 numvotesinfavourofkicking() const;
  inline void set_numvotesinfavourofkicking(::google::protobuf::uint32 value);

  // required uint32 numVotesNeededToKick = 5;
  inline bool has_numvotesneededtokick() const;
  inline void clear_numvotesneededtokick();
  static const int kNumVotesNeededToKickFieldNumber = 5;
  inline ::google::protobuf::uint32 numvotesneededtokick() const;
  inline void set_numvotesneededtokick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KickPetitionUpdateMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_petitionid();
  inline void clear_has_petitionid();
  inline void set_has_numvotesagainstkicking();
  inline void clear_has_numvotesagainstkicking();
  inline void set_has_numvotesinfavourofkicking();
  inline void clear_has_numvotesinfavourofkicking();
  inline void set_has_numvotesneededtokick();
  inline void clear_has_numvotesneededtokick();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  ::google::protobuf::uint32 numvotesagainstkicking_;
  ::google::protobuf::uint32 numvotesinfavourofkicking_;
  ::google::protobuf::uint32 numvotesneededtokick_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static KickPetitionUpdateMessage* default_instance_;
};
// -------------------------------------------------------------------

class EndKickPetitionMessage : public ::google::protobuf::MessageLite {
 public:
  EndKickPetitionMessage();
  virtual ~EndKickPetitionMessage();

  EndKickPetitionMessage(const EndKickPetitionMessage& from);

  inline EndKickPetitionMessage& operator=(const EndKickPetitionMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EndKickPetitionMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EndKickPetitionMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EndKickPetitionMessage* other);

  // implements Message ----------------------------------------------

  EndKickPetitionMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EndKickPetitionMessage& from);
  void MergeFrom(const EndKickPetitionMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef EndKickPetitionMessage_PetitionEndReason PetitionEndReason;
  static const PetitionEndReason petitionEndEnoughVotes = EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes;
  static const PetitionEndReason petitionEndTooFewPlayers = EndKickPetitionMessage_PetitionEndReason_petitionEndTooFewPlayers;
  static const PetitionEndReason petitionEndPlayerLeft = EndKickPetitionMessage_PetitionEndReason_petitionEndPlayerLeft;
  static const PetitionEndReason petitionEndTimeout = EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout;
  static inline bool PetitionEndReason_IsValid(int value) {
    return EndKickPetitionMessage_PetitionEndReason_IsValid(value);
  }
  static const PetitionEndReason PetitionEndReason_MIN =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MIN;
  static const PetitionEndReason PetitionEndReason_MAX =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX;
  static const int PetitionEndReason_ARRAYSIZE =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required uint32 petitionId = 2;
  inline bool has_petitionid() const;
  inline void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 petitionid() const;
  inline void set_petitionid(::google::protobuf::uint32 value);

  // required uint32 numVotesAgainstKicking = 3;
  inline bool has_numvotesagainstkicking() const;
  inline void clear_numvotesagainstkicking();
  static const int kNumVotesAgainstKickingFieldNumber = 3;
  inline ::google::protobuf::uint32 numvotesagainstkicking() const;
  inline void set_numvotesagainstkicking(::google::protobuf::uint32 value);

  // required uint32 numVotesInFavourOfKicking = 4;
  inline bool has_numvotesinfavourofkicking() const;
  inline void clear_numvotesinfavourofkicking();
  static const int kNumVotesInFavourOfKickingFieldNumber = 4;
  inline ::google::protobuf::uint32 numvotesinfavourofkicking() const;
  inline void set_numvotesinfavourofkicking(::google::protobuf::uint32 value);

  // required uint32 resultPlayerKicked = 5;
  inline bool has_resultplayerkicked() const;
  inline void clear_resultplayerkicked();
  static const int kResultPlayerKickedFieldNumber = 5;
  inline ::google::protobuf::uint32 resultplayerkicked() const;
  inline void set_resultplayerkicked(::google::protobuf::uint32 value);

  // required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
  inline bool has_petitionendreason() const;
  inline void clear_petitionendreason();
  static const int kPetitionEndReasonFieldNumber = 6;
  inline ::EndKickPetitionMessage_PetitionEndReason petitionendreason() const;
  inline void set_petitionendreason(::EndKickPetitionMessage_PetitionEndReason value);

  // @@protoc_insertion_point(class_scope:EndKickPetitionMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_petitionid();
  inline void clear_has_petitionid();
  inline void set_has_numvotesagainstkicking();
  inline void clear_has_numvotesagainstkicking();
  inline void set_has_numvotesinfavourofkicking();
  inline void clear_has_numvotesinfavourofkicking();
  inline void set_has_resultplayerkicked();
  inline void clear_has_resultplayerkicked();
  inline void set_has_petitionendreason();
  inline void clear_has_petitionendreason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  ::google::protobuf::uint32 numvotesagainstkicking_;
  ::google::protobuf::uint32 numvotesinfavourofkicking_;
  ::google::protobuf::uint32 resultplayerkicked_;
  int petitionendreason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static EndKickPetitionMessage* default_instance_;
};
// -------------------------------------------------------------------

class StatisticsMessage_StatisticsData : public ::google::protobuf::MessageLite {
 public:
  StatisticsMessage_StatisticsData();
  virtual ~StatisticsMessage_StatisticsData();

  StatisticsMessage_StatisticsData(const StatisticsMessage_StatisticsData& from);

  inline StatisticsMessage_StatisticsData& operator=(const StatisticsMessage_StatisticsData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StatisticsMessage_StatisticsData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StatisticsMessage_StatisticsData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StatisticsMessage_StatisticsData* other);

  // implements Message ----------------------------------------------

  StatisticsMessage_StatisticsData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StatisticsMessage_StatisticsData& from);
  void MergeFrom(const StatisticsMessage_StatisticsData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef StatisticsMessage_StatisticsData_StatisticsType StatisticsType;
  static const StatisticsType statNumberOfPlayers = StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
  static inline bool StatisticsType_IsValid(int value) {
    return StatisticsMessage_StatisticsData_StatisticsType_IsValid(value);
  }
  static const StatisticsType StatisticsType_MIN =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MIN;
  static const StatisticsType StatisticsType_MAX =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX;
  static const int StatisticsType_ARRAYSIZE =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
  inline bool has_statisticstype() const;
  inline void clear_statisticstype();
  static const int kStatisticsTypeFieldNumber = 1;
  inline ::StatisticsMessage_StatisticsData_StatisticsType statisticstype() const;
  inline void set_statisticstype(::StatisticsMessage_StatisticsData_StatisticsType value);

  // required uint32 statisticsValue = 2;
  inline bool has_statisticsvalue() const;
  inline void clear_statisticsvalue();
  static const int kStatisticsValueFieldNumber = 2;
  inline ::google::protobuf::uint32 statisticsvalue() const;
  inline void set_statisticsvalue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:StatisticsMessage.StatisticsData)
 private:
  inline void set_has_statisticstype();
  inline void clear_has_statisticstype();
  inline void set_has_statisticsvalue();
  inline void clear_has_statisticsvalue();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int statisticstype_;
  ::google::protobuf::uint32 statisticsvalue_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static StatisticsMessage_StatisticsData* default_instance_;
};
// -------------------------------------------------------------------

class StatisticsMessage : public ::google::protobuf::MessageLite {
 public:
  StatisticsMessage();
  virtual ~StatisticsMessage();

  StatisticsMessage(const StatisticsMessage& from);

  inline StatisticsMessage& operator=(const StatisticsMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StatisticsMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StatisticsMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StatisticsMessage* other);

  // implements Message ----------------------------------------------

  StatisticsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StatisticsMessage& from);
  void MergeFrom(const StatisticsMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef StatisticsMessage_StatisticsData StatisticsData;

  // accessors -------------------------------------------------------

  // repeated .StatisticsMessage.StatisticsData statisticsData = 1;
  inline int statisticsdata_size() const;
  inline void clear_statisticsdata();
  static const int kStatisticsDataFieldNumber = 1;
  inline const ::StatisticsMessage_StatisticsData& statisticsdata(int index) const;
  inline ::StatisticsMessage_StatisticsData* mutable_statisticsdata(int index);
  inline ::StatisticsMessage_StatisticsData* add_statisticsdata();
  inline const ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >&
      statisticsdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >*
      mutable_statisticsdata();

  // @@protoc_insertion_point(class_scope:StatisticsMessage)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData > statisticsdata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static StatisticsMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatRequestMessage : public ::google::protobuf::MessageLite {
 public:
  ChatRequestMessage();
  virtual ~ChatRequestMessage();

  ChatRequestMessage(const ChatRequestMessage& from);

  inline ChatRequestMessage& operator=(const ChatRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChatRequestMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatRequestMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatRequestMessage* other);

  // implements Message ----------------------------------------------

  ChatRequestMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatRequestMessage& from);
  void MergeFrom(const ChatRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 targetGameId = 1;
  inline bool has_targetgameid() const;
  inline void clear_targetgameid();
  static const int kTargetGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 targetgameid() const;
  inline void set_targetgameid(::google::protobuf::uint32 value);

  // optional uint32 targetPlayerId = 2;
  inline bool has_targetplayerid() const;
  inline void clear_targetplayerid();
  static const int kTargetPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 targetplayerid() const;
  inline void set_targetplayerid(::google::protobuf::uint32 value);

  // required string chatText = 3;
  inline bool has_chattext() const;
  inline void clear_chattext();
  static const int kChatTextFieldNumber = 3;
  inline const ::std::string& chattext() const;
  inline void set_chattext(const ::std::string& value);
  inline void set_chattext(const char* value);
  inline void set_chattext(const char* value, size_t size);
  inline ::std::string* mutable_chattext();
  inline ::std::string* release_chattext();
  inline void set_allocated_chattext(::std::string* chattext);

  // @@protoc_insertion_point(class_scope:ChatRequestMessage)
 private:
  inline void set_has_targetgameid();
  inline void clear_has_targetgameid();
  inline void set_has_targetplayerid();
  inline void clear_has_targetplayerid();
  inline void set_has_chattext();
  inline void clear_has_chattext();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 targetgameid_;
  ::google::protobuf::uint32 targetplayerid_;
  ::std::string* chattext_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static ChatRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatMessage : public ::google::protobuf::MessageLite {
 public:
  ChatMessage();
  virtual ~ChatMessage();

  ChatMessage(const ChatMessage& from);

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChatMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatMessage* other);

  // implements Message ----------------------------------------------

  ChatMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ChatMessage_ChatType ChatType;
  static const ChatType chatTypeLobby = ChatMessage_ChatType_chatTypeLobby;
  static const ChatType chatTypeGame = ChatMessage_ChatType_chatTypeGame;
  static const ChatType chatTypeBot = ChatMessage_ChatType_chatTypeBot;
  static const ChatType chatTypeBroadcast = ChatMessage_ChatType_chatTypeBroadcast;
  static const ChatType chatTypePrivate = ChatMessage_ChatType_chatTypePrivate;
  static inline bool ChatType_IsValid(int value) {
    return ChatMessage_ChatType_IsValid(value);
  }
  static const ChatType ChatType_MIN =
    ChatMessage_ChatType_ChatType_MIN;
  static const ChatType ChatType_MAX =
    ChatMessage_ChatType_ChatType_MAX;
  static const int ChatType_ARRAYSIZE =
    ChatMessage_ChatType_ChatType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional uint32 playerId = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required .ChatMessage.ChatType chatType = 3;
  inline bool has_chattype() const;
  inline void clear_chattype();
  static const int kChatTypeFieldNumber = 3;
  inline ::ChatMessage_ChatType chattype() const;
  inline void set_chattype(::ChatMessage_ChatType value);

  // required string chatText = 4;
  inline bool has_chattext() const;
  inline void clear_chattext();
  static const int kChatTextFieldNumber = 4;
  inline const ::std::string& chattext() const;
  inline void set_chattext(const ::std::string& value);
  inline void set_chattext(const char* value);
  inline void set_chattext(const char* value, size_t size);
  inline ::std::string* mutable_chattext();
  inline ::std::string* release_chattext();
  inline void set_allocated_chattext(::std::string* chattext);

  // @@protoc_insertion_point(class_scope:ChatMessage)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_chattype();
  inline void clear_has_chattype();
  inline void set_has_chattext();
  inline void clear_has_chattext();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  ::std::string* chattext_;
  int chattype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static ChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatRejectMessage : public ::google::protobuf::MessageLite {
 public:
  ChatRejectMessage();
  virtual ~ChatRejectMessage();

  ChatRejectMessage(const ChatRejectMessage& from);

  inline ChatRejectMessage& operator=(const ChatRejectMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChatRejectMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatRejectMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatRejectMessage* other);

  // implements Message ----------------------------------------------

  ChatRejectMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatRejectMessage& from);
  void MergeFrom(const ChatRejectMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string chatText = 1;
  inline bool has_chattext() const;
  inline void clear_chattext();
  static const int kChatTextFieldNumber = 1;
  inline const ::std::string& chattext() const;
  inline void set_chattext(const ::std::string& value);
  inline void set_chattext(const char* value);
  inline void set_chattext(const char* value, size_t size);
  inline ::std::string* mutable_chattext();
  inline ::std::string* release_chattext();
  inline void set_allocated_chattext(::std::string* chattext);

  // @@protoc_insertion_point(class_scope:ChatRejectMessage)
 private:
  inline void set_has_chattext();
  inline void clear_has_chattext();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* chattext_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static ChatRejectMessage* default_instance_;
};
// -------------------------------------------------------------------

class DialogMessage : public ::google::protobuf::MessageLite {
 public:
  DialogMessage();
  virtual ~DialogMessage();

  DialogMessage(const DialogMessage& from);

  inline DialogMessage& operator=(const DialogMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DialogMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DialogMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DialogMessage* other);

  // implements Message ----------------------------------------------

  DialogMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DialogMessage& from);
  void MergeFrom(const DialogMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string notificationText = 1;
  inline bool has_notificationtext() const;
  inline void clear_notificationtext();
  static const int kNotificationTextFieldNumber = 1;
  inline const ::std::string& notificationtext() const;
  inline void set_notificationtext(const ::std::string& value);
  inline void set_notificationtext(const char* value);
  inline void set_notificationtext(const char* value, size_t size);
  inline ::std::string* mutable_notificationtext();
  inline ::std::string* release_notificationtext();
  inline void set_allocated_notificationtext(::std::string* notificationtext);

  // @@protoc_insertion_point(class_scope:DialogMessage)
 private:
  inline void set_has_notificationtext();
  inline void clear_has_notificationtext();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* notificationtext_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static DialogMessage* default_instance_;
};
// -------------------------------------------------------------------

class TimeoutWarningMessage : public ::google::protobuf::MessageLite {
 public:
  TimeoutWarningMessage();
  virtual ~TimeoutWarningMessage();

  TimeoutWarningMessage(const TimeoutWarningMessage& from);

  inline TimeoutWarningMessage& operator=(const TimeoutWarningMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TimeoutWarningMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeoutWarningMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeoutWarningMessage* other);

  // implements Message ----------------------------------------------

  TimeoutWarningMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeoutWarningMessage& from);
  void MergeFrom(const TimeoutWarningMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TimeoutWarningMessage_TimeoutReason TimeoutReason;
  static const TimeoutReason timeoutNoDataReceived = TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived;
  static const TimeoutReason timeoutInactiveGame = TimeoutWarningMessage_TimeoutReason_timeoutInactiveGame;
  static const TimeoutReason timeoutKickAfterAutofold = TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold;
  static inline bool TimeoutReason_IsValid(int value) {
    return TimeoutWarningMessage_TimeoutReason_IsValid(value);
  }
  static const TimeoutReason TimeoutReason_MIN =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_MIN;
  static const TimeoutReason TimeoutReason_MAX =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX;
  static const int TimeoutReason_ARRAYSIZE =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
  inline bool has_timeoutreason() const;
  inline void clear_timeoutreason();
  static const int kTimeoutReasonFieldNumber = 1;
  inline ::TimeoutWarningMessage_TimeoutReason timeoutreason() const;
  inline void set_timeoutreason(::TimeoutWarningMessage_TimeoutReason value);

  // required uint32 remainingSeconds = 2;
  inline bool has_remainingseconds() const;
  inline void clear_remainingseconds();
  static const int kRemainingSecondsFieldNumber = 2;
  inline ::google::protobuf::uint32 remainingseconds() const;
  inline void set_remainingseconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TimeoutWarningMessage)
 private:
  inline void set_has_timeoutreason();
  inline void clear_has_timeoutreason();
  inline void set_has_remainingseconds();
  inline void clear_has_remainingseconds();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int timeoutreason_;
  ::google::protobuf::uint32 remainingseconds_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static TimeoutWarningMessage* default_instance_;
};
// -------------------------------------------------------------------

class ResetTimeoutMessage : public ::google::protobuf::MessageLite {
 public:
  ResetTimeoutMessage();
  virtual ~ResetTimeoutMessage();

  ResetTimeoutMessage(const ResetTimeoutMessage& from);

  inline ResetTimeoutMessage& operator=(const ResetTimeoutMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ResetTimeoutMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResetTimeoutMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResetTimeoutMessage* other);

  // implements Message ----------------------------------------------

  ResetTimeoutMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResetTimeoutMessage& from);
  void MergeFrom(const ResetTimeoutMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ResetTimeoutMessage)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static ResetTimeoutMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReportAvatarMessage : public ::google::protobuf::MessageLite {
 public:
  ReportAvatarMessage();
  virtual ~ReportAvatarMessage();

  ReportAvatarMessage(const ReportAvatarMessage& from);

  inline ReportAvatarMessage& operator=(const ReportAvatarMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ReportAvatarMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReportAvatarMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReportAvatarMessage* other);

  // implements Message ----------------------------------------------

  ReportAvatarMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReportAvatarMessage& from);
  void MergeFrom(const ReportAvatarMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 reportedPlayerId = 1;
  inline bool has_reportedplayerid() const;
  inline void clear_reportedplayerid();
  static const int kReportedPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 reportedplayerid() const;
  inline void set_reportedplayerid(::google::protobuf::uint32 value);

  // required bytes reportedAvatarHash = 2;
  inline bool has_reportedavatarhash() const;
  inline void clear_reportedavatarhash();
  static const int kReportedAvatarHashFieldNumber = 2;
  inline const ::std::string& reportedavatarhash() const;
  inline void set_reportedavatarhash(const ::std::string& value);
  inline void set_reportedavatarhash(const char* value);
  inline void set_reportedavatarhash(const void* value, size_t size);
  inline ::std::string* mutable_reportedavatarhash();
  inline ::std::string* release_reportedavatarhash();
  inline void set_allocated_reportedavatarhash(::std::string* reportedavatarhash);

  // @@protoc_insertion_point(class_scope:ReportAvatarMessage)
 private:
  inline void set_has_reportedplayerid();
  inline void clear_has_reportedplayerid();
  inline void set_has_reportedavatarhash();
  inline void clear_has_reportedavatarhash();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* reportedavatarhash_;
  ::google::protobuf::uint32 reportedplayerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static ReportAvatarMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReportAvatarAckMessage : public ::google::protobuf::MessageLite {
 public:
  ReportAvatarAckMessage();
  virtual ~ReportAvatarAckMessage();

  ReportAvatarAckMessage(const ReportAvatarAckMessage& from);

  inline ReportAvatarAckMessage& operator=(const ReportAvatarAckMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ReportAvatarAckMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReportAvatarAckMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReportAvatarAckMessage* other);

  // implements Message ----------------------------------------------

  ReportAvatarAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReportAvatarAckMessage& from);
  void MergeFrom(const ReportAvatarAckMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ReportAvatarAckMessage_ReportAvatarResult ReportAvatarResult;
  static const ReportAvatarResult avatarReportAccepted = ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted;
  static const ReportAvatarResult avatarReportDuplicate = ReportAvatarAckMessage_ReportAvatarResult_avatarReportDuplicate;
  static const ReportAvatarResult avatarReportInvalid = ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid;
  static inline bool ReportAvatarResult_IsValid(int value) {
    return ReportAvatarAckMessage_ReportAvatarResult_IsValid(value);
  }
  static const ReportAvatarResult ReportAvatarResult_MIN =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MIN;
  static const ReportAvatarResult ReportAvatarResult_MAX =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX;
  static const int ReportAvatarResult_ARRAYSIZE =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 reportedPlayerId = 1;
  inline bool has_reportedplayerid() const;
  inline void clear_reportedplayerid();
  static const int kReportedPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 reportedplayerid() const;
  inline void set_reportedplayerid(::google::protobuf::uint32 value);

  // required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
  inline bool has_reportavatarresult() const;
  inline void clear_reportavatarresult();
  static const int kReportAvatarResultFieldNumber = 2;
  inline ::ReportAvatarAckMessage_ReportAvatarResult reportavatarresult() const;
  inline void set_reportavatarresult(::ReportAvatarAckMessage_ReportAvatarResult value);

  // @@protoc_insertion_point(class_scope:ReportAvatarAckMessage)
 private:
  inline void set_has_reportedplayerid();
  inline void clear_has_reportedplayerid();
  inline void set_has_reportavatarresult();
  inline void clear_has_reportavatarresult();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 reportedplayerid_;
  int reportavatarresult_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static ReportAvatarAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReportGameMessage : public ::google::protobuf::MessageLite {
 public:
  ReportGameMessage();
  virtual ~ReportGameMessage();

  ReportGameMessage(const ReportGameMessage& from);

  inline ReportGameMessage& operator=(const ReportGameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ReportGameMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReportGameMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReportGameMessage* other);

  // implements Message ----------------------------------------------

  ReportGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReportGameMessage& from);
  void MergeFrom(const ReportGameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 reportedGameId = 1;
  inline bool has_reportedgameid() const;
  inline void clear_reportedgameid();
  static const int kReportedGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 reportedgameid() const;
  inline void set_reportedgameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ReportGameMessage)
 private:
  inline void set_has_reportedgameid();
  inline void clear_has_reportedgameid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 reportedgameid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static ReportGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReportGameAckMessage : public ::google::protobuf::MessageLite {
 public:
  ReportGameAckMessage();
  virtual ~ReportGameAckMessage();

  ReportGameAckMessage(const ReportGameAckMessage& from);

  inline ReportGameAckMessage& operator=(const ReportGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ReportGameAckMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReportGameAckMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReportGameAckMessage* other);

  // implements Message ----------------------------------------------

  ReportGameAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReportGameAckMessage& from);
  void MergeFrom(const ReportGameAckMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ReportGameAckMessage_ReportGameResult ReportGameResult;
  static const ReportGameResult gameReportAccepted = ReportGameAckMessage_ReportGameResult_gameReportAccepted;
  static const ReportGameResult gameReportDuplicate = ReportGameAckMessage_ReportGameResult_gameReportDuplicate;
  static const ReportGameResult gameReportInvalid = ReportGameAckMessage_ReportGameResult_gameReportInvalid;
  static inline bool ReportGameResult_IsValid(int value) {
    return ReportGameAckMessage_ReportGameResult_IsValid(value);
  }
  static const ReportGameResult ReportGameResult_MIN =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_MIN;
  static const ReportGameResult ReportGameResult_MAX =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX;
  static const int ReportGameResult_ARRAYSIZE =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 reportedGameId = 1;
  inline bool has_reportedgameid() const;
  inline void clear_reportedgameid();
  static const int kReportedGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 reportedgameid() const;
  inline void set_reportedgameid(::google::protobuf::uint32 value);

  // required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
  inline bool has_reportgameresult() const;
  inline void clear_reportgameresult();
  static const int kReportGameResultFieldNumber = 2;
  inline ::ReportGameAckMessage_ReportGameResult reportgameresult() const;
  inline void set_reportgameresult(::ReportGameAckMessage_ReportGameResult value);

  // @@protoc_insertion_point(class_scope:ReportGameAckMessage)
 private:
  inline void set_has_reportedgameid();
  inline void clear_has_reportedgameid();
  inline void set_has_reportgameresult();
  inline void clear_has_reportgameresult();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 reportedgameid_;
  int reportgameresult_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static ReportGameAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class ErrorMessage : public ::google::protobuf::MessageLite {
 public:
  ErrorMessage();
  virtual ~ErrorMessage();

  ErrorMessage(const ErrorMessage& from);

  inline ErrorMessage& operator=(const ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ErrorMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ErrorMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ErrorMessage* other);

  // implements Message ----------------------------------------------

  ErrorMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ErrorMessage& from);
  void MergeFrom(const ErrorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ErrorMessage_ErrorReason ErrorReason;
  static const ErrorReason reserved = ErrorMessage_ErrorReason_reserved;
  static const ErrorReason initVersionNotSupported = ErrorMessage_ErrorReason_initVersionNotSupported;
  static const ErrorReason initServerFull = ErrorMessage_ErrorReason_initServerFull;
  static const ErrorReason initAuthFailure = ErrorMessage_ErrorReason_initAuthFailure;
  static const ErrorReason initPlayerNameInUse = ErrorMessage_ErrorReason_initPlayerNameInUse;
  static const ErrorReason initInvalidPlayerName = ErrorMessage_ErrorReason_initInvalidPlayerName;
  static const ErrorReason initServerMaintenance = ErrorMessage_ErrorReason_initServerMaintenance;
  static const ErrorReason initBlocked = ErrorMessage_ErrorReason_initBlocked;
  static const ErrorReason avatarTooLarge = ErrorMessage_ErrorReason_avatarTooLarge;
  static const ErrorReason invalidPacket = ErrorMessage_ErrorReason_invalidPacket;
  static const ErrorReason invalidState = ErrorMessage_ErrorReason_invalidState;
  static const ErrorReason kickedFromServer = ErrorMessage_ErrorReason_kickedFromServer;
  static const ErrorReason bannedFromServer = ErrorMessage_ErrorReason_bannedFromServer;
  static const ErrorReason blockedByServer = ErrorMessage_ErrorReason_blockedByServer;
  static const ErrorReason sessionTimeout = ErrorMessage_ErrorReason_sessionTimeout;
  static inline bool ErrorReason_IsValid(int value) {
    return ErrorMessage_ErrorReason_IsValid(value);
  }
  static const ErrorReason ErrorReason_MIN =
    ErrorMessage_ErrorReason_ErrorReason_MIN;
  static const ErrorReason ErrorReason_MAX =
    ErrorMessage_ErrorReason_ErrorReason_MAX;
  static const int ErrorReason_ARRAYSIZE =
    ErrorMessage_ErrorReason_ErrorReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .ErrorMessage.ErrorReason errorReason = 1;
  inline bool has_errorreason() const;
  inline void clear_errorreason();
  static const int kErrorReasonFieldNumber = 1;
  inline ::ErrorMessage_ErrorReason errorreason() const;
  inline void set_errorreason(::ErrorMessage_ErrorReason value);

  // @@protoc_insertion_point(class_scope:ErrorMessage)
 private:
  inline void set_has_errorreason();
  inline void clear_has_errorreason();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int errorreason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static ErrorMessage* default_instance_;
};
// -------------------------------------------------------------------

class AdminRemoveGameMessage : public ::google::protobuf::MessageLite {
 public:
  AdminRemoveGameMessage();
  virtual ~AdminRemoveGameMessage();

  AdminRemoveGameMessage(const AdminRemoveGameMessage& from);

  inline AdminRemoveGameMessage& operator=(const AdminRemoveGameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AdminRemoveGameMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AdminRemoveGameMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AdminRemoveGameMessage* other);

  // implements Message ----------------------------------------------

  AdminRemoveGameMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AdminRemoveGameMessage& from);
  void MergeFrom(const AdminRemoveGameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 removeGameId = 1;
  inline bool has_removegameid() const;
  inline void clear_removegameid();
  static const int kRemoveGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 removegameid() const;
  inline void set_removegameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AdminRemoveGameMessage)
 private:
  inline void set_has_removegameid();
  inline void clear_has_removegameid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 removegameid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AdminRemoveGameMessage* default_instance_;
};
// -------------------------------------------------------------------

class AdminRemoveGameAckMessage : public ::google::protobuf::MessageLite {
 public:
  AdminRemoveGameAckMessage();
  virtual ~AdminRemoveGameAckMessage();

  AdminRemoveGameAckMessage(const AdminRemoveGameAckMessage& from);

  inline AdminRemoveGameAckMessage& operator=(const AdminRemoveGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AdminRemoveGameAckMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AdminRemoveGameAckMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AdminRemoveGameAckMessage* other);

  // implements Message ----------------------------------------------

  AdminRemoveGameAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AdminRemoveGameAckMessage& from);
  void MergeFrom(const AdminRemoveGameAckMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameResult;
  static const AdminRemoveGameResult gameRemoveAccepted = AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveAccepted;
  static const AdminRemoveGameResult gameRemoveInvalid = AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveInvalid;
  static inline bool AdminRemoveGameResult_IsValid(int value) {
    return AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(value);
  }
  static const AdminRemoveGameResult AdminRemoveGameResult_MIN =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MIN;
  static const AdminRemoveGameResult AdminRemoveGameResult_MAX =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MAX;
  static const int AdminRemoveGameResult_ARRAYSIZE =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 removeGameId = 1;
  inline bool has_removegameid() const;
  inline void clear_removegameid();
  static const int kRemoveGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 removegameid() const;
  inline void set_removegameid(::google::protobuf::uint32 value);

  // required .AdminRemoveGameAckMessage.AdminRemoveGameResult removeGameResult = 2;
  inline bool has_removegameresult() const;
  inline void clear_removegameresult();
  static const int kRemoveGameResultFieldNumber = 2;
  inline ::AdminRemoveGameAckMessage_AdminRemoveGameResult removegameresult() const;
  inline void set_removegameresult(::AdminRemoveGameAckMessage_AdminRemoveGameResult value);

  // @@protoc_insertion_point(class_scope:AdminRemoveGameAckMessage)
 private:
  inline void set_has_removegameid();
  inline void clear_has_removegameid();
  inline void set_has_removegameresult();
  inline void clear_has_removegameresult();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 removegameid_;
  int removegameresult_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AdminRemoveGameAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class AdminBanPlayerMessage : public ::google::protobuf::MessageLite {
 public:
  AdminBanPlayerMessage();
  virtual ~AdminBanPlayerMessage();

  AdminBanPlayerMessage(const AdminBanPlayerMessage& from);

  inline AdminBanPlayerMessage& operator=(const AdminBanPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AdminBanPlayerMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AdminBanPlayerMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AdminBanPlayerMessage* other);

  // implements Message ----------------------------------------------

  AdminBanPlayerMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AdminBanPlayerMessage& from);
  void MergeFrom(const AdminBanPlayerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 banPlayerId = 1;
  inline bool has_banplayerid() const;
  inline void clear_banplayerid();
  static const int kBanPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 banplayerid() const;
  inline void set_banplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AdminBanPlayerMessage)
 private:
  inline void set_has_banplayerid();
  inline void clear_has_banplayerid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 banplayerid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AdminBanPlayerMessage* default_instance_;
};
// -------------------------------------------------------------------

class AdminBanPlayerAckMessage : public ::google::protobuf::MessageLite {
 public:
  AdminBanPlayerAckMessage();
  virtual ~AdminBanPlayerAckMessage();

  AdminBanPlayerAckMessage(const AdminBanPlayerAckMessage& from);

  inline AdminBanPlayerAckMessage& operator=(const AdminBanPlayerAckMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AdminBanPlayerAckMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AdminBanPlayerAckMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AdminBanPlayerAckMessage* other);

  // implements Message ----------------------------------------------

  AdminBanPlayerAckMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AdminBanPlayerAckMessage& from);
  void MergeFrom(const AdminBanPlayerAckMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerResult;
  static const AdminBanPlayerResult banPlayerAccepted = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerAccepted;
  static const AdminBanPlayerResult banPlayerPending = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerPending;
  static const AdminBanPlayerResult banPlayerNoDB = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerNoDB;
  static const AdminBanPlayerResult banPlayerDBError = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerDBError;
  static const AdminBanPlayerResult banPlayerInvalid = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerInvalid;
  static inline bool AdminBanPlayerResult_IsValid(int value) {
    return AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(value);
  }
  static const AdminBanPlayerResult AdminBanPlayerResult_MIN =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MIN;
  static const AdminBanPlayerResult AdminBanPlayerResult_MAX =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MAX;
  static const int AdminBanPlayerResult_ARRAYSIZE =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 banPlayerId = 1;
  inline bool has_banplayerid() const;
  inline void clear_banplayerid();
  static const int kBanPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 banplayerid() const;
  inline void set_banplayerid(::google::protobuf::uint32 value);

  // required .AdminBanPlayerAckMessage.AdminBanPlayerResult banPlayerResult = 2;
  inline bool has_banplayerresult() const;
  inline void clear_banplayerresult();
  static const int kBanPlayerResultFieldNumber = 2;
  inline ::AdminBanPlayerAckMessage_AdminBanPlayerResult banplayerresult() const;
  inline void set_banplayerresult(::AdminBanPlayerAckMessage_AdminBanPlayerResult value);

  // @@protoc_insertion_point(class_scope:AdminBanPlayerAckMessage)
 private:
  inline void set_has_banplayerid();
  inline void clear_has_banplayerid();
  inline void set_has_banplayerresult();
  inline void clear_has_banplayerresult();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 banplayerid_;
  int banplayerresult_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static AdminBanPlayerAckMessage* default_instance_;
};
// -------------------------------------------------------------------

class PokerTHMessage : public ::google::protobuf::MessageLite {
 public:
  PokerTHMessage();
  virtual ~PokerTHMessage();

  PokerTHMessage(const PokerTHMessage& from);

  inline PokerTHMessage& operator=(const PokerTHMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PokerTHMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PokerTHMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PokerTHMessage* other);

  // implements Message ----------------------------------------------

  PokerTHMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PokerTHMessage& from);
  void MergeFrom(const PokerTHMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PokerTHMessage_PokerTHMessageType PokerTHMessageType;
  static const PokerTHMessageType Type_AnnounceMessage = PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage;
  static const PokerTHMessageType Type_InitMessage = PokerTHMessage_PokerTHMessageType_Type_InitMessage;
  static const PokerTHMessageType Type_AuthServerChallengeMessage = PokerTHMessage_PokerTHMessageType_Type_AuthServerChallengeMessage;
  static const PokerTHMessageType Type_AuthClientResponseMessage = PokerTHMessage_PokerTHMessageType_Type_AuthClientResponseMessage;
  static const PokerTHMessageType Type_AuthServerVerificationMessage = PokerTHMessage_PokerTHMessageType_Type_AuthServerVerificationMessage;
  static const PokerTHMessageType Type_InitAckMessage = PokerTHMessage_PokerTHMessageType_Type_InitAckMessage;
  static const PokerTHMessageType Type_AvatarRequestMessage = PokerTHMessage_PokerTHMessageType_Type_AvatarRequestMessage;
  static const PokerTHMessageType Type_AvatarHeaderMessage = PokerTHMessage_PokerTHMessageType_Type_AvatarHeaderMessage;
  static const PokerTHMessageType Type_AvatarDataMessage = PokerTHMessage_PokerTHMessageType_Type_AvatarDataMessage;
  static const PokerTHMessageType Type_AvatarEndMessage = PokerTHMessage_PokerTHMessageType_Type_AvatarEndMessage;
  static const PokerTHMessageType Type_UnknownAvatarMessage = PokerTHMessage_PokerTHMessageType_Type_UnknownAvatarMessage;
  static const PokerTHMessageType Type_PlayerListMessage = PokerTHMessage_PokerTHMessageType_Type_PlayerListMessage;
  static const PokerTHMessageType Type_GameListNewMessage = PokerTHMessage_PokerTHMessageType_Type_GameListNewMessage;
  static const PokerTHMessageType Type_GameListUpdateMessage = PokerTHMessage_PokerTHMessageType_Type_GameListUpdateMessage;
  static const PokerTHMessageType Type_GameListPlayerJoinedMessage = PokerTHMessage_PokerTHMessageType_Type_GameListPlayerJoinedMessage;
  static const PokerTHMessageType Type_GameListPlayerLeftMessage = PokerTHMessage_PokerTHMessageType_Type_GameListPlayerLeftMessage;
  static const PokerTHMessageType Type_GameListAdminChangedMessage = PokerTHMessage_PokerTHMessageType_Type_GameListAdminChangedMessage;
  static const PokerTHMessageType Type_PlayerInfoRequestMessage = PokerTHMessage_PokerTHMessageType_Type_PlayerInfoRequestMessage;
  static const PokerTHMessageType Type_PlayerInfoReplyMessage = PokerTHMessage_PokerTHMessageType_Type_PlayerInfoReplyMessage;
  static const PokerTHMessageType Type_SubscriptionRequestMessage = PokerTHMessage_PokerTHMessageType_Type_SubscriptionRequestMessage;
  static const PokerTHMessageType Type_JoinExistingGameMessage = PokerTHMessage_PokerTHMessageType_Type_JoinExistingGameMessage;
  static const PokerTHMessageType Type_JoinNewGameMessage = PokerTHMessage_PokerTHMessageType_Type_JoinNewGameMessage;
  static const PokerTHMessageType Type_RejoinExistingGameMessage = PokerTHMessage_PokerTHMessageType_Type_RejoinExistingGameMessage;
  static const PokerTHMessageType Type_JoinGameAckMessage = PokerTHMessage_PokerTHMessageType_Type_JoinGameAckMessage;
  static const PokerTHMessageType Type_JoinGameFailedMessage = PokerTHMessage_PokerTHMessageType_Type_JoinGameFailedMessage;
  static const PokerTHMessageType Type_GamePlayerJoinedMessage = PokerTHMessage_PokerTHMessageType_Type_GamePlayerJoinedMessage;
  static const PokerTHMessageType Type_GamePlayerLeftMessage = PokerTHMessage_PokerTHMessageType_Type_GamePlayerLeftMessage;
  static const PokerTHMessageType Type_GameAdminChangedMessage = PokerTHMessage_PokerTHMessageType_Type_GameAdminChangedMessage;
  static const PokerTHMessageType Type_RemovedFromGameMessage = PokerTHMessage_PokerTHMessageType_Type_RemovedFromGameMessage;
  static const PokerTHMessageType Type_KickPlayerRequestMessage = PokerTHMessage_PokerTHMessageType_Type_KickPlayerRequestMessage;
  static const PokerTHMessageType Type_LeaveGameRequestMessage = PokerTHMessage_PokerTHMessageType_Type_LeaveGameRequestMessage;
  static const PokerTHMessageType Type_InvitePlayerToGameMessage = PokerTHMessage_PokerTHMessageType_Type_InvitePlayerToGameMessage;
  static const PokerTHMessageType Type_InviteNotifyMessage = PokerTHMessage_PokerTHMessageType_Type_InviteNotifyMessage;
  static const PokerTHMessageType Type_RejectGameInvitationMessage = PokerTHMessage_PokerTHMessageType_Type_RejectGameInvitationMessage;
  static const PokerTHMessageType Type_RejectInvNotifyMessage = PokerTHMessage_PokerTHMessageType_Type_RejectInvNotifyMessage;
  static const PokerTHMessageType Type_StartEventMessage = PokerTHMessage_PokerTHMessageType_Type_StartEventMessage;
  static const PokerTHMessageType Type_StartEventAckMessage = PokerTHMessage_PokerTHMessageType_Type_StartEventAckMessage;
  static const PokerTHMessageType Type_GameStartInitialMessage = PokerTHMessage_PokerTHMessageType_Type_GameStartInitialMessage;
  static const PokerTHMessageType Type_GameStartRejoinMessage = PokerTHMessage_PokerTHMessageType_Type_GameStartRejoinMessage;
  static const PokerTHMessageType Type_HandStartMessage = PokerTHMessage_PokerTHMessageType_Type_HandStartMessage;
  static const PokerTHMessageType Type_PlayersTurnMessage = PokerTHMessage_PokerTHMessageType_Type_PlayersTurnMessage;
  static const PokerTHMessageType Type_MyActionRequestMessage = PokerTHMessage_PokerTHMessageType_Type_MyActionRequestMessage;
  static const PokerTHMessageType Type_YourActionRejectedMessage = PokerTHMessage_PokerTHMessageType_Type_YourActionRejectedMessage;
  static const PokerTHMessageType Type_PlayersActionDoneMessage = PokerTHMessage_PokerTHMessageType_Type_PlayersActionDoneMessage;
  static const PokerTHMessageType Type_DealFlopCardsMessage = PokerTHMessage_PokerTHMessageType_Type_DealFlopCardsMessage;
  static const PokerTHMessageType Type_DealTurnCardMessage = PokerTHMessage_PokerTHMessageType_Type_DealTurnCardMessage;
  static const PokerTHMessageType Type_DealRiverCardMessage = PokerTHMessage_PokerTHMessageType_Type_DealRiverCardMessage;
  static const PokerTHMessageType Type_AllInShowCardsMessage = PokerTHMessage_PokerTHMessageType_Type_AllInShowCardsMessage;
  static const PokerTHMessageType Type_EndOfHandShowCardsMessage = PokerTHMessage_PokerTHMessageType_Type_EndOfHandShowCardsMessage;
  static const PokerTHMessageType Type_EndOfHandHideCardsMessage = PokerTHMessage_PokerTHMessageType_Type_EndOfHandHideCardsMessage;
  static const PokerTHMessageType Type_ShowMyCardsRequestMessage = PokerTHMessage_PokerTHMessageType_Type_ShowMyCardsRequestMessage;
  static const PokerTHMessageType Type_AfterHandShowCardsMessage = PokerTHMessage_PokerTHMessageType_Type_AfterHandShowCardsMessage;
  static const PokerTHMessageType Type_EndOfGameMessage = PokerTHMessage_PokerTHMessageType_Type_EndOfGameMessage;
  static const PokerTHMessageType Type_PlayerIdChangedMessage = PokerTHMessage_PokerTHMessageType_Type_PlayerIdChangedMessage;
  static const PokerTHMessageType Type_AskKickPlayerMessage = PokerTHMessage_PokerTHMessageType_Type_AskKickPlayerMessage;
  static const PokerTHMessageType Type_AskKickDeniedMessage = PokerTHMessage_PokerTHMessageType_Type_AskKickDeniedMessage;
  static const PokerTHMessageType Type_StartKickPetitionMessage = PokerTHMessage_PokerTHMessageType_Type_StartKickPetitionMessage;
  static const PokerTHMessageType Type_VoteKickRequestMessage = PokerTHMessage_PokerTHMessageType_Type_VoteKickRequestMessage;
  static const PokerTHMessageType Type_VoteKickReplyMessage = PokerTHMessage_PokerTHMessageType_Type_VoteKickReplyMessage;
  static const PokerTHMessageType Type_KickPetitionUpdateMessage = PokerTHMessage_PokerTHMessageType_Type_KickPetitionUpdateMessage;
  static const PokerTHMessageType Type_EndKickPetitionMessage = PokerTHMessage_PokerTHMessageType_Type_EndKickPetitionMessage;
  static const PokerTHMessageType Type_StatisticsMessage = PokerTHMessage_PokerTHMessageType_Type_StatisticsMessage;
  static const PokerTHMessageType Type_ChatRequestMessage = PokerTHMessage_PokerTHMessageType_Type_ChatRequestMessage;
  static const PokerTHMessageType Type_ChatMessage = PokerTHMessage_PokerTHMessageType_Type_ChatMessage;
  static const PokerTHMessageType Type_ChatRejectMessage = PokerTHMessage_PokerTHMessageType_Type_ChatRejectMessage;
  static const PokerTHMessageType Type_DialogMessage = PokerTHMessage_PokerTHMessageType_Type_DialogMessage;
  static const PokerTHMessageType Type_TimeoutWarningMessage = PokerTHMessage_PokerTHMessageType_Type_TimeoutWarningMessage;
  static const PokerTHMessageType Type_ResetTimeoutMessage = PokerTHMessage_PokerTHMessageType_Type_ResetTimeoutMessage;
  static const PokerTHMessageType Type_ReportAvatarMessage = PokerTHMessage_PokerTHMessageType_Type_ReportAvatarMessage;
  static const PokerTHMessageType Type_ReportAvatarAckMessage = PokerTHMessage_PokerTHMessageType_Type_ReportAvatarAckMessage;
  static const PokerTHMessageType Type_ReportGameMessage = PokerTHMessage_PokerTHMessageType_Type_ReportGameMessage;
  static const PokerTHMessageType Type_ReportGameAckMessage = PokerTHMessage_PokerTHMessageType_Type_ReportGameAckMessage;
  static const PokerTHMessageType Type_ErrorMessage = PokerTHMessage_PokerTHMessageType_Type_ErrorMessage;
  static const PokerTHMessageType Type_AdminRemoveGameMessage = PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameMessage;
  static const PokerTHMessageType Type_AdminRemoveGameAckMessage = PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameAckMessage;
  static const PokerTHMessageType Type_AdminBanPlayerMessage = PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerMessage;
  static const PokerTHMessageType Type_AdminBanPlayerAckMessage = PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerAckMessage;
  static const PokerTHMessageType Type_GameListSpectatorJoinedMessage = PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorJoinedMessage;
  static const PokerTHMessageType Type_GameListSpectatorLeftMessage = PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorLeftMessage;
  static const PokerTHMessageType Type_GameSpectatorJoinedMessage = PokerTHMessage_PokerTHMessageType_Type_GameSpectatorJoinedMessage;
  static const PokerTHMessageType Type_GameSpectatorLeftMessage = PokerTHMessage_PokerTHMessageType_Type_GameSpectatorLeftMessage;
  static inline bool PokerTHMessageType_IsValid(int value) {
    return PokerTHMessage_PokerTHMessageType_IsValid(value);
  }
  static const PokerTHMessageType PokerTHMessageType_MIN =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MIN;
  static const PokerTHMessageType PokerTHMessageType_MAX =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX;
  static const int PokerTHMessageType_ARRAYSIZE =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .PokerTHMessage.PokerTHMessageType messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::PokerTHMessage_PokerTHMessageType messagetype() const;
  inline void set_messagetype(::PokerTHMessage_PokerTHMessageType value);

  // optional .AnnounceMessage announceMessage = 2;
  inline bool has_announcemessage() const;
  inline void clear_announcemessage();
  static const int kAnnounceMessageFieldNumber = 2;
  inline const ::AnnounceMessage& announcemessage() const;
  inline ::AnnounceMessage* mutable_announcemessage();
  inline ::AnnounceMessage* release_announcemessage();
  inline void set_allocated_announcemessage(::AnnounceMessage* announcemessage);

  // optional .InitMessage initMessage = 3;
  inline bool has_initmessage() const;
  inline void clear_initmessage();
  static const int kInitMessageFieldNumber = 3;
  inline const ::InitMessage& initmessage() const;
  inline ::InitMessage* mutable_initmessage();
  inline ::InitMessage* release_initmessage();
  inline void set_allocated_initmessage(::InitMessage* initmessage);

  // optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
  inline bool has_authserverchallengemessage() const;
  inline void clear_authserverchallengemessage();
  static const int kAuthServerChallengeMessageFieldNumber = 4;
  inline const ::AuthServerChallengeMessage& authserverchallengemessage() const;
  inline ::AuthServerChallengeMessage* mutable_authserverchallengemessage();
  inline ::AuthServerChallengeMessage* release_authserverchallengemessage();
  inline void set_allocated_authserverchallengemessage(::AuthServerChallengeMessage* authserverchallengemessage);

  // optional .AuthClientResponseMessage authClientResponseMessage = 5;
  inline bool has_authclientresponsemessage() const;
  inline void clear_authclientresponsemessage();
  static const int kAuthClientResponseMessageFieldNumber = 5;
  inline const ::AuthClientResponseMessage& authclientresponsemessage() const;
  inline ::AuthClientResponseMessage* mutable_authclientresponsemessage();
  inline ::AuthClientResponseMessage* release_authclientresponsemessage();
  inline void set_allocated_authclientresponsemessage(::AuthClientResponseMessage* authclientresponsemessage);

  // optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
  inline bool has_authserververificationmessage() const;
  inline void clear_authserververificationmessage();
  static const int kAuthServerVerificationMessageFieldNumber = 6;
  inline const ::AuthServerVerificationMessage& authserververificationmessage() const;
  inline ::AuthServerVerificationMessage* mutable_authserververificationmessage();
  inline ::AuthServerVerificationMessage* release_authserververificationmessage();
  inline void set_allocated_authserververificationmessage(::AuthServerVerificationMessage* authserververificationmessage);

  // optional .InitAckMessage initAckMessage = 7;
  inline bool has_initackmessage() const;
  inline void clear_initackmessage();
  static const int kInitAckMessageFieldNumber = 7;
  inline const ::InitAckMessage& initackmessage() const;
  inline ::InitAckMessage* mutable_initackmessage();
  inline ::InitAckMessage* release_initackmessage();
  inline void set_allocated_initackmessage(::InitAckMessage* initackmessage);

  // optional .AvatarRequestMessage avatarRequestMessage = 8;
  inline bool has_avatarrequestmessage() const;
  inline void clear_avatarrequestmessage();
  static const int kAvatarRequestMessageFieldNumber = 8;
  inline const ::AvatarRequestMessage& avatarrequestmessage() const;
  inline ::AvatarRequestMessage* mutable_avatarrequestmessage();
  inline ::AvatarRequestMessage* release_avatarrequestmessage();
  inline void set_allocated_avatarrequestmessage(::AvatarRequestMessage* avatarrequestmessage);

  // optional .AvatarHeaderMessage avatarHeaderMessage = 9;
  inline bool has_avatarheadermessage() const;
  inline void clear_avatarheadermessage();
  static const int kAvatarHeaderMessageFieldNumber = 9;
  inline const ::AvatarHeaderMessage& avatarheadermessage() const;
  inline ::AvatarHeaderMessage* mutable_avatarheadermessage();
  inline ::AvatarHeaderMessage* release_avatarheadermessage();
  inline void set_allocated_avatarheadermessage(::AvatarHeaderMessage* avatarheadermessage);

  // optional .AvatarDataMessage avatarDataMessage = 10;
  inline bool has_avatardatamessage() const;
  inline void clear_avatardatamessage();
  static const int kAvatarDataMessageFieldNumber = 10;
  inline const ::AvatarDataMessage& avatardatamessage() const;
  inline ::AvatarDataMessage* mutable_avatardatamessage();
  inline ::AvatarDataMessage* release_avatardatamessage();
  inline void set_allocated_avatardatamessage(::AvatarDataMessage* avatardatamessage);

  // optional .AvatarEndMessage avatarEndMessage = 11;
  inline bool has_avatarendmessage() const;
  inline void clear_avatarendmessage();
  static const int kAvatarEndMessageFieldNumber = 11;
  inline const ::AvatarEndMessage& avatarendmessage() const;
  inline ::AvatarEndMessage* mutable_avatarendmessage();
  inline ::AvatarEndMessage* release_avatarendmessage();
  inline void set_allocated_avatarendmessage(::AvatarEndMessage* avatarendmessage);

  // optional .UnknownAvatarMessage unknownAvatarMessage = 12;
  inline bool has_unknownavatarmessage() const;
  inline void clear_unknownavatarmessage();
  static const int kUnknownAvatarMessageFieldNumber = 12;
  inline const ::UnknownAvatarMessage& unknownavatarmessage() const;
  inline ::UnknownAvatarMessage* mutable_unknownavatarmessage();
  inline ::UnknownAvatarMessage* release_unknownavatarmessage();
  inline void set_allocated_unknownavatarmessage(::UnknownAvatarMessage* unknownavatarmessage);

  // optional .PlayerListMessage playerListMessage = 13;
  inline bool has_playerlistmessage() const;
  inline void clear_playerlistmessage();
  static const int kPlayerListMessageFieldNumber = 13;
  inline const ::PlayerListMessage& playerlistmessage() const;
  inline ::PlayerListMessage* mutable_playerlistmessage();
  inline ::PlayerListMessage* release_playerlistmessage();
  inline void set_allocated_playerlistmessage(::PlayerListMessage* playerlistmessage);

  // optional .GameListNewMessage gameListNewMessage = 14;
  inline bool has_gamelistnewmessage() const;
  inline void clear_gamelistnewmessage();
  static const int kGameListNewMessageFieldNumber = 14;
  inline const ::GameListNewMessage& gamelistnewmessage() const;
  inline ::GameListNewMessage* mutable_gamelistnewmessage();
  inline ::GameListNewMessage* release_gamelistnewmessage();
  inline void set_allocated_gamelistnewmessage(::GameListNewMessage* gamelistnewmessage);

  // optional .GameListUpdateMessage gameListUpdateMessage = 15;
  inline bool has_gamelistupdatemessage() const;
  inline void clear_gamelistupdatemessage();
  static const int kGameListUpdateMessageFieldNumber = 15;
  inline const ::GameListUpdateMessage& gamelistupdatemessage() const;
  inline ::GameListUpdateMessage* mutable_gamelistupdatemessage();
  inline ::GameListUpdateMessage* release_gamelistupdatemessage();
  inline void set_allocated_gamelistupdatemessage(::GameListUpdateMessage* gamelistupdatemessage);

  // optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
  inline bool has_gamelistplayerjoinedmessage() const;
  inline void clear_gamelistplayerjoinedmessage();
  static const int kGameListPlayerJoinedMessageFieldNumber = 16;
  inline const ::GameListPlayerJoinedMessage& gamelistplayerjoinedmessage() const;
  inline ::GameListPlayerJoinedMessage* mutable_gamelistplayerjoinedmessage();
  inline ::GameListPlayerJoinedMessage* release_gamelistplayerjoinedmessage();
  inline void set_allocated_gamelistplayerjoinedmessage(::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage);

  // optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
  inline bool has_gamelistplayerleftmessage() const;
  inline void clear_gamelistplayerleftmessage();
  static const int kGameListPlayerLeftMessageFieldNumber = 17;
  inline const ::GameListPlayerLeftMessage& gamelistplayerleftmessage() const;
  inline ::GameListPlayerLeftMessage* mutable_gamelistplayerleftmessage();
  inline ::GameListPlayerLeftMessage* release_gamelistplayerleftmessage();
  inline void set_allocated_gamelistplayerleftmessage(::GameListPlayerLeftMessage* gamelistplayerleftmessage);

  // optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
  inline bool has_gamelistadminchangedmessage() const;
  inline void clear_gamelistadminchangedmessage();
  static const int kGameListAdminChangedMessageFieldNumber = 18;
  inline const ::GameListAdminChangedMessage& gamelistadminchangedmessage() const;
  inline ::GameListAdminChangedMessage* mutable_gamelistadminchangedmessage();
  inline ::GameListAdminChangedMessage* release_gamelistadminchangedmessage();
  inline void set_allocated_gamelistadminchangedmessage(::GameListAdminChangedMessage* gamelistadminchangedmessage);

  // optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
  inline bool has_playerinforequestmessage() const;
  inline void clear_playerinforequestmessage();
  static const int kPlayerInfoRequestMessageFieldNumber = 19;
  inline const ::PlayerInfoRequestMessage& playerinforequestmessage() const;
  inline ::PlayerInfoRequestMessage* mutable_playerinforequestmessage();
  inline ::PlayerInfoRequestMessage* release_playerinforequestmessage();
  inline void set_allocated_playerinforequestmessage(::PlayerInfoRequestMessage* playerinforequestmessage);

  // optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
  inline bool has_playerinforeplymessage() const;
  inline void clear_playerinforeplymessage();
  static const int kPlayerInfoReplyMessageFieldNumber = 20;
  inline const ::PlayerInfoReplyMessage& playerinforeplymessage() const;
  inline ::PlayerInfoReplyMessage* mutable_playerinforeplymessage();
  inline ::PlayerInfoReplyMessage* release_playerinforeplymessage();
  inline void set_allocated_playerinforeplymessage(::PlayerInfoReplyMessage* playerinforeplymessage);

  // optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
  inline bool has_subscriptionrequestmessage() const;
  inline void clear_subscriptionrequestmessage();
  static const int kSubscriptionRequestMessageFieldNumber = 21;
  inline const ::SubscriptionRequestMessage& subscriptionrequestmessage() const;
  inline ::SubscriptionRequestMessage* mutable_subscriptionrequestmessage();
  inline ::SubscriptionRequestMessage* release_subscriptionrequestmessage();
  inline void set_allocated_subscriptionrequestmessage(::SubscriptionRequestMessage* subscriptionrequestmessage);

  // optional .JoinExistingGameMessage joinExistingGameMessage = 22;
  inline bool has_joinexistinggamemessage() const;
  inline void clear_joinexistinggamemessage();
  static const int kJoinExistingGameMessageFieldNumber = 22;
  inline const ::JoinExistingGameMessage& joinexistinggamemessage() const;
  inline ::JoinExistingGameMessage* mutable_joinexistinggamemessage();
  inline ::JoinExistingGameMessage* release_joinexistinggamemessage();
  inline void set_allocated_joinexistinggamemessage(::JoinExistingGameMessage* joinexistinggamemessage);

  // optional .JoinNewGameMessage joinNewGameMessage = 23;
  inline bool has_joinnewgamemessage() const;
  inline void clear_joinnewgamemessage();
  static const int kJoinNewGameMessageFieldNumber = 23;
  inline const ::JoinNewGameMessage& joinnewgamemessage() const;
  inline ::JoinNewGameMessage* mutable_joinnewgamemessage();
  inline ::JoinNewGameMessage* release_joinnewgamemessage();
  inline void set_allocated_joinnewgamemessage(::JoinNewGameMessage* joinnewgamemessage);

  // optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
  inline bool has_rejoinexistinggamemessage() const;
  inline void clear_rejoinexistinggamemessage();
  static const int kRejoinExistingGameMessageFieldNumber = 24;
  inline const ::RejoinExistingGameMessage& rejoinexistinggamemessage() const;
  inline ::RejoinExistingGameMessage* mutable_rejoinexistinggamemessage();
  inline ::RejoinExistingGameMessage* release_rejoinexistinggamemessage();
  inline void set_allocated_rejoinexistinggamemessage(::RejoinExistingGameMessage* rejoinexistinggamemessage);

  // optional .JoinGameAckMessage joinGameAckMessage = 25;
  inline bool has_joingameackmessage() const;
  inline void clear_joingameackmessage();
  static const int kJoinGameAckMessageFieldNumber = 25;
  inline const ::JoinGameAckMessage& joingameackmessage() const;
  inline ::JoinGameAckMessage* mutable_joingameackmessage();
  inline ::JoinGameAckMessage* release_joingameackmessage();
  inline void set_allocated_joingameackmessage(::JoinGameAckMessage* joingameackmessage);

  // optional .JoinGameFailedMessage joinGameFailedMessage = 26;
  inline bool has_joingamefailedmessage() const;
  inline void clear_joingamefailedmessage();
  static const int kJoinGameFailedMessageFieldNumber = 26;
  inline const ::JoinGameFailedMessage& joingamefailedmessage() const;
  inline ::JoinGameFailedMessage* mutable_joingamefailedmessage();
  inline ::JoinGameFailedMessage* release_joingamefailedmessage();
  inline void set_allocated_joingamefailedmessage(::JoinGameFailedMessage* joingamefailedmessage);

  // optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
  inline bool has_gameplayerjoinedmessage() const;
  inline void clear_gameplayerjoinedmessage();
  static const int kGamePlayerJoinedMessageFieldNumber = 27;
  inline const ::GamePlayerJoinedMessage& gameplayerjoinedmessage() const;
  inline ::GamePlayerJoinedMessage* mutable_gameplayerjoinedmessage();
  inline ::GamePlayerJoinedMessage* release_gameplayerjoinedmessage();
  inline void set_allocated_gameplayerjoinedmessage(::GamePlayerJoinedMessage* gameplayerjoinedmessage);

  // optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
  inline bool has_gameplayerleftmessage() const;
  inline void clear_gameplayerleftmessage();
  static const int kGamePlayerLeftMessageFieldNumber = 28;
  inline const ::GamePlayerLeftMessage& gameplayerleftmessage() const;
  inline ::GamePlayerLeftMessage* mutable_gameplayerleftmessage();
  inline ::GamePlayerLeftMessage* release_gameplayerleftmessage();
  inline void set_allocated_gameplayerleftmessage(::GamePlayerLeftMessage* gameplayerleftmessage);

  // optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
  inline bool has_gameadminchangedmessage() const;
  inline void clear_gameadminchangedmessage();
  static const int kGameAdminChangedMessageFieldNumber = 29;
  inline const ::GameAdminChangedMessage& gameadminchangedmessage() const;
  inline ::GameAdminChangedMessage* mutable_gameadminchangedmessage();
  inline ::GameAdminChangedMessage* release_gameadminchangedmessage();
  inline void set_allocated_gameadminchangedmessage(::GameAdminChangedMessage* gameadminchangedmessage);

  // optional .RemovedFromGameMessage removedFromGameMessage = 30;
  inline bool has_removedfromgamemessage() const;
  inline void clear_removedfromgamemessage();
  static const int kRemovedFromGameMessageFieldNumber = 30;
  inline const ::RemovedFromGameMessage& removedfromgamemessage() const;
  inline ::RemovedFromGameMessage* mutable_removedfromgamemessage();
  inline ::RemovedFromGameMessage* release_removedfromgamemessage();
  inline void set_allocated_removedfromgamemessage(::RemovedFromGameMessage* removedfromgamemessage);

  // optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
  inline bool has_kickplayerrequestmessage() const;
  inline void clear_kickplayerrequestmessage();
  static const int kKickPlayerRequestMessageFieldNumber = 31;
  inline const ::KickPlayerRequestMessage& kickplayerrequestmessage() const;
  inline ::KickPlayerRequestMessage* mutable_kickplayerrequestmessage();
  inline ::KickPlayerRequestMessage* release_kickplayerrequestmessage();
  inline void set_allocated_kickplayerrequestmessage(::KickPlayerRequestMessage* kickplayerrequestmessage);

  // optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
  inline bool has_leavegamerequestmessage() const;
  inline void clear_leavegamerequestmessage();
  static const int kLeaveGameRequestMessageFieldNumber = 32;
  inline const ::LeaveGameRequestMessage& leavegamerequestmessage() const;
  inline ::LeaveGameRequestMessage* mutable_leavegamerequestmessage();
  inline ::LeaveGameRequestMessage* release_leavegamerequestmessage();
  inline void set_allocated_leavegamerequestmessage(::LeaveGameRequestMessage* leavegamerequestmessage);

  // optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
  inline bool has_inviteplayertogamemessage() const;
  inline void clear_inviteplayertogamemessage();
  static const int kInvitePlayerToGameMessageFieldNumber = 33;
  inline const ::InvitePlayerToGameMessage& inviteplayertogamemessage() const;
  inline ::InvitePlayerToGameMessage* mutable_inviteplayertogamemessage();
  inline ::InvitePlayerToGameMessage* release_inviteplayertogamemessage();
  inline void set_allocated_inviteplayertogamemessage(::InvitePlayerToGameMessage* inviteplayertogamemessage);

  // optional .InviteNotifyMessage inviteNotifyMessage = 34;
  inline bool has_invitenotifymessage() const;
  inline void clear_invitenotifymessage();
  static const int kInviteNotifyMessageFieldNumber = 34;
  inline const ::InviteNotifyMessage& invitenotifymessage() const;
  inline ::InviteNotifyMessage* mutable_invitenotifymessage();
  inline ::InviteNotifyMessage* release_invitenotifymessage();
  inline void set_allocated_invitenotifymessage(::InviteNotifyMessage* invitenotifymessage);

  // optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
  inline bool has_rejectgameinvitationmessage() const;
  inline void clear_rejectgameinvitationmessage();
  static const int kRejectGameInvitationMessageFieldNumber = 35;
  inline const ::RejectGameInvitationMessage& rejectgameinvitationmessage() const;
  inline ::RejectGameInvitationMessage* mutable_rejectgameinvitationmessage();
  inline ::RejectGameInvitationMessage* release_rejectgameinvitationmessage();
  inline void set_allocated_rejectgameinvitationmessage(::RejectGameInvitationMessage* rejectgameinvitationmessage);

  // optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
  inline bool has_rejectinvnotifymessage() const;
  inline void clear_rejectinvnotifymessage();
  static const int kRejectInvNotifyMessageFieldNumber = 36;
  inline const ::RejectInvNotifyMessage& rejectinvnotifymessage() const;
  inline ::RejectInvNotifyMessage* mutable_rejectinvnotifymessage();
  inline ::RejectInvNotifyMessage* release_rejectinvnotifymessage();
  inline void set_allocated_rejectinvnotifymessage(::RejectInvNotifyMessage* rejectinvnotifymessage);

  // optional .StartEventMessage startEventMessage = 37;
  inline bool has_starteventmessage() const;
  inline void clear_starteventmessage();
  static const int kStartEventMessageFieldNumber = 37;
  inline const ::StartEventMessage& starteventmessage() const;
  inline ::StartEventMessage* mutable_starteventmessage();
  inline ::StartEventMessage* release_starteventmessage();
  inline void set_allocated_starteventmessage(::StartEventMessage* starteventmessage);

  // optional .StartEventAckMessage startEventAckMessage = 38;
  inline bool has_starteventackmessage() const;
  inline void clear_starteventackmessage();
  static const int kStartEventAckMessageFieldNumber = 38;
  inline const ::StartEventAckMessage& starteventackmessage() const;
  inline ::StartEventAckMessage* mutable_starteventackmessage();
  inline ::StartEventAckMessage* release_starteventackmessage();
  inline void set_allocated_starteventackmessage(::StartEventAckMessage* starteventackmessage);

  // optional .GameStartInitialMessage gameStartInitialMessage = 39;
  inline bool has_gamestartinitialmessage() const;
  inline void clear_gamestartinitialmessage();
  static const int kGameStartInitialMessageFieldNumber = 39;
  inline const ::GameStartInitialMessage& gamestartinitialmessage() const;
  inline ::GameStartInitialMessage* mutable_gamestartinitialmessage();
  inline ::GameStartInitialMessage* release_gamestartinitialmessage();
  inline void set_allocated_gamestartinitialmessage(::GameStartInitialMessage* gamestartinitialmessage);

  // optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
  inline bool has_gamestartrejoinmessage() const;
  inline void clear_gamestartrejoinmessage();
  static const int kGameStartRejoinMessageFieldNumber = 40;
  inline const ::GameStartRejoinMessage& gamestartrejoinmessage() const;
  inline ::GameStartRejoinMessage* mutable_gamestartrejoinmessage();
  inline ::GameStartRejoinMessage* release_gamestartrejoinmessage();
  inline void set_allocated_gamestartrejoinmessage(::GameStartRejoinMessage* gamestartrejoinmessage);

  // optional .HandStartMessage handStartMessage = 41;
  inline bool has_handstartmessage() const;
  inline void clear_handstartmessage();
  static const int kHandStartMessageFieldNumber = 41;
  inline const ::HandStartMessage& handstartmessage() const;
  inline ::HandStartMessage* mutable_handstartmessage();
  inline ::HandStartMessage* release_handstartmessage();
  inline void set_allocated_handstartmessage(::HandStartMessage* handstartmessage);

  // optional .PlayersTurnMessage playersTurnMessage = 42;
  inline bool has_playersturnmessage() const;
  inline void clear_playersturnmessage();
  static const int kPlayersTurnMessageFieldNumber = 42;
  inline const ::PlayersTurnMessage& playersturnmessage() const;
  inline ::PlayersTurnMessage* mutable_playersturnmessage();
  inline ::PlayersTurnMessage* release_playersturnmessage();
  inline void set_allocated_playersturnmessage(::PlayersTurnMessage* playersturnmessage);

  // optional .MyActionRequestMessage myActionRequestMessage = 43;
  inline bool has_myactionrequestmessage() const;
  inline void clear_myactionrequestmessage();
  static const int kMyActionRequestMessageFieldNumber = 43;
  inline const ::MyActionRequestMessage& myactionrequestmessage() const;
  inline ::MyActionRequestMessage* mutable_myactionrequestmessage();
  inline ::MyActionRequestMessage* release_myactionrequestmessage();
  inline void set_allocated_myactionrequestmessage(::MyActionRequestMessage* myactionrequestmessage);

  // optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
  inline bool has_youractionrejectedmessage() const;
  inline void clear_youractionrejectedmessage();
  static const int kYourActionRejectedMessageFieldNumber = 44;
  inline const ::YourActionRejectedMessage& youractionrejectedmessage() const;
  inline ::YourActionRejectedMessage* mutable_youractionrejectedmessage();
  inline ::YourActionRejectedMessage* release_youractionrejectedmessage();
  inline void set_allocated_youractionrejectedmessage(::YourActionRejectedMessage* youractionrejectedmessage);

  // optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
  inline bool has_playersactiondonemessage() const;
  inline void clear_playersactiondonemessage();
  static const int kPlayersActionDoneMessageFieldNumber = 45;
  inline const ::PlayersActionDoneMessage& playersactiondonemessage() const;
  inline ::PlayersActionDoneMessage* mutable_playersactiondonemessage();
  inline ::PlayersActionDoneMessage* release_playersactiondonemessage();
  inline void set_allocated_playersactiondonemessage(::PlayersActionDoneMessage* playersactiondonemessage);

  // optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
  inline bool has_dealflopcardsmessage() const;
  inline void clear_dealflopcardsmessage();
  static const int kDealFlopCardsMessageFieldNumber = 46;
  inline const ::DealFlopCardsMessage& dealflopcardsmessage() const;
  inline ::DealFlopCardsMessage* mutable_dealflopcardsmessage();
  inline ::DealFlopCardsMessage* release_dealflopcardsmessage();
  inline void set_allocated_dealflopcardsmessage(::DealFlopCardsMessage* dealflopcardsmessage);

  // optional .DealTurnCardMessage dealTurnCardMessage = 47;
  inline bool has_dealturncardmessage() const;
  inline void clear_dealturncardmessage();
  static const int kDealTurnCardMessageFieldNumber = 47;
  inline const ::DealTurnCardMessage& dealturncardmessage() const;
  inline ::DealTurnCardMessage* mutable_dealturncardmessage();
  inline ::DealTurnCardMessage* release_dealturncardmessage();
  inline void set_allocated_dealturncardmessage(::DealTurnCardMessage* dealturncardmessage);

  // optional .DealRiverCardMessage dealRiverCardMessage = 48;
  inline bool has_dealrivercardmessage() const;
  inline void clear_dealrivercardmessage();
  static const int kDealRiverCardMessageFieldNumber = 48;
  inline const ::DealRiverCardMessage& dealrivercardmessage() const;
  inline ::DealRiverCardMessage* mutable_dealrivercardmessage();
  inline ::DealRiverCardMessage* release_dealrivercardmessage();
  inline void set_allocated_dealrivercardmessage(::DealRiverCardMessage* dealrivercardmessage);

  // optional .AllInShowCardsMessage allInShowCardsMessage = 49;
  inline bool has_allinshowcardsmessage() const;
  inline void clear_allinshowcardsmessage();
  static const int kAllInShowCardsMessageFieldNumber = 49;
  inline const ::AllInShowCardsMessage& allinshowcardsmessage() const;
  inline ::AllInShowCardsMessage* mutable_allinshowcardsmessage();
  inline ::AllInShowCardsMessage* release_allinshowcardsmessage();
  inline void set_allocated_allinshowcardsmessage(::AllInShowCardsMessage* allinshowcardsmessage);

  // optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
  inline bool has_endofhandshowcardsmessage() const;
  inline void clear_endofhandshowcardsmessage();
  static const int kEndOfHandShowCardsMessageFieldNumber = 50;
  inline const ::EndOfHandShowCardsMessage& endofhandshowcardsmessage() const;
  inline ::EndOfHandShowCardsMessage* mutable_endofhandshowcardsmessage();
  inline ::EndOfHandShowCardsMessage* release_endofhandshowcardsmessage();
  inline void set_allocated_endofhandshowcardsmessage(::EndOfHandShowCardsMessage* endofhandshowcardsmessage);

  // optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
  inline bool has_endofhandhidecardsmessage() const;
  inline void clear_endofhandhidecardsmessage();
  static const int kEndOfHandHideCardsMessageFieldNumber = 51;
  inline const ::EndOfHandHideCardsMessage& endofhandhidecardsmessage() const;
  inline ::EndOfHandHideCardsMessage* mutable_endofhandhidecardsmessage();
  inline ::EndOfHandHideCardsMessage* release_endofhandhidecardsmessage();
  inline void set_allocated_endofhandhidecardsmessage(::EndOfHandHideCardsMessage* endofhandhidecardsmessage);

  // optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
  inline bool has_showmycardsrequestmessage() const;
  inline void clear_showmycardsrequestmessage();
  static const int kShowMyCardsRequestMessageFieldNumber = 52;
  inline const ::ShowMyCardsRequestMessage& showmycardsrequestmessage() const;
  inline ::ShowMyCardsRequestMessage* mutable_showmycardsrequestmessage();
  inline ::ShowMyCardsRequestMessage* release_showmycardsrequestmessage();
  inline void set_allocated_showmycardsrequestmessage(::ShowMyCardsRequestMessage* showmycardsrequestmessage);

  // optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
  inline bool has_afterhandshowcardsmessage() const;
  inline void clear_afterhandshowcardsmessage();
  static const int kAfterHandShowCardsMessageFieldNumber = 53;
  inline const ::AfterHandShowCardsMessage& afterhandshowcardsmessage() const;
  inline ::AfterHandShowCardsMessage* mutable_afterhandshowcardsmessage();
  inline ::AfterHandShowCardsMessage* release_afterhandshowcardsmessage();
  inline void set_allocated_afterhandshowcardsmessage(::AfterHandShowCardsMessage* afterhandshowcardsmessage);

  // optional .EndOfGameMessage endOfGameMessage = 54;
  inline bool has_endofgamemessage() const;
  inline void clear_endofgamemessage();
  static const int kEndOfGameMessageFieldNumber = 54;
  inline const ::EndOfGameMessage& endofgamemessage() const;
  inline ::EndOfGameMessage* mutable_endofgamemessage();
  inline ::EndOfGameMessage* release_endofgamemessage();
  inline void set_allocated_endofgamemessage(::EndOfGameMessage* endofgamemessage);

  // optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
  inline bool has_playeridchangedmessage() const;
  inline void clear_playeridchangedmessage();
  static const int kPlayerIdChangedMessageFieldNumber = 55;
  inline const ::PlayerIdChangedMessage& playeridchangedmessage() const;
  inline ::PlayerIdChangedMessage* mutable_playeridchangedmessage();
  inline ::PlayerIdChangedMessage* release_playeridchangedmessage();
  inline void set_allocated_playeridchangedmessage(::PlayerIdChangedMessage* playeridchangedmessage);

  // optional .AskKickPlayerMessage askKickPlayerMessage = 56;
  inline bool has_askkickplayermessage() const;
  inline void clear_askkickplayermessage();
  static const int kAskKickPlayerMessageFieldNumber = 56;
  inline const ::AskKickPlayerMessage& askkickplayermessage() const;
  inline ::AskKickPlayerMessage* mutable_askkickplayermessage();
  inline ::AskKickPlayerMessage* release_askkickplayermessage();
  inline void set_allocated_askkickplayermessage(::AskKickPlayerMessage* askkickplayermessage);

  // optional .AskKickDeniedMessage askKickDeniedMessage = 57;
  inline bool has_askkickdeniedmessage() const;
  inline void clear_askkickdeniedmessage();
  static const int kAskKickDeniedMessageFieldNumber = 57;
  inline const ::AskKickDeniedMessage& askkickdeniedmessage() const;
  inline ::AskKickDeniedMessage* mutable_askkickdeniedmessage();
  inline ::AskKickDeniedMessage* release_askkickdeniedmessage();
  inline void set_allocated_askkickdeniedmessage(::AskKickDeniedMessage* askkickdeniedmessage);

  // optional .StartKickPetitionMessage startKickPetitionMessage = 58;
  inline bool has_startkickpetitionmessage() const;
  inline void clear_startkickpetitionmessage();
  static const int kStartKickPetitionMessageFieldNumber = 58;
  inline const ::StartKickPetitionMessage& startkickpetitionmessage() const;
  inline ::StartKickPetitionMessage* mutable_startkickpetitionmessage();
  inline ::StartKickPetitionMessage* release_startkickpetitionmessage();
  inline void set_allocated_startkickpetitionmessage(::StartKickPetitionMessage* startkickpetitionmessage);

  // optional .VoteKickRequestMessage voteKickRequestMessage = 59;
  inline bool has_votekickrequestmessage() const;
  inline void clear_votekickrequestmessage();
  static const int kVoteKickRequestMessageFieldNumber = 59;
  inline const ::VoteKickRequestMessage& votekickrequestmessage() const;
  inline ::VoteKickRequestMessage* mutable_votekickrequestmessage();
  inline ::VoteKickRequestMessage* release_votekickrequestmessage();
  inline void set_allocated_votekickrequestmessage(::VoteKickRequestMessage* votekickrequestmessage);

  // optional .VoteKickReplyMessage voteKickReplyMessage = 60;
  inline bool has_votekickreplymessage() const;
  inline void clear_votekickreplymessage();
  static const int kVoteKickReplyMessageFieldNumber = 60;
  inline const ::VoteKickReplyMessage& votekickreplymessage() const;
  inline ::VoteKickReplyMessage* mutable_votekickreplymessage();
  inline ::VoteKickReplyMessage* release_votekickreplymessage();
  inline void set_allocated_votekickreplymessage(::VoteKickReplyMessage* votekickreplymessage);

  // optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
  inline bool has_kickpetitionupdatemessage() const;
  inline void clear_kickpetitionupdatemessage();
  static const int kKickPetitionUpdateMessageFieldNumber = 61;
  inline const ::KickPetitionUpdateMessage& kickpetitionupdatemessage() const;
  inline ::KickPetitionUpdateMessage* mutable_kickpetitionupdatemessage();
  inline ::KickPetitionUpdateMessage* release_kickpetitionupdatemessage();
  inline void set_allocated_kickpetitionupdatemessage(::KickPetitionUpdateMessage* kickpetitionupdatemessage);

  // optional .EndKickPetitionMessage endKickPetitionMessage = 62;
  inline bool has_endkickpetitionmessage() const;
  inline void clear_endkickpetitionmessage();
  static const int kEndKickPetitionMessageFieldNumber = 62;
  inline const ::EndKickPetitionMessage& endkickpetitionmessage() const;
  inline ::EndKickPetitionMessage* mutable_endkickpetitionmessage();
  inline ::EndKickPetitionMessage* release_endkickpetitionmessage();
  inline void set_allocated_endkickpetitionmessage(::EndKickPetitionMessage* endkickpetitionmessage);

  // optional .StatisticsMessage statisticsMessage = 63;
  inline bool has_statisticsmessage() const;
  inline void clear_statisticsmessage();
  static const int kStatisticsMessageFieldNumber = 63;
  inline const ::StatisticsMessage& statisticsmessage() const;
  inline ::StatisticsMessage* mutable_statisticsmessage();
  inline ::StatisticsMessage* release_statisticsmessage();
  inline void set_allocated_statisticsmessage(::StatisticsMessage* statisticsmessage);

  // optional .ChatRequestMessage chatRequestMessage = 64;
  inline bool has_chatrequestmessage() const;
  inline void clear_chatrequestmessage();
  static const int kChatRequestMessageFieldNumber = 64;
  inline const ::ChatRequestMessage& chatrequestmessage() const;
  inline ::ChatRequestMessage* mutable_chatrequestmessage();
  inline ::ChatRequestMessage* release_chatrequestmessage();
  inline void set_allocated_chatrequestmessage(::ChatRequestMessage* chatrequestmessage);

  // optional .ChatMessage chatMessage = 65;
  inline bool has_chatmessage() const;
  inline void clear_chatmessage();
  static const int kChatMessageFieldNumber = 65;
  inline const ::ChatMessage& chatmessage() const;
  inline ::ChatMessage* mutable_chatmessage();
  inline ::ChatMessage* release_chatmessage();
  inline void set_allocated_chatmessage(::ChatMessage* chatmessage);

  // optional .ChatRejectMessage chatRejectMessage = 66;
  inline bool has_chatrejectmessage() const;
  inline void clear_chatrejectmessage();
  static const int kChatRejectMessageFieldNumber = 66;
  inline const ::ChatRejectMessage& chatrejectmessage() const;
  inline ::ChatRejectMessage* mutable_chatrejectmessage();
  inline ::ChatRejectMessage* release_chatrejectmessage();
  inline void set_allocated_chatrejectmessage(::ChatRejectMessage* chatrejectmessage);

  // optional .DialogMessage dialogMessage = 67;
  inline bool has_dialogmessage() const;
  inline void clear_dialogmessage();
  static const int kDialogMessageFieldNumber = 67;
  inline const ::DialogMessage& dialogmessage() const;
  inline ::DialogMessage* mutable_dialogmessage();
  inline ::DialogMessage* release_dialogmessage();
  inline void set_allocated_dialogmessage(::DialogMessage* dialogmessage);

  // optional .TimeoutWarningMessage timeoutWarningMessage = 68;
  inline bool has_timeoutwarningmessage() const;
  inline void clear_timeoutwarningmessage();
  static const int kTimeoutWarningMessageFieldNumber = 68;
  inline const ::TimeoutWarningMessage& timeoutwarningmessage() const;
  inline ::TimeoutWarningMessage* mutable_timeoutwarningmessage();
  inline ::TimeoutWarningMessage* release_timeoutwarningmessage();
  inline void set_allocated_timeoutwarningmessage(::TimeoutWarningMessage* timeoutwarningmessage);

  // optional .ResetTimeoutMessage resetTimeoutMessage = 69;
  inline bool has_resettimeoutmessage() const;
  inline void clear_resettimeoutmessage();
  static const int kResetTimeoutMessageFieldNumber = 69;
  inline const ::ResetTimeoutMessage& resettimeoutmessage() const;
  inline ::ResetTimeoutMessage* mutable_resettimeoutmessage();
  inline ::ResetTimeoutMessage* release_resettimeoutmessage();
  inline void set_allocated_resettimeoutmessage(::ResetTimeoutMessage* resettimeoutmessage);

  // optional .ReportAvatarMessage reportAvatarMessage = 70;
  inline bool has_reportavatarmessage() const;
  inline void clear_reportavatarmessage();
  static const int kReportAvatarMessageFieldNumber = 70;
  inline const ::ReportAvatarMessage& reportavatarmessage() const;
  inline ::ReportAvatarMessage* mutable_reportavatarmessage();
  inline ::ReportAvatarMessage* release_reportavatarmessage();
  inline void set_allocated_reportavatarmessage(::ReportAvatarMessage* reportavatarmessage);

  // optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
  inline bool has_reportavatarackmessage() const;
  inline void clear_reportavatarackmessage();
  static const int kReportAvatarAckMessageFieldNumber = 71;
  inline const ::ReportAvatarAckMessage& reportavatarackmessage() const;
  inline ::ReportAvatarAckMessage* mutable_reportavatarackmessage();
  inline ::ReportAvatarAckMessage* release_reportavatarackmessage();
  inline void set_allocated_reportavatarackmessage(::ReportAvatarAckMessage* reportavatarackmessage);

  // optional .ReportGameMessage reportGameMessage = 72;
  inline bool has_reportgamemessage() const;
  inline void clear_reportgamemessage();
  static const int kReportGameMessageFieldNumber = 72;
  inline const ::ReportGameMessage& reportgamemessage() const;
  inline ::ReportGameMessage* mutable_reportgamemessage();
  inline ::ReportGameMessage* release_reportgamemessage();
  inline void set_allocated_reportgamemessage(::ReportGameMessage* reportgamemessage);

  // optional .ReportGameAckMessage reportGameAckMessage = 73;
  inline bool has_reportgameackmessage() const;
  inline void clear_reportgameackmessage();
  static const int kReportGameAckMessageFieldNumber = 73;
  inline const ::ReportGameAckMessage& reportgameackmessage() const;
  inline ::ReportGameAckMessage* mutable_reportgameackmessage();
  inline ::ReportGameAckMessage* release_reportgameackmessage();
  inline void set_allocated_reportgameackmessage(::ReportGameAckMessage* reportgameackmessage);

  // optional .ErrorMessage errorMessage = 74;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 74;
  inline const ::ErrorMessage& errormessage() const;
  inline ::ErrorMessage* mutable_errormessage();
  inline ::ErrorMessage* release_errormessage();
  inline void set_allocated_errormessage(::ErrorMessage* errormessage);

  // optional .AdminRemoveGameMessage adminRemoveGameMessage = 75;
  inline bool has_adminremovegamemessage() const;
  inline void clear_adminremovegamemessage();
  static const int kAdminRemoveGameMessageFieldNumber = 75;
  inline const ::AdminRemoveGameMessage& adminremovegamemessage() const;
  inline ::AdminRemoveGameMessage* mutable_adminremovegamemessage();
  inline ::AdminRemoveGameMessage* release_adminremovegamemessage();
  inline void set_allocated_adminremovegamemessage(::AdminRemoveGameMessage* adminremovegamemessage);

  // optional .AdminRemoveGameAckMessage adminRemoveGameAckMessage = 76;
  inline bool has_adminremovegameackmessage() const;
  inline void clear_adminremovegameackmessage();
  static const int kAdminRemoveGameAckMessageFieldNumber = 76;
  inline const ::AdminRemoveGameAckMessage& adminremovegameackmessage() const;
  inline ::AdminRemoveGameAckMessage* mutable_adminremovegameackmessage();
  inline ::AdminRemoveGameAckMessage* release_adminremovegameackmessage();
  inline void set_allocated_adminremovegameackmessage(::AdminRemoveGameAckMessage* adminremovegameackmessage);

  // optional .AdminBanPlayerMessage adminBanPlayerMessage = 77;
  inline bool has_adminbanplayermessage() const;
  inline void clear_adminbanplayermessage();
  static const int kAdminBanPlayerMessageFieldNumber = 77;
  inline const ::AdminBanPlayerMessage& adminbanplayermessage() const;
  inline ::AdminBanPlayerMessage* mutable_adminbanplayermessage();
  inline ::AdminBanPlayerMessage* release_adminbanplayermessage();
  inline void set_allocated_adminbanplayermessage(::AdminBanPlayerMessage* adminbanplayermessage);

  // optional .AdminBanPlayerAckMessage adminBanPlayerAckMessage = 78;
  inline bool has_adminbanplayerackmessage() const;
  inline void clear_adminbanplayerackmessage();
  static const int kAdminBanPlayerAckMessageFieldNumber = 78;
  inline const ::AdminBanPlayerAckMessage& adminbanplayerackmessage() const;
  inline ::AdminBanPlayerAckMessage* mutable_adminbanplayerackmessage();
  inline ::AdminBanPlayerAckMessage* release_adminbanplayerackmessage();
  inline void set_allocated_adminbanplayerackmessage(::AdminBanPlayerAckMessage* adminbanplayerackmessage);

  // optional .GameListSpectatorJoinedMessage gameListSpectatorJoinedMessage = 79;
  inline bool has_gamelistspectatorjoinedmessage() const;
  inline void clear_gamelistspectatorjoinedmessage();
  static const int kGameListSpectatorJoinedMessageFieldNumber = 79;
  inline const ::GameListSpectatorJoinedMessage& gamelistspectatorjoinedmessage() const;
  inline ::GameListSpectatorJoinedMessage* mutable_gamelistspectatorjoinedmessage();
  inline ::GameListSpectatorJoinedMessage* release_gamelistspectatorjoinedmessage();
  inline void set_allocated_gamelistspectatorjoinedmessage(::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage);

  // optional .GameListSpectatorLeftMessage gameListSpectatorLeftMessage = 80;
  inline bool has_gamelistspectatorleftmessage() const;
  inline void clear_gamelistspectatorleftmessage();
  static const int kGameListSpectatorLeftMessageFieldNumber = 80;
  inline const ::GameListSpectatorLeftMessage& gamelistspectatorleftmessage() const;
  inline ::GameListSpectatorLeftMessage* mutable_gamelistspectatorleftmessage();
  inline ::GameListSpectatorLeftMessage* release_gamelistspectatorleftmessage();
  inline void set_allocated_gamelistspectatorleftmessage(::GameListSpectatorLeftMessage* gamelistspectatorleftmessage);

  // optional .GameSpectatorJoinedMessage gameSpectatorJoinedMessage = 81;
  inline bool has_gamespectatorjoinedmessage() const;
  inline void clear_gamespectatorjoinedmessage();
  static const int kGameSpectatorJoinedMessageFieldNumber = 81;
  inline const ::GameSpectatorJoinedMessage& gamespectatorjoinedmessage() const;
  inline ::GameSpectatorJoinedMessage* mutable_gamespectatorjoinedmessage();
  inline ::GameSpectatorJoinedMessage* release_gamespectatorjoinedmessage();
  inline void set_allocated_gamespectatorjoinedmessage(::GameSpectatorJoinedMessage* gamespectatorjoinedmessage);

  // optional .GameSpectatorLeftMessage gameSpectatorLeftMessage = 82;
  inline bool has_gamespectatorleftmessage() const;
  inline void clear_gamespectatorleftmessage();
  static const int kGameSpectatorLeftMessageFieldNumber = 82;
  inline const ::GameSpectatorLeftMessage& gamespectatorleftmessage() const;
  inline ::GameSpectatorLeftMessage* mutable_gamespectatorleftmessage();
  inline ::GameSpectatorLeftMessage* release_gamespectatorleftmessage();
  inline void set_allocated_gamespectatorleftmessage(::GameSpectatorLeftMessage* gamespectatorleftmessage);

  // @@protoc_insertion_point(class_scope:PokerTHMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_announcemessage();
  inline void clear_has_announcemessage();
  inline void set_has_initmessage();
  inline void clear_has_initmessage();
  inline void set_has_authserverchallengemessage();
  inline void clear_has_authserverchallengemessage();
  inline void set_has_authclientresponsemessage();
  inline void clear_has_authclientresponsemessage();
  inline void set_has_authserververificationmessage();
  inline void clear_has_authserververificationmessage();
  inline void set_has_initackmessage();
  inline void clear_has_initackmessage();
  inline void set_has_avatarrequestmessage();
  inline void clear_has_avatarrequestmessage();
  inline void set_has_avatarheadermessage();
  inline void clear_has_avatarheadermessage();
  inline void set_has_avatardatamessage();
  inline void clear_has_avatardatamessage();
  inline void set_has_avatarendmessage();
  inline void clear_has_avatarendmessage();
  inline void set_has_unknownavatarmessage();
  inline void clear_has_unknownavatarmessage();
  inline void set_has_playerlistmessage();
  inline void clear_has_playerlistmessage();
  inline void set_has_gamelistnewmessage();
  inline void clear_has_gamelistnewmessage();
  inline void set_has_gamelistupdatemessage();
  inline void clear_has_gamelistupdatemessage();
  inline void set_has_gamelistplayerjoinedmessage();
  inline void clear_has_gamelistplayerjoinedmessage();
  inline void set_has_gamelistplayerleftmessage();
  inline void clear_has_gamelistplayerleftmessage();
  inline void set_has_gamelistadminchangedmessage();
  inline void clear_has_gamelistadminchangedmessage();
  inline void set_has_playerinforequestmessage();
  inline void clear_has_playerinforequestmessage();
  inline void set_has_playerinforeplymessage();
  inline void clear_has_playerinforeplymessage();
  inline void set_has_subscriptionrequestmessage();
  inline void clear_has_subscriptionrequestmessage();
  inline void set_has_joinexistinggamemessage();
  inline void clear_has_joinexistinggamemessage();
  inline void set_has_joinnewgamemessage();
  inline void clear_has_joinnewgamemessage();
  inline void set_has_rejoinexistinggamemessage();
  inline void clear_has_rejoinexistinggamemessage();
  inline void set_has_joingameackmessage();
  inline void clear_has_joingameackmessage();
  inline void set_has_joingamefailedmessage();
  inline void clear_has_joingamefailedmessage();
  inline void set_has_gameplayerjoinedmessage();
  inline void clear_has_gameplayerjoinedmessage();
  inline void set_has_gameplayerleftmessage();
  inline void clear_has_gameplayerleftmessage();
  inline void set_has_gameadminchangedmessage();
  inline void clear_has_gameadminchangedmessage();
  inline void set_has_removedfromgamemessage();
  inline void clear_has_removedfromgamemessage();
  inline void set_has_kickplayerrequestmessage();
  inline void clear_has_kickplayerrequestmessage();
  inline void set_has_leavegamerequestmessage();
  inline void clear_has_leavegamerequestmessage();
  inline void set_has_inviteplayertogamemessage();
  inline void clear_has_inviteplayertogamemessage();
  inline void set_has_invitenotifymessage();
  inline void clear_has_invitenotifymessage();
  inline void set_has_rejectgameinvitationmessage();
  inline void clear_has_rejectgameinvitationmessage();
  inline void set_has_rejectinvnotifymessage();
  inline void clear_has_rejectinvnotifymessage();
  inline void set_has_starteventmessage();
  inline void clear_has_starteventmessage();
  inline void set_has_starteventackmessage();
  inline void clear_has_starteventackmessage();
  inline void set_has_gamestartinitialmessage();
  inline void clear_has_gamestartinitialmessage();
  inline void set_has_gamestartrejoinmessage();
  inline void clear_has_gamestartrejoinmessage();
  inline void set_has_handstartmessage();
  inline void clear_has_handstartmessage();
  inline void set_has_playersturnmessage();
  inline void clear_has_playersturnmessage();
  inline void set_has_myactionrequestmessage();
  inline void clear_has_myactionrequestmessage();
  inline void set_has_youractionrejectedmessage();
  inline void clear_has_youractionrejectedmessage();
  inline void set_has_playersactiondonemessage();
  inline void clear_has_playersactiondonemessage();
  inline void set_has_dealflopcardsmessage();
  inline void clear_has_dealflopcardsmessage();
  inline void set_has_dealturncardmessage();
  inline void clear_has_dealturncardmessage();
  inline void set_has_dealrivercardmessage();
  inline void clear_has_dealrivercardmessage();
  inline void set_has_allinshowcardsmessage();
  inline void clear_has_allinshowcardsmessage();
  inline void set_has_endofhandshowcardsmessage();
  inline void clear_has_endofhandshowcardsmessage();
  inline void set_has_endofhandhidecardsmessage();
  inline void clear_has_endofhandhidecardsmessage();
  inline void set_has_showmycardsrequestmessage();
  inline void clear_has_showmycardsrequestmessage();
  inline void set_has_afterhandshowcardsmessage();
  inline void clear_has_afterhandshowcardsmessage();
  inline void set_has_endofgamemessage();
  inline void clear_has_endofgamemessage();
  inline void set_has_playeridchangedmessage();
  inline void clear_has_playeridchangedmessage();
  inline void set_has_askkickplayermessage();
  inline void clear_has_askkickplayermessage();
  inline void set_has_askkickdeniedmessage();
  inline void clear_has_askkickdeniedmessage();
  inline void set_has_startkickpetitionmessage();
  inline void clear_has_startkickpetitionmessage();
  inline void set_has_votekickrequestmessage();
  inline void clear_has_votekickrequestmessage();
  inline void set_has_votekickreplymessage();
  inline void clear_has_votekickreplymessage();
  inline void set_has_kickpetitionupdatemessage();
  inline void clear_has_kickpetitionupdatemessage();
  inline void set_has_endkickpetitionmessage();
  inline void clear_has_endkickpetitionmessage();
  inline void set_has_statisticsmessage();
  inline void clear_has_statisticsmessage();
  inline void set_has_chatrequestmessage();
  inline void clear_has_chatrequestmessage();
  inline void set_has_chatmessage();
  inline void clear_has_chatmessage();
  inline void set_has_chatrejectmessage();
  inline void clear_has_chatrejectmessage();
  inline void set_has_dialogmessage();
  inline void clear_has_dialogmessage();
  inline void set_has_timeoutwarningmessage();
  inline void clear_has_timeoutwarningmessage();
  inline void set_has_resettimeoutmessage();
  inline void clear_has_resettimeoutmessage();
  inline void set_has_reportavatarmessage();
  inline void clear_has_reportavatarmessage();
  inline void set_has_reportavatarackmessage();
  inline void clear_has_reportavatarackmessage();
  inline void set_has_reportgamemessage();
  inline void clear_has_reportgamemessage();
  inline void set_has_reportgameackmessage();
  inline void clear_has_reportgameackmessage();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  inline void set_has_adminremovegamemessage();
  inline void clear_has_adminremovegamemessage();
  inline void set_has_adminremovegameackmessage();
  inline void clear_has_adminremovegameackmessage();
  inline void set_has_adminbanplayermessage();
  inline void clear_has_adminbanplayermessage();
  inline void set_has_adminbanplayerackmessage();
  inline void clear_has_adminbanplayerackmessage();
  inline void set_has_gamelistspectatorjoinedmessage();
  inline void clear_has_gamelistspectatorjoinedmessage();
  inline void set_has_gamelistspectatorleftmessage();
  inline void clear_has_gamelistspectatorleftmessage();
  inline void set_has_gamespectatorjoinedmessage();
  inline void clear_has_gamespectatorjoinedmessage();
  inline void set_has_gamespectatorleftmessage();
  inline void clear_has_gamespectatorleftmessage();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[3];
  mutable int _cached_size_;
  ::AnnounceMessage* announcemessage_;
  ::InitMessage* initmessage_;
  ::AuthServerChallengeMessage* authserverchallengemessage_;
  ::AuthClientResponseMessage* authclientresponsemessage_;
  ::AuthServerVerificationMessage* authserververificationmessage_;
  ::InitAckMessage* initackmessage_;
  ::AvatarRequestMessage* avatarrequestmessage_;
  ::AvatarHeaderMessage* avatarheadermessage_;
  ::AvatarDataMessage* avatardatamessage_;
  ::AvatarEndMessage* avatarendmessage_;
  ::UnknownAvatarMessage* unknownavatarmessage_;
  ::PlayerListMessage* playerlistmessage_;
  ::GameListNewMessage* gamelistnewmessage_;
  ::GameListUpdateMessage* gamelistupdatemessage_;
  ::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage_;
  ::GameListPlayerLeftMessage* gamelistplayerleftmessage_;
  ::GameListAdminChangedMessage* gamelistadminchangedmessage_;
  ::PlayerInfoRequestMessage* playerinforequestmessage_;
  ::PlayerInfoReplyMessage* playerinforeplymessage_;
  ::SubscriptionRequestMessage* subscriptionrequestmessage_;
  ::JoinExistingGameMessage* joinexistinggamemessage_;
  ::JoinNewGameMessage* joinnewgamemessage_;
  ::RejoinExistingGameMessage* rejoinexistinggamemessage_;
  ::JoinGameAckMessage* joingameackmessage_;
  ::JoinGameFailedMessage* joingamefailedmessage_;
  ::GamePlayerJoinedMessage* gameplayerjoinedmessage_;
  ::GamePlayerLeftMessage* gameplayerleftmessage_;
  ::GameAdminChangedMessage* gameadminchangedmessage_;
  ::RemovedFromGameMessage* removedfromgamemessage_;
  ::KickPlayerRequestMessage* kickplayerrequestmessage_;
  ::LeaveGameRequestMessage* leavegamerequestmessage_;
  ::InvitePlayerToGameMessage* inviteplayertogamemessage_;
  ::InviteNotifyMessage* invitenotifymessage_;
  ::RejectGameInvitationMessage* rejectgameinvitationmessage_;
  ::RejectInvNotifyMessage* rejectinvnotifymessage_;
  ::StartEventMessage* starteventmessage_;
  ::StartEventAckMessage* starteventackmessage_;
  ::GameStartInitialMessage* gamestartinitialmessage_;
  ::GameStartRejoinMessage* gamestartrejoinmessage_;
  ::HandStartMessage* handstartmessage_;
  ::PlayersTurnMessage* playersturnmessage_;
  ::MyActionRequestMessage* myactionrequestmessage_;
  ::YourActionRejectedMessage* youractionrejectedmessage_;
  ::PlayersActionDoneMessage* playersactiondonemessage_;
  ::DealFlopCardsMessage* dealflopcardsmessage_;
  ::DealTurnCardMessage* dealturncardmessage_;
  ::DealRiverCardMessage* dealrivercardmessage_;
  ::AllInShowCardsMessage* allinshowcardsmessage_;
  ::EndOfHandShowCardsMessage* endofhandshowcardsmessage_;
  ::EndOfHandHideCardsMessage* endofhandhidecardsmessage_;
  ::ShowMyCardsRequestMessage* showmycardsrequestmessage_;
  ::AfterHandShowCardsMessage* afterhandshowcardsmessage_;
  ::EndOfGameMessage* endofgamemessage_;
  ::PlayerIdChangedMessage* playeridchangedmessage_;
  ::AskKickPlayerMessage* askkickplayermessage_;
  ::AskKickDeniedMessage* askkickdeniedmessage_;
  ::StartKickPetitionMessage* startkickpetitionmessage_;
  ::VoteKickRequestMessage* votekickrequestmessage_;
  ::VoteKickReplyMessage* votekickreplymessage_;
  ::KickPetitionUpdateMessage* kickpetitionupdatemessage_;
  ::EndKickPetitionMessage* endkickpetitionmessage_;
  ::StatisticsMessage* statisticsmessage_;
  ::ChatRequestMessage* chatrequestmessage_;
  ::ChatMessage* chatmessage_;
  ::ChatRejectMessage* chatrejectmessage_;
  ::DialogMessage* dialogmessage_;
  ::TimeoutWarningMessage* timeoutwarningmessage_;
  ::ResetTimeoutMessage* resettimeoutmessage_;
  ::ReportAvatarMessage* reportavatarmessage_;
  ::ReportAvatarAckMessage* reportavatarackmessage_;
  ::ReportGameMessage* reportgamemessage_;
  ::ReportGameAckMessage* reportgameackmessage_;
  ::ErrorMessage* errormessage_;
  ::AdminRemoveGameMessage* adminremovegamemessage_;
  ::AdminRemoveGameAckMessage* adminremovegameackmessage_;
  ::AdminBanPlayerMessage* adminbanplayermessage_;
  ::AdminBanPlayerAckMessage* adminbanplayerackmessage_;
  ::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage_;
  ::GameListSpectatorLeftMessage* gamelistspectatorleftmessage_;
  ::GameSpectatorJoinedMessage* gamespectatorjoinedmessage_;
  ::GameSpectatorLeftMessage* gamespectatorleftmessage_;
  int messagetype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pokerth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pokerth_2eproto();
  #endif
  friend void protobuf_AssignDesc_pokerth_2eproto();
  friend void protobuf_ShutdownFile_pokerth_2eproto();

  void InitAsDefaultInstance();
  static PokerTHMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// NetGameInfo

// required string gameName = 1;
inline bool NetGameInfo::has_gamename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetGameInfo::set_has_gamename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetGameInfo::clear_has_gamename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetGameInfo::clear_gamename() {
  if (gamename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gamename_->clear();
  }
  clear_has_gamename();
}
inline const ::std::string& NetGameInfo::gamename() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.gameName)
  return *gamename_;
}
inline void NetGameInfo::set_gamename(const ::std::string& value) {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gamename_ = new ::std::string;
  }
  gamename_->assign(value);
  // @@protoc_insertion_point(field_set:NetGameInfo.gameName)
}
inline void NetGameInfo::set_gamename(const char* value) {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gamename_ = new ::std::string;
  }
  gamename_->assign(value);
  // @@protoc_insertion_point(field_set_char:NetGameInfo.gameName)
}
inline void NetGameInfo::set_gamename(const char* value, size_t size) {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gamename_ = new ::std::string;
  }
  gamename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NetGameInfo.gameName)
}
inline ::std::string* NetGameInfo::mutable_gamename() {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gamename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NetGameInfo.gameName)
  return gamename_;
}
inline ::std::string* NetGameInfo::release_gamename() {
  clear_has_gamename();
  if (gamename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gamename_;
    gamename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NetGameInfo::set_allocated_gamename(::std::string* gamename) {
  if (gamename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gamename_;
  }
  if (gamename) {
    set_has_gamename();
    gamename_ = gamename;
  } else {
    clear_has_gamename();
    gamename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NetGameInfo.gameName)
}

// required .NetGameInfo.NetGameType netGameType = 2;
inline bool NetGameInfo::has_netgametype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetGameInfo::set_has_netgametype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetGameInfo::clear_has_netgametype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetGameInfo::clear_netgametype() {
  netgametype_ = 1;
  clear_has_netgametype();
}
inline ::NetGameInfo_NetGameType NetGameInfo::netgametype() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.netGameType)
  return static_cast< ::NetGameInfo_NetGameType >(netgametype_);
}
inline void NetGameInfo::set_netgametype(::NetGameInfo_NetGameType value) {
  assert(::NetGameInfo_NetGameType_IsValid(value));
  set_has_netgametype();
  netgametype_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.netGameType)
}

// required uint32 maxNumPlayers = 3;
inline bool NetGameInfo::has_maxnumplayers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetGameInfo::set_has_maxnumplayers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetGameInfo::clear_has_maxnumplayers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetGameInfo::clear_maxnumplayers() {
  maxnumplayers_ = 0u;
  clear_has_maxnumplayers();
}
inline ::google::protobuf::uint32 NetGameInfo::maxnumplayers() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.maxNumPlayers)
  return maxnumplayers_;
}
inline void NetGameInfo::set_maxnumplayers(::google::protobuf::uint32 value) {
  set_has_maxnumplayers();
  maxnumplayers_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.maxNumPlayers)
}

// required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
inline bool NetGameInfo::has_raiseintervalmode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetGameInfo::set_has_raiseintervalmode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetGameInfo::clear_has_raiseintervalmode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetGameInfo::clear_raiseintervalmode() {
  raiseintervalmode_ = 1;
  clear_has_raiseintervalmode();
}
inline ::NetGameInfo_RaiseIntervalMode NetGameInfo::raiseintervalmode() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.raiseIntervalMode)
  return static_cast< ::NetGameInfo_RaiseIntervalMode >(raiseintervalmode_);
}
inline void NetGameInfo::set_raiseintervalmode(::NetGameInfo_RaiseIntervalMode value) {
  assert(::NetGameInfo_RaiseIntervalMode_IsValid(value));
  set_has_raiseintervalmode();
  raiseintervalmode_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.raiseIntervalMode)
}

// optional uint32 raiseEveryHands = 5;
inline bool NetGameInfo::has_raiseeveryhands() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetGameInfo::set_has_raiseeveryhands() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetGameInfo::clear_has_raiseeveryhands() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetGameInfo::clear_raiseeveryhands() {
  raiseeveryhands_ = 0u;
  clear_has_raiseeveryhands();
}
inline ::google::protobuf::uint32 NetGameInfo::raiseeveryhands() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.raiseEveryHands)
  return raiseeveryhands_;
}
inline void NetGameInfo::set_raiseeveryhands(::google::protobuf::uint32 value) {
  set_has_raiseeveryhands();
  raiseeveryhands_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.raiseEveryHands)
}

// optional uint32 raiseEveryMinutes = 6;
inline bool NetGameInfo::has_raiseeveryminutes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetGameInfo::set_has_raiseeveryminutes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NetGameInfo::clear_has_raiseeveryminutes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NetGameInfo::clear_raiseeveryminutes() {
  raiseeveryminutes_ = 0u;
  clear_has_raiseeveryminutes();
}
inline ::google::protobuf::uint32 NetGameInfo::raiseeveryminutes() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.raiseEveryMinutes)
  return raiseeveryminutes_;
}
inline void NetGameInfo::set_raiseeveryminutes(::google::protobuf::uint32 value) {
  set_has_raiseeveryminutes();
  raiseeveryminutes_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.raiseEveryMinutes)
}

// required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
inline bool NetGameInfo::has_endraisemode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NetGameInfo::set_has_endraisemode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NetGameInfo::clear_has_endraisemode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NetGameInfo::clear_endraisemode() {
  endraisemode_ = 1;
  clear_has_endraisemode();
}
inline ::NetGameInfo_EndRaiseMode NetGameInfo::endraisemode() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.endRaiseMode)
  return static_cast< ::NetGameInfo_EndRaiseMode >(endraisemode_);
}
inline void NetGameInfo::set_endraisemode(::NetGameInfo_EndRaiseMode value) {
  assert(::NetGameInfo_EndRaiseMode_IsValid(value));
  set_has_endraisemode();
  endraisemode_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.endRaiseMode)
}

// optional uint32 endRaiseSmallBlindValue = 8;
inline bool NetGameInfo::has_endraisesmallblindvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NetGameInfo::set_has_endraisesmallblindvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NetGameInfo::clear_has_endraisesmallblindvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NetGameInfo::clear_endraisesmallblindvalue() {
  endraisesmallblindvalue_ = 0u;
  clear_has_endraisesmallblindvalue();
}
inline ::google::protobuf::uint32 NetGameInfo::endraisesmallblindvalue() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.endRaiseSmallBlindValue)
  return endraisesmallblindvalue_;
}
inline void NetGameInfo::set_endraisesmallblindvalue(::google::protobuf::uint32 value) {
  set_has_endraisesmallblindvalue();
  endraisesmallblindvalue_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.endRaiseSmallBlindValue)
}

// required uint32 proposedGuiSpeed = 9;
inline bool NetGameInfo::has_proposedguispeed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NetGameInfo::set_has_proposedguispeed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NetGameInfo::clear_has_proposedguispeed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NetGameInfo::clear_proposedguispeed() {
  proposedguispeed_ = 0u;
  clear_has_proposedguispeed();
}
inline ::google::protobuf::uint32 NetGameInfo::proposedguispeed() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.proposedGuiSpeed)
  return proposedguispeed_;
}
inline void NetGameInfo::set_proposedguispeed(::google::protobuf::uint32 value) {
  set_has_proposedguispeed();
  proposedguispeed_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.proposedGuiSpeed)
}

// required uint32 delayBetweenHands = 10;
inline bool NetGameInfo::has_delaybetweenhands() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NetGameInfo::set_has_delaybetweenhands() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NetGameInfo::clear_has_delaybetweenhands() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NetGameInfo::clear_delaybetweenhands() {
  delaybetweenhands_ = 0u;
  clear_has_delaybetweenhands();
}
inline ::google::protobuf::uint32 NetGameInfo::delaybetweenhands() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.delayBetweenHands)
  return delaybetweenhands_;
}
inline void NetGameInfo::set_delaybetweenhands(::google::protobuf::uint32 value) {
  set_has_delaybetweenhands();
  delaybetweenhands_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.delayBetweenHands)
}

// required uint32 playerActionTimeout = 11;
inline bool NetGameInfo::has_playeractiontimeout() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NetGameInfo::set_has_playeractiontimeout() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NetGameInfo::clear_has_playeractiontimeout() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NetGameInfo::clear_playeractiontimeout() {
  playeractiontimeout_ = 0u;
  clear_has_playeractiontimeout();
}
inline ::google::protobuf::uint32 NetGameInfo::playeractiontimeout() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.playerActionTimeout)
  return playeractiontimeout_;
}
inline void NetGameInfo::set_playeractiontimeout(::google::protobuf::uint32 value) {
  set_has_playeractiontimeout();
  playeractiontimeout_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.playerActionTimeout)
}

// required uint32 firstSmallBlind = 12;
inline bool NetGameInfo::has_firstsmallblind() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NetGameInfo::set_has_firstsmallblind() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NetGameInfo::clear_has_firstsmallblind() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NetGameInfo::clear_firstsmallblind() {
  firstsmallblind_ = 0u;
  clear_has_firstsmallblind();
}
inline ::google::protobuf::uint32 NetGameInfo::firstsmallblind() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.firstSmallBlind)
  return firstsmallblind_;
}
inline void NetGameInfo::set_firstsmallblind(::google::protobuf::uint32 value) {
  set_has_firstsmallblind();
  firstsmallblind_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.firstSmallBlind)
}

// required uint32 startMoney = 13;
inline bool NetGameInfo::has_startmoney() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NetGameInfo::set_has_startmoney() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NetGameInfo::clear_has_startmoney() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NetGameInfo::clear_startmoney() {
  startmoney_ = 0u;
  clear_has_startmoney();
}
inline ::google::protobuf::uint32 NetGameInfo::startmoney() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.startMoney)
  return startmoney_;
}
inline void NetGameInfo::set_startmoney(::google::protobuf::uint32 value) {
  set_has_startmoney();
  startmoney_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.startMoney)
}

// repeated uint32 manualBlinds = 14 [packed = true];
inline int NetGameInfo::manualblinds_size() const {
  return manualblinds_.size();
}
inline void NetGameInfo::clear_manualblinds() {
  manualblinds_.Clear();
}
inline ::google::protobuf::uint32 NetGameInfo::manualblinds(int index) const {
  // @@protoc_insertion_point(field_get:NetGameInfo.manualBlinds)
  return manualblinds_.Get(index);
}
inline void NetGameInfo::set_manualblinds(int index, ::google::protobuf::uint32 value) {
  manualblinds_.Set(index, value);
  // @@protoc_insertion_point(field_set:NetGameInfo.manualBlinds)
}
inline void NetGameInfo::add_manualblinds(::google::protobuf::uint32 value) {
  manualblinds_.Add(value);
  // @@protoc_insertion_point(field_add:NetGameInfo.manualBlinds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NetGameInfo::manualblinds() const {
  // @@protoc_insertion_point(field_list:NetGameInfo.manualBlinds)
  return manualblinds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NetGameInfo::mutable_manualblinds() {
  // @@protoc_insertion_point(field_mutable_list:NetGameInfo.manualBlinds)
  return &manualblinds_;
}

// optional bool allowSpectators = 15 [default = true];
inline bool NetGameInfo::has_allowspectators() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NetGameInfo::set_has_allowspectators() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NetGameInfo::clear_has_allowspectators() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NetGameInfo::clear_allowspectators() {
  allowspectators_ = true;
  clear_has_allowspectators();
}
inline bool NetGameInfo::allowspectators() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.allowSpectators)
  return allowspectators_;
}
inline void NetGameInfo::set_allowspectators(bool value) {
  set_has_allowspectators();
  allowspectators_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.allowSpectators)
}

// -------------------------------------------------------------------

// PlayerResult

// required uint32 playerId = 1;
inline bool PlayerResult::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerResult::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerResult::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerResult::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayerResult::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerResult.playerId)
  return playerid_;
}
inline void PlayerResult::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.playerId)
}

// required uint32 resultCard1 = 2;
inline bool PlayerResult::has_resultcard1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerResult::set_has_resultcard1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerResult::clear_has_resultcard1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerResult::clear_resultcard1() {
  resultcard1_ = 0u;
  clear_has_resultcard1();
}
inline ::google::protobuf::uint32 PlayerResult::resultcard1() const {
  // @@protoc_insertion_point(field_get:PlayerResult.resultCard1)
  return resultcard1_;
}
inline void PlayerResult::set_resultcard1(::google::protobuf::uint32 value) {
  set_has_resultcard1();
  resultcard1_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.resultCard1)
}

// required uint32 resultCard2 = 3;
inline bool PlayerResult::has_resultcard2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerResult::set_has_resultcard2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerResult::clear_has_resultcard2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerResult::clear_resultcard2() {
  resultcard2_ = 0u;
  clear_has_resultcard2();
}
inline ::google::protobuf::uint32 PlayerResult::resultcard2() const {
  // @@protoc_insertion_point(field_get:PlayerResult.resultCard2)
  return resultcard2_;
}
inline void PlayerResult::set_resultcard2(::google::protobuf::uint32 value) {
  set_has_resultcard2();
  resultcard2_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.resultCard2)
}

// repeated uint32 bestHandPosition = 4 [packed = true];
inline int PlayerResult::besthandposition_size() const {
  return besthandposition_.size();
}
inline void PlayerResult::clear_besthandposition() {
  besthandposition_.Clear();
}
inline ::google::protobuf::uint32 PlayerResult::besthandposition(int index) const {
  // @@protoc_insertion_point(field_get:PlayerResult.bestHandPosition)
  return besthandposition_.Get(index);
}
inline void PlayerResult::set_besthandposition(int index, ::google::protobuf::uint32 value) {
  besthandposition_.Set(index, value);
  // @@protoc_insertion_point(field_set:PlayerResult.bestHandPosition)
}
inline void PlayerResult::add_besthandposition(::google::protobuf::uint32 value) {
  besthandposition_.Add(value);
  // @@protoc_insertion_point(field_add:PlayerResult.bestHandPosition)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PlayerResult::besthandposition() const {
  // @@protoc_insertion_point(field_list:PlayerResult.bestHandPosition)
  return besthandposition_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PlayerResult::mutable_besthandposition() {
  // @@protoc_insertion_point(field_mutable_list:PlayerResult.bestHandPosition)
  return &besthandposition_;
}

// required uint32 moneyWon = 5;
inline bool PlayerResult::has_moneywon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerResult::set_has_moneywon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerResult::clear_has_moneywon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerResult::clear_moneywon() {
  moneywon_ = 0u;
  clear_has_moneywon();
}
inline ::google::protobuf::uint32 PlayerResult::moneywon() const {
  // @@protoc_insertion_point(field_get:PlayerResult.moneyWon)
  return moneywon_;
}
inline void PlayerResult::set_moneywon(::google::protobuf::uint32 value) {
  set_has_moneywon();
  moneywon_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.moneyWon)
}

// required uint32 playerMoney = 6;
inline bool PlayerResult::has_playermoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerResult::set_has_playermoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerResult::clear_has_playermoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerResult::clear_playermoney() {
  playermoney_ = 0u;
  clear_has_playermoney();
}
inline ::google::protobuf::uint32 PlayerResult::playermoney() const {
  // @@protoc_insertion_point(field_get:PlayerResult.playerMoney)
  return playermoney_;
}
inline void PlayerResult::set_playermoney(::google::protobuf::uint32 value) {
  set_has_playermoney();
  playermoney_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.playerMoney)
}

// optional uint32 cardsValue = 7;
inline bool PlayerResult::has_cardsvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerResult::set_has_cardsvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerResult::clear_has_cardsvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerResult::clear_cardsvalue() {
  cardsvalue_ = 0u;
  clear_has_cardsvalue();
}
inline ::google::protobuf::uint32 PlayerResult::cardsvalue() const {
  // @@protoc_insertion_point(field_get:PlayerResult.cardsValue)
  return cardsvalue_;
}
inline void PlayerResult::set_cardsvalue(::google::protobuf::uint32 value) {
  set_has_cardsvalue();
  cardsvalue_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.cardsValue)
}

// -------------------------------------------------------------------

// AnnounceMessage_Version

// required uint32 majorVersion = 1;
inline bool AnnounceMessage_Version::has_majorversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnounceMessage_Version::set_has_majorversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnnounceMessage_Version::clear_has_majorversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnnounceMessage_Version::clear_majorversion() {
  majorversion_ = 0u;
  clear_has_majorversion();
}
inline ::google::protobuf::uint32 AnnounceMessage_Version::majorversion() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.Version.majorVersion)
  return majorversion_;
}
inline void AnnounceMessage_Version::set_majorversion(::google::protobuf::uint32 value) {
  set_has_majorversion();
  majorversion_ = value;
  // @@protoc_insertion_point(field_set:AnnounceMessage.Version.majorVersion)
}

// required uint32 minorVersion = 2;
inline bool AnnounceMessage_Version::has_minorversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnnounceMessage_Version::set_has_minorversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnnounceMessage_Version::clear_has_minorversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnnounceMessage_Version::clear_minorversion() {
  minorversion_ = 0u;
  clear_has_minorversion();
}
inline ::google::protobuf::uint32 AnnounceMessage_Version::minorversion() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.Version.minorVersion)
  return minorversion_;
}
inline void AnnounceMessage_Version::set_minorversion(::google::protobuf::uint32 value) {
  set_has_minorversion();
  minorversion_ = value;
  // @@protoc_insertion_point(field_set:AnnounceMessage.Version.minorVersion)
}

// -------------------------------------------------------------------

// AnnounceMessage

// required .AnnounceMessage.Version protocolVersion = 1;
inline bool AnnounceMessage::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnounceMessage::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnnounceMessage::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnnounceMessage::clear_protocolversion() {
  if (protocolversion_ != NULL) protocolversion_->::AnnounceMessage_Version::Clear();
  clear_has_protocolversion();
}
inline const ::AnnounceMessage_Version& AnnounceMessage::protocolversion() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.protocolVersion)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return protocolversion_ != NULL ? *protocolversion_ : *default_instance().protocolversion_;
#else
  return protocolversion_ != NULL ? *protocolversion_ : *default_instance_->protocolversion_;
#endif
}
inline ::AnnounceMessage_Version* AnnounceMessage::mutable_protocolversion() {
  set_has_protocolversion();
  if (protocolversion_ == NULL) protocolversion_ = new ::AnnounceMessage_Version;
  // @@protoc_insertion_point(field_mutable:AnnounceMessage.protocolVersion)
  return protocolversion_;
}
inline ::AnnounceMessage_Version* AnnounceMessage::release_protocolversion() {
  clear_has_protocolversion();
  ::AnnounceMessage_Version* temp = protocolversion_;
  protocolversion_ = NULL;
  return temp;
}
inline void AnnounceMessage::set_allocated_protocolversion(::AnnounceMessage_Version* protocolversion) {
  delete protocolversion_;
  protocolversion_ = protocolversion;
  if (protocolversion) {
    set_has_protocolversion();
  } else {
    clear_has_protocolversion();
  }
  // @@protoc_insertion_point(field_set_allocated:AnnounceMessage.protocolVersion)
}

// required .AnnounceMessage.Version latestGameVersion = 2;
inline bool AnnounceMessage::has_latestgameversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnnounceMessage::set_has_latestgameversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnnounceMessage::clear_has_latestgameversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnnounceMessage::clear_latestgameversion() {
  if (latestgameversion_ != NULL) latestgameversion_->::AnnounceMessage_Version::Clear();
  clear_has_latestgameversion();
}
inline const ::AnnounceMessage_Version& AnnounceMessage::latestgameversion() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.latestGameVersion)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return latestgameversion_ != NULL ? *latestgameversion_ : *default_instance().latestgameversion_;
#else
  return latestgameversion_ != NULL ? *latestgameversion_ : *default_instance_->latestgameversion_;
#endif
}
inline ::AnnounceMessage_Version* AnnounceMessage::mutable_latestgameversion() {
  set_has_latestgameversion();
  if (latestgameversion_ == NULL) latestgameversion_ = new ::AnnounceMessage_Version;
  // @@protoc_insertion_point(field_mutable:AnnounceMessage.latestGameVersion)
  return latestgameversion_;
}
inline ::AnnounceMessage_Version* AnnounceMessage::release_latestgameversion() {
  clear_has_latestgameversion();
  ::AnnounceMessage_Version* temp = latestgameversion_;
  latestgameversion_ = NULL;
  return temp;
}
inline void AnnounceMessage::set_allocated_latestgameversion(::AnnounceMessage_Version* latestgameversion) {
  delete latestgameversion_;
  latestgameversion_ = latestgameversion;
  if (latestgameversion) {
    set_has_latestgameversion();
  } else {
    clear_has_latestgameversion();
  }
  // @@protoc_insertion_point(field_set_allocated:AnnounceMessage.latestGameVersion)
}

// required uint32 latestBetaRevision = 3;
inline bool AnnounceMessage::has_latestbetarevision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnnounceMessage::set_has_latestbetarevision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnnounceMessage::clear_has_latestbetarevision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnnounceMessage::clear_latestbetarevision() {
  latestbetarevision_ = 0u;
  clear_has_latestbetarevision();
}
inline ::google::protobuf::uint32 AnnounceMessage::latestbetarevision() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.latestBetaRevision)
  return latestbetarevision_;
}
inline void AnnounceMessage::set_latestbetarevision(::google::protobuf::uint32 value) {
  set_has_latestbetarevision();
  latestbetarevision_ = value;
  // @@protoc_insertion_point(field_set:AnnounceMessage.latestBetaRevision)
}

// required .AnnounceMessage.ServerType serverType = 4;
inline bool AnnounceMessage::has_servertype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnnounceMessage::set_has_servertype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnnounceMessage::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnnounceMessage::clear_servertype() {
  servertype_ = 0;
  clear_has_servertype();
}
inline ::AnnounceMessage_ServerType AnnounceMessage::servertype() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.serverType)
  return static_cast< ::AnnounceMessage_ServerType >(servertype_);
}
inline void AnnounceMessage::set_servertype(::AnnounceMessage_ServerType value) {
  assert(::AnnounceMessage_ServerType_IsValid(value));
  set_has_servertype();
  servertype_ = value;
  // @@protoc_insertion_point(field_set:AnnounceMessage.serverType)
}

// required uint32 numPlayersOnServer = 5;
inline bool AnnounceMessage::has_numplayersonserver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnnounceMessage::set_has_numplayersonserver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnnounceMessage::clear_has_numplayersonserver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnnounceMessage::clear_numplayersonserver() {
  numplayersonserver_ = 0u;
  clear_has_numplayersonserver();
}
inline ::google::protobuf::uint32 AnnounceMessage::numplayersonserver() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.numPlayersOnServer)
  return numplayersonserver_;
}
inline void AnnounceMessage::set_numplayersonserver(::google::protobuf::uint32 value) {
  set_has_numplayersonserver();
  numplayersonserver_ = value;
  // @@protoc_insertion_point(field_set:AnnounceMessage.numPlayersOnServer)
}

// -------------------------------------------------------------------

// InitMessage

// required .AnnounceMessage.Version requestedVersion = 1;
inline bool InitMessage::has_requestedversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitMessage::set_has_requestedversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitMessage::clear_has_requestedversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitMessage::clear_requestedversion() {
  if (requestedversion_ != NULL) requestedversion_->::AnnounceMessage_Version::Clear();
  clear_has_requestedversion();
}
inline const ::AnnounceMessage_Version& InitMessage::requestedversion() const {
  // @@protoc_insertion_point(field_get:InitMessage.requestedVersion)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return requestedversion_ != NULL ? *requestedversion_ : *default_instance().requestedversion_;
#else
  return requestedversion_ != NULL ? *requestedversion_ : *default_instance_->requestedversion_;
#endif
}
inline ::AnnounceMessage_Version* InitMessage::mutable_requestedversion() {
  set_has_requestedversion();
  if (requestedversion_ == NULL) requestedversion_ = new ::AnnounceMessage_Version;
  // @@protoc_insertion_point(field_mutable:InitMessage.requestedVersion)
  return requestedversion_;
}
inline ::AnnounceMessage_Version* InitMessage::release_requestedversion() {
  clear_has_requestedversion();
  ::AnnounceMessage_Version* temp = requestedversion_;
  requestedversion_ = NULL;
  return temp;
}
inline void InitMessage::set_allocated_requestedversion(::AnnounceMessage_Version* requestedversion) {
  delete requestedversion_;
  requestedversion_ = requestedversion;
  if (requestedversion) {
    set_has_requestedversion();
  } else {
    clear_has_requestedversion();
  }
  // @@protoc_insertion_point(field_set_allocated:InitMessage.requestedVersion)
}

// required uint32 buildId = 2;
inline bool InitMessage::has_buildid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitMessage::set_has_buildid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitMessage::clear_has_buildid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitMessage::clear_buildid() {
  buildid_ = 0u;
  clear_has_buildid();
}
inline ::google::protobuf::uint32 InitMessage::buildid() const {
  // @@protoc_insertion_point(field_get:InitMessage.buildId)
  return buildid_;
}
inline void InitMessage::set_buildid(::google::protobuf::uint32 value) {
  set_has_buildid();
  buildid_ = value;
  // @@protoc_insertion_point(field_set:InitMessage.buildId)
}

// optional bytes myLastSessionId = 3;
inline bool InitMessage::has_mylastsessionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitMessage::set_has_mylastsessionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitMessage::clear_has_mylastsessionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitMessage::clear_mylastsessionid() {
  if (mylastsessionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mylastsessionid_->clear();
  }
  clear_has_mylastsessionid();
}
inline const ::std::string& InitMessage::mylastsessionid() const {
  // @@protoc_insertion_point(field_get:InitMessage.myLastSessionId)
  return *mylastsessionid_;
}
inline void InitMessage::set_mylastsessionid(const ::std::string& value) {
  set_has_mylastsessionid();
  if (mylastsessionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mylastsessionid_ = new ::std::string;
  }
  mylastsessionid_->assign(value);
  // @@protoc_insertion_point(field_set:InitMessage.myLastSessionId)
}
inline void InitMessage::set_mylastsessionid(const char* value) {
  set_has_mylastsessionid();
  if (mylastsessionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mylastsessionid_ = new ::std::string;
  }
  mylastsessionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:InitMessage.myLastSessionId)
}
inline void InitMessage::set_mylastsessionid(const void* value, size_t size) {
  set_has_mylastsessionid();
  if (mylastsessionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mylastsessionid_ = new ::std::string;
  }
  mylastsessionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InitMessage.myLastSessionId)
}
inline ::std::string* InitMessage::mutable_mylastsessionid() {
  set_has_mylastsessionid();
  if (mylastsessionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mylastsessionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InitMessage.myLastSessionId)
  return mylastsessionid_;
}
inline ::std::string* InitMessage::release_mylastsessionid() {
  clear_has_mylastsessionid();
  if (mylastsessionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mylastsessionid_;
    mylastsessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitMessage::set_allocated_mylastsessionid(::std::string* mylastsessionid) {
  if (mylastsessionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mylastsessionid_;
  }
  if (mylastsessionid) {
    set_has_mylastsessionid();
    mylastsessionid_ = mylastsessionid;
  } else {
    clear_has_mylastsessionid();
    mylastsessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InitMessage.myLastSessionId)
}

// optional string authServerPassword = 4;
inline bool InitMessage::has_authserverpassword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitMessage::set_has_authserverpassword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitMessage::clear_has_authserverpassword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitMessage::clear_authserverpassword() {
  if (authserverpassword_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authserverpassword_->clear();
  }
  clear_has_authserverpassword();
}
inline const ::std::string& InitMessage::authserverpassword() const {
  // @@protoc_insertion_point(field_get:InitMessage.authServerPassword)
  return *authserverpassword_;
}
inline void InitMessage::set_authserverpassword(const ::std::string& value) {
  set_has_authserverpassword();
  if (authserverpassword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authserverpassword_ = new ::std::string;
  }
  authserverpassword_->assign(value);
  // @@protoc_insertion_point(field_set:InitMessage.authServerPassword)
}
inline void InitMessage::set_authserverpassword(const char* value) {
  set_has_authserverpassword();
  if (authserverpassword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authserverpassword_ = new ::std::string;
  }
  authserverpassword_->assign(value);
  // @@protoc_insertion_point(field_set_char:InitMessage.authServerPassword)
}
inline void InitMessage::set_authserverpassword(const char* value, size_t size) {
  set_has_authserverpassword();
  if (authserverpassword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authserverpassword_ = new ::std::string;
  }
  authserverpassword_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InitMessage.authServerPassword)
}
inline ::std::string* InitMessage::mutable_authserverpassword() {
  set_has_authserverpassword();
  if (authserverpassword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authserverpassword_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InitMessage.authServerPassword)
  return authserverpassword_;
}
inline ::std::string* InitMessage::release_authserverpassword() {
  clear_has_authserverpassword();
  if (authserverpassword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = authserverpassword_;
    authserverpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitMessage::set_allocated_authserverpassword(::std::string* authserverpassword) {
  if (authserverpassword_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete authserverpassword_;
  }
  if (authserverpassword) {
    set_has_authserverpassword();
    authserverpassword_ = authserverpassword;
  } else {
    clear_has_authserverpassword();
    authserverpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InitMessage.authServerPassword)
}

// required .InitMessage.LoginType login = 5;
inline bool InitMessage::has_login() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitMessage::set_has_login() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitMessage::clear_has_login() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitMessage::clear_login() {
  login_ = 0;
  clear_has_login();
}
inline ::InitMessage_LoginType InitMessage::login() const {
  // @@protoc_insertion_point(field_get:InitMessage.login)
  return static_cast< ::InitMessage_LoginType >(login_);
}
inline void InitMessage::set_login(::InitMessage_LoginType value) {
  assert(::InitMessage_LoginType_IsValid(value));
  set_has_login();
  login_ = value;
  // @@protoc_insertion_point(field_set:InitMessage.login)
}

// optional string nickName = 6;
inline bool InitMessage::has_nickname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InitMessage::set_has_nickname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InitMessage::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InitMessage::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& InitMessage::nickname() const {
  // @@protoc_insertion_point(field_get:InitMessage.nickName)
  return *nickname_;
}
inline void InitMessage::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:InitMessage.nickName)
}
inline void InitMessage::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:InitMessage.nickName)
}
inline void InitMessage::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InitMessage.nickName)
}
inline ::std::string* InitMessage::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InitMessage.nickName)
  return nickname_;
}
inline ::std::string* InitMessage::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitMessage::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InitMessage.nickName)
}

// optional bytes clientUserData = 7;
inline bool InitMessage::has_clientuserdata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InitMessage::set_has_clientuserdata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InitMessage::clear_has_clientuserdata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InitMessage::clear_clientuserdata() {
  if (clientuserdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientuserdata_->clear();
  }
  clear_has_clientuserdata();
}
inline const ::std::string& InitMessage::clientuserdata() const {
  // @@protoc_insertion_point(field_get:InitMessage.clientUserData)
  return *clientuserdata_;
}
inline void InitMessage::set_clientuserdata(const ::std::string& value) {
  set_has_clientuserdata();
  if (clientuserdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientuserdata_ = new ::std::string;
  }
  clientuserdata_->assign(value);
  // @@protoc_insertion_point(field_set:InitMessage.clientUserData)
}
inline void InitMessage::set_clientuserdata(const char* value) {
  set_has_clientuserdata();
  if (clientuserdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientuserdata_ = new ::std::string;
  }
  clientuserdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:InitMessage.clientUserData)
}
inline void InitMessage::set_clientuserdata(const void* value, size_t size) {
  set_has_clientuserdata();
  if (clientuserdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientuserdata_ = new ::std::string;
  }
  clientuserdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InitMessage.clientUserData)
}
inline ::std::string* InitMessage::mutable_clientuserdata() {
  set_has_clientuserdata();
  if (clientuserdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientuserdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InitMessage.clientUserData)
  return clientuserdata_;
}
inline ::std::string* InitMessage::release_clientuserdata() {
  clear_has_clientuserdata();
  if (clientuserdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientuserdata_;
    clientuserdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitMessage::set_allocated_clientuserdata(::std::string* clientuserdata) {
  if (clientuserdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientuserdata_;
  }
  if (clientuserdata) {
    set_has_clientuserdata();
    clientuserdata_ = clientuserdata;
  } else {
    clear_has_clientuserdata();
    clientuserdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InitMessage.clientUserData)
}

// optional bytes avatarHash = 8;
inline bool InitMessage::has_avatarhash() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InitMessage::set_has_avatarhash() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InitMessage::clear_has_avatarhash() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InitMessage::clear_avatarhash() {
  if (avatarhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_->clear();
  }
  clear_has_avatarhash();
}
inline const ::std::string& InitMessage::avatarhash() const {
  // @@protoc_insertion_point(field_get:InitMessage.avatarHash)
  return *avatarhash_;
}
inline void InitMessage::set_avatarhash(const ::std::string& value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
  // @@protoc_insertion_point(field_set:InitMessage.avatarHash)
}
inline void InitMessage::set_avatarhash(const char* value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
  // @@protoc_insertion_point(field_set_char:InitMessage.avatarHash)
}
inline void InitMessage::set_avatarhash(const void* value, size_t size) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InitMessage.avatarHash)
}
inline ::std::string* InitMessage::mutable_avatarhash() {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InitMessage.avatarHash)
  return avatarhash_;
}
inline ::std::string* InitMessage::release_avatarhash() {
  clear_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatarhash_;
    avatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitMessage::set_allocated_avatarhash(::std::string* avatarhash) {
  if (avatarhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatarhash_;
  }
  if (avatarhash) {
    set_has_avatarhash();
    avatarhash_ = avatarhash;
  } else {
    clear_has_avatarhash();
    avatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InitMessage.avatarHash)
}

// -------------------------------------------------------------------

// AuthServerChallengeMessage

// required bytes serverChallenge = 1;
inline bool AuthServerChallengeMessage::has_serverchallenge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthServerChallengeMessage::set_has_serverchallenge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthServerChallengeMessage::clear_has_serverchallenge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthServerChallengeMessage::clear_serverchallenge() {
  if (serverchallenge_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverchallenge_->clear();
  }
  clear_has_serverchallenge();
}
inline const ::std::string& AuthServerChallengeMessage::serverchallenge() const {
  // @@protoc_insertion_point(field_get:AuthServerChallengeMessage.serverChallenge)
  return *serverchallenge_;
}
inline void AuthServerChallengeMessage::set_serverchallenge(const ::std::string& value) {
  set_has_serverchallenge();
  if (serverchallenge_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverchallenge_ = new ::std::string;
  }
  serverchallenge_->assign(value);
  // @@protoc_insertion_point(field_set:AuthServerChallengeMessage.serverChallenge)
}
inline void AuthServerChallengeMessage::set_serverchallenge(const char* value) {
  set_has_serverchallenge();
  if (serverchallenge_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverchallenge_ = new ::std::string;
  }
  serverchallenge_->assign(value);
  // @@protoc_insertion_point(field_set_char:AuthServerChallengeMessage.serverChallenge)
}
inline void AuthServerChallengeMessage::set_serverchallenge(const void* value, size_t size) {
  set_has_serverchallenge();
  if (serverchallenge_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverchallenge_ = new ::std::string;
  }
  serverchallenge_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AuthServerChallengeMessage.serverChallenge)
}
inline ::std::string* AuthServerChallengeMessage::mutable_serverchallenge() {
  set_has_serverchallenge();
  if (serverchallenge_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverchallenge_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AuthServerChallengeMessage.serverChallenge)
  return serverchallenge_;
}
inline ::std::string* AuthServerChallengeMessage::release_serverchallenge() {
  clear_has_serverchallenge();
  if (serverchallenge_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverchallenge_;
    serverchallenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthServerChallengeMessage::set_allocated_serverchallenge(::std::string* serverchallenge) {
  if (serverchallenge_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverchallenge_;
  }
  if (serverchallenge) {
    set_has_serverchallenge();
    serverchallenge_ = serverchallenge;
  } else {
    clear_has_serverchallenge();
    serverchallenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthServerChallengeMessage.serverChallenge)
}

// -------------------------------------------------------------------

// AuthClientResponseMessage

// required bytes clientResponse = 1;
inline bool AuthClientResponseMessage::has_clientresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthClientResponseMessage::set_has_clientresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthClientResponseMessage::clear_has_clientresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthClientResponseMessage::clear_clientresponse() {
  if (clientresponse_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientresponse_->clear();
  }
  clear_has_clientresponse();
}
inline const ::std::string& AuthClientResponseMessage::clientresponse() const {
  // @@protoc_insertion_point(field_get:AuthClientResponseMessage.clientResponse)
  return *clientresponse_;
}
inline void AuthClientResponseMessage::set_clientresponse(const ::std::string& value) {
  set_has_clientresponse();
  if (clientresponse_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientresponse_ = new ::std::string;
  }
  clientresponse_->assign(value);
  // @@protoc_insertion_point(field_set:AuthClientResponseMessage.clientResponse)
}
inline void AuthClientResponseMessage::set_clientresponse(const char* value) {
  set_has_clientresponse();
  if (clientresponse_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientresponse_ = new ::std::string;
  }
  clientresponse_->assign(value);
  // @@protoc_insertion_point(field_set_char:AuthClientResponseMessage.clientResponse)
}
inline void AuthClientResponseMessage::set_clientresponse(const void* value, size_t size) {
  set_has_clientresponse();
  if (clientresponse_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientresponse_ = new ::std::string;
  }
  clientresponse_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AuthClientResponseMessage.clientResponse)
}
inline ::std::string* AuthClientResponseMessage::mutable_clientresponse() {
  set_has_clientresponse();
  if (clientresponse_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientresponse_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AuthClientResponseMessage.clientResponse)
  return clientresponse_;
}
inline ::std::string* AuthClientResponseMessage::release_clientresponse() {
  clear_has_clientresponse();
  if (clientresponse_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientresponse_;
    clientresponse_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthClientResponseMessage::set_allocated_clientresponse(::std::string* clientresponse) {
  if (clientresponse_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientresponse_;
  }
  if (clientresponse) {
    set_has_clientresponse();
    clientresponse_ = clientresponse;
  } else {
    clear_has_clientresponse();
    clientresponse_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthClientResponseMessage.clientResponse)
}

// -------------------------------------------------------------------

// AuthServerVerificationMessage

// required bytes serverVerification = 1;
inline bool AuthServerVerificationMessage::has_serververification() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthServerVerificationMessage::set_has_serververification() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthServerVerificationMessage::clear_has_serververification() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthServerVerificationMessage::clear_serververification() {
  if (serververification_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serververification_->clear();
  }
  clear_has_serververification();
}
inline const ::std::string& AuthServerVerificationMessage::serververification() const {
  // @@protoc_insertion_point(field_get:AuthServerVerificationMessage.serverVerification)
  return *serververification_;
}
inline void AuthServerVerificationMessage::set_serververification(const ::std::string& value) {
  set_has_serververification();
  if (serververification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serververification_ = new ::std::string;
  }
  serververification_->assign(value);
  // @@protoc_insertion_point(field_set:AuthServerVerificationMessage.serverVerification)
}
inline void AuthServerVerificationMessage::set_serververification(const char* value) {
  set_has_serververification();
  if (serververification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serververification_ = new ::std::string;
  }
  serververification_->assign(value);
  // @@protoc_insertion_point(field_set_char:AuthServerVerificationMessage.serverVerification)
}
inline void AuthServerVerificationMessage::set_serververification(const void* value, size_t size) {
  set_has_serververification();
  if (serververification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serververification_ = new ::std::string;
  }
  serververification_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AuthServerVerificationMessage.serverVerification)
}
inline ::std::string* AuthServerVerificationMessage::mutable_serververification() {
  set_has_serververification();
  if (serververification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serververification_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AuthServerVerificationMessage.serverVerification)
  return serververification_;
}
inline ::std::string* AuthServerVerificationMessage::release_serververification() {
  clear_has_serververification();
  if (serververification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serververification_;
    serververification_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthServerVerificationMessage::set_allocated_serververification(::std::string* serververification) {
  if (serververification_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serververification_;
  }
  if (serververification) {
    set_has_serververification();
    serververification_ = serververification;
  } else {
    clear_has_serververification();
    serververification_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthServerVerificationMessage.serverVerification)
}

// -------------------------------------------------------------------

// InitAckMessage

// required bytes yourSessionId = 1;
inline bool InitAckMessage::has_yoursessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitAckMessage::set_has_yoursessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitAckMessage::clear_has_yoursessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitAckMessage::clear_yoursessionid() {
  if (yoursessionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yoursessionid_->clear();
  }
  clear_has_yoursessionid();
}
inline const ::std::string& InitAckMessage::yoursessionid() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.yourSessionId)
  return *yoursessionid_;
}
inline void InitAckMessage::set_yoursessionid(const ::std::string& value) {
  set_has_yoursessionid();
  if (yoursessionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yoursessionid_ = new ::std::string;
  }
  yoursessionid_->assign(value);
  // @@protoc_insertion_point(field_set:InitAckMessage.yourSessionId)
}
inline void InitAckMessage::set_yoursessionid(const char* value) {
  set_has_yoursessionid();
  if (yoursessionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yoursessionid_ = new ::std::string;
  }
  yoursessionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:InitAckMessage.yourSessionId)
}
inline void InitAckMessage::set_yoursessionid(const void* value, size_t size) {
  set_has_yoursessionid();
  if (yoursessionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yoursessionid_ = new ::std::string;
  }
  yoursessionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InitAckMessage.yourSessionId)
}
inline ::std::string* InitAckMessage::mutable_yoursessionid() {
  set_has_yoursessionid();
  if (yoursessionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yoursessionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InitAckMessage.yourSessionId)
  return yoursessionid_;
}
inline ::std::string* InitAckMessage::release_yoursessionid() {
  clear_has_yoursessionid();
  if (yoursessionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = yoursessionid_;
    yoursessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitAckMessage::set_allocated_yoursessionid(::std::string* yoursessionid) {
  if (yoursessionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete yoursessionid_;
  }
  if (yoursessionid) {
    set_has_yoursessionid();
    yoursessionid_ = yoursessionid;
  } else {
    clear_has_yoursessionid();
    yoursessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InitAckMessage.yourSessionId)
}

// required uint32 yourPlayerId = 2;
inline bool InitAckMessage::has_yourplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitAckMessage::set_has_yourplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitAckMessage::clear_has_yourplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitAckMessage::clear_yourplayerid() {
  yourplayerid_ = 0u;
  clear_has_yourplayerid();
}
inline ::google::protobuf::uint32 InitAckMessage::yourplayerid() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.yourPlayerId)
  return yourplayerid_;
}
inline void InitAckMessage::set_yourplayerid(::google::protobuf::uint32 value) {
  set_has_yourplayerid();
  yourplayerid_ = value;
  // @@protoc_insertion_point(field_set:InitAckMessage.yourPlayerId)
}

// optional bytes yourAvatarHash = 3;
inline bool InitAckMessage::has_youravatarhash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitAckMessage::set_has_youravatarhash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitAckMessage::clear_has_youravatarhash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitAckMessage::clear_youravatarhash() {
  if (youravatarhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    youravatarhash_->clear();
  }
  clear_has_youravatarhash();
}
inline const ::std::string& InitAckMessage::youravatarhash() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.yourAvatarHash)
  return *youravatarhash_;
}
inline void InitAckMessage::set_youravatarhash(const ::std::string& value) {
  set_has_youravatarhash();
  if (youravatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    youravatarhash_ = new ::std::string;
  }
  youravatarhash_->assign(value);
  // @@protoc_insertion_point(field_set:InitAckMessage.yourAvatarHash)
}
inline void InitAckMessage::set_youravatarhash(const char* value) {
  set_has_youravatarhash();
  if (youravatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    youravatarhash_ = new ::std::string;
  }
  youravatarhash_->assign(value);
  // @@protoc_insertion_point(field_set_char:InitAckMessage.yourAvatarHash)
}
inline void InitAckMessage::set_youravatarhash(const void* value, size_t size) {
  set_has_youravatarhash();
  if (youravatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    youravatarhash_ = new ::std::string;
  }
  youravatarhash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InitAckMessage.yourAvatarHash)
}
inline ::std::string* InitAckMessage::mutable_youravatarhash() {
  set_has_youravatarhash();
  if (youravatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    youravatarhash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InitAckMessage.yourAvatarHash)
  return youravatarhash_;
}
inline ::std::string* InitAckMessage::release_youravatarhash() {
  clear_has_youravatarhash();
  if (youravatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = youravatarhash_;
    youravatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitAckMessage::set_allocated_youravatarhash(::std::string* youravatarhash) {
  if (youravatarhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete youravatarhash_;
  }
  if (youravatarhash) {
    set_has_youravatarhash();
    youravatarhash_ = youravatarhash;
  } else {
    clear_has_youravatarhash();
    youravatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InitAckMessage.yourAvatarHash)
}

// optional uint32 rejoinGameId = 4;
inline bool InitAckMessage::has_rejoingameid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitAckMessage::set_has_rejoingameid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitAckMessage::clear_has_rejoingameid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitAckMessage::clear_rejoingameid() {
  rejoingameid_ = 0u;
  clear_has_rejoingameid();
}
inline ::google::protobuf::uint32 InitAckMessage::rejoingameid() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.rejoinGameId)
  return rejoingameid_;
}
inline void InitAckMessage::set_rejoingameid(::google::protobuf::uint32 value) {
  set_has_rejoingameid();
  rejoingameid_ = value;
  // @@protoc_insertion_point(field_set:InitAckMessage.rejoinGameId)
}

// -------------------------------------------------------------------

// AvatarRequestMessage

// required uint32 requestId = 1;
inline bool AvatarRequestMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarRequestMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarRequestMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarRequestMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 AvatarRequestMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarRequestMessage.requestId)
  return requestid_;
}
inline void AvatarRequestMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:AvatarRequestMessage.requestId)
}

// required bytes avatarHash = 2;
inline bool AvatarRequestMessage::has_avatarhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarRequestMessage::set_has_avatarhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AvatarRequestMessage::clear_has_avatarhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AvatarRequestMessage::clear_avatarhash() {
  if (avatarhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_->clear();
  }
  clear_has_avatarhash();
}
inline const ::std::string& AvatarRequestMessage::avatarhash() const {
  // @@protoc_insertion_point(field_get:AvatarRequestMessage.avatarHash)
  return *avatarhash_;
}
inline void AvatarRequestMessage::set_avatarhash(const ::std::string& value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
  // @@protoc_insertion_point(field_set:AvatarRequestMessage.avatarHash)
}
inline void AvatarRequestMessage::set_avatarhash(const char* value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
  // @@protoc_insertion_point(field_set_char:AvatarRequestMessage.avatarHash)
}
inline void AvatarRequestMessage::set_avatarhash(const void* value, size_t size) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AvatarRequestMessage.avatarHash)
}
inline ::std::string* AvatarRequestMessage::mutable_avatarhash() {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AvatarRequestMessage.avatarHash)
  return avatarhash_;
}
inline ::std::string* AvatarRequestMessage::release_avatarhash() {
  clear_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatarhash_;
    avatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AvatarRequestMessage::set_allocated_avatarhash(::std::string* avatarhash) {
  if (avatarhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatarhash_;
  }
  if (avatarhash) {
    set_has_avatarhash();
    avatarhash_ = avatarhash;
  } else {
    clear_has_avatarhash();
    avatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AvatarRequestMessage.avatarHash)
}

// -------------------------------------------------------------------

// AvatarHeaderMessage

// required uint32 requestId = 1;
inline bool AvatarHeaderMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarHeaderMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarHeaderMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarHeaderMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 AvatarHeaderMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarHeaderMessage.requestId)
  return requestid_;
}
inline void AvatarHeaderMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:AvatarHeaderMessage.requestId)
}

// required .NetAvatarType avatarType = 2;
inline bool AvatarHeaderMessage::has_avatartype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarHeaderMessage::set_has_avatartype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AvatarHeaderMessage::clear_has_avatartype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AvatarHeaderMessage::clear_avatartype() {
  avatartype_ = 1;
  clear_has_avatartype();
}
inline ::NetAvatarType AvatarHeaderMessage::avatartype() const {
  // @@protoc_insertion_point(field_get:AvatarHeaderMessage.avatarType)
  return static_cast< ::NetAvatarType >(avatartype_);
}
inline void AvatarHeaderMessage::set_avatartype(::NetAvatarType value) {
  assert(::NetAvatarType_IsValid(value));
  set_has_avatartype();
  avatartype_ = value;
  // @@protoc_insertion_point(field_set:AvatarHeaderMessage.avatarType)
}

// required uint32 avatarSize = 3;
inline bool AvatarHeaderMessage::has_avatarsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AvatarHeaderMessage::set_has_avatarsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AvatarHeaderMessage::clear_has_avatarsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AvatarHeaderMessage::clear_avatarsize() {
  avatarsize_ = 0u;
  clear_has_avatarsize();
}
inline ::google::protobuf::uint32 AvatarHeaderMessage::avatarsize() const {
  // @@protoc_insertion_point(field_get:AvatarHeaderMessage.avatarSize)
  return avatarsize_;
}
inline void AvatarHeaderMessage::set_avatarsize(::google::protobuf::uint32 value) {
  set_has_avatarsize();
  avatarsize_ = value;
  // @@protoc_insertion_point(field_set:AvatarHeaderMessage.avatarSize)
}

// -------------------------------------------------------------------

// AvatarDataMessage

// required uint32 requestId = 1;
inline bool AvatarDataMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarDataMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarDataMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarDataMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 AvatarDataMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarDataMessage.requestId)
  return requestid_;
}
inline void AvatarDataMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:AvatarDataMessage.requestId)
}

// required bytes avatarBlock = 2;
inline bool AvatarDataMessage::has_avatarblock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarDataMessage::set_has_avatarblock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AvatarDataMessage::clear_has_avatarblock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AvatarDataMessage::clear_avatarblock() {
  if (avatarblock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarblock_->clear();
  }
  clear_has_avatarblock();
}
inline const ::std::string& AvatarDataMessage::avatarblock() const {
  // @@protoc_insertion_point(field_get:AvatarDataMessage.avatarBlock)
  return *avatarblock_;
}
inline void AvatarDataMessage::set_avatarblock(const ::std::string& value) {
  set_has_avatarblock();
  if (avatarblock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarblock_ = new ::std::string;
  }
  avatarblock_->assign(value);
  // @@protoc_insertion_point(field_set:AvatarDataMessage.avatarBlock)
}
inline void AvatarDataMessage::set_avatarblock(const char* value) {
  set_has_avatarblock();
  if (avatarblock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarblock_ = new ::std::string;
  }
  avatarblock_->assign(value);
  // @@protoc_insertion_point(field_set_char:AvatarDataMessage.avatarBlock)
}
inline void AvatarDataMessage::set_avatarblock(const void* value, size_t size) {
  set_has_avatarblock();
  if (avatarblock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarblock_ = new ::std::string;
  }
  avatarblock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AvatarDataMessage.avatarBlock)
}
inline ::std::string* AvatarDataMessage::mutable_avatarblock() {
  set_has_avatarblock();
  if (avatarblock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarblock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AvatarDataMessage.avatarBlock)
  return avatarblock_;
}
inline ::std::string* AvatarDataMessage::release_avatarblock() {
  clear_has_avatarblock();
  if (avatarblock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatarblock_;
    avatarblock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AvatarDataMessage::set_allocated_avatarblock(::std::string* avatarblock) {
  if (avatarblock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatarblock_;
  }
  if (avatarblock) {
    set_has_avatarblock();
    avatarblock_ = avatarblock;
  } else {
    clear_has_avatarblock();
    avatarblock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AvatarDataMessage.avatarBlock)
}

// -------------------------------------------------------------------

// AvatarEndMessage

// required uint32 requestId = 1;
inline bool AvatarEndMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarEndMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarEndMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarEndMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 AvatarEndMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarEndMessage.requestId)
  return requestid_;
}
inline void AvatarEndMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:AvatarEndMessage.requestId)
}

// -------------------------------------------------------------------

// UnknownAvatarMessage

// required uint32 requestId = 1;
inline bool UnknownAvatarMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnknownAvatarMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnknownAvatarMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnknownAvatarMessage::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 UnknownAvatarMessage::requestid() const {
  // @@protoc_insertion_point(field_get:UnknownAvatarMessage.requestId)
  return requestid_;
}
inline void UnknownAvatarMessage::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:UnknownAvatarMessage.requestId)
}

// -------------------------------------------------------------------

// PlayerListMessage

// required uint32 playerId = 1;
inline bool PlayerListMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerListMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerListMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerListMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayerListMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerListMessage.playerId)
  return playerid_;
}
inline void PlayerListMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerListMessage.playerId)
}

// required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
inline bool PlayerListMessage::has_playerlistnotification() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerListMessage::set_has_playerlistnotification() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerListMessage::clear_has_playerlistnotification() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerListMessage::clear_playerlistnotification() {
  playerlistnotification_ = 0;
  clear_has_playerlistnotification();
}
inline ::PlayerListMessage_PlayerListNotification PlayerListMessage::playerlistnotification() const {
  // @@protoc_insertion_point(field_get:PlayerListMessage.playerListNotification)
  return static_cast< ::PlayerListMessage_PlayerListNotification >(playerlistnotification_);
}
inline void PlayerListMessage::set_playerlistnotification(::PlayerListMessage_PlayerListNotification value) {
  assert(::PlayerListMessage_PlayerListNotification_IsValid(value));
  set_has_playerlistnotification();
  playerlistnotification_ = value;
  // @@protoc_insertion_point(field_set:PlayerListMessage.playerListNotification)
}

// -------------------------------------------------------------------

// GameListNewMessage

// required uint32 gameId = 1;
inline bool GameListNewMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListNewMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListNewMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListNewMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListNewMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.gameId)
  return gameid_;
}
inline void GameListNewMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListNewMessage.gameId)
}

// required .NetGameMode gameMode = 2;
inline bool GameListNewMessage::has_gamemode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListNewMessage::set_has_gamemode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListNewMessage::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListNewMessage::clear_gamemode() {
  gamemode_ = 1;
  clear_has_gamemode();
}
inline ::NetGameMode GameListNewMessage::gamemode() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.gameMode)
  return static_cast< ::NetGameMode >(gamemode_);
}
inline void GameListNewMessage::set_gamemode(::NetGameMode value) {
  assert(::NetGameMode_IsValid(value));
  set_has_gamemode();
  gamemode_ = value;
  // @@protoc_insertion_point(field_set:GameListNewMessage.gameMode)
}

// required bool isPrivate = 3;
inline bool GameListNewMessage::has_isprivate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameListNewMessage::set_has_isprivate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameListNewMessage::clear_has_isprivate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameListNewMessage::clear_isprivate() {
  isprivate_ = false;
  clear_has_isprivate();
}
inline bool GameListNewMessage::isprivate() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.isPrivate)
  return isprivate_;
}
inline void GameListNewMessage::set_isprivate(bool value) {
  set_has_isprivate();
  isprivate_ = value;
  // @@protoc_insertion_point(field_set:GameListNewMessage.isPrivate)
}

// repeated uint32 playerIds = 4 [packed = true];
inline int GameListNewMessage::playerids_size() const {
  return playerids_.size();
}
inline void GameListNewMessage::clear_playerids() {
  playerids_.Clear();
}
inline ::google::protobuf::uint32 GameListNewMessage::playerids(int index) const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.playerIds)
  return playerids_.Get(index);
}
inline void GameListNewMessage::set_playerids(int index, ::google::protobuf::uint32 value) {
  playerids_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameListNewMessage.playerIds)
}
inline void GameListNewMessage::add_playerids(::google::protobuf::uint32 value) {
  playerids_.Add(value);
  // @@protoc_insertion_point(field_add:GameListNewMessage.playerIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameListNewMessage::playerids() const {
  // @@protoc_insertion_point(field_list:GameListNewMessage.playerIds)
  return playerids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameListNewMessage::mutable_playerids() {
  // @@protoc_insertion_point(field_mutable_list:GameListNewMessage.playerIds)
  return &playerids_;
}

// required uint32 adminPlayerId = 5;
inline bool GameListNewMessage::has_adminplayerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameListNewMessage::set_has_adminplayerid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameListNewMessage::clear_has_adminplayerid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameListNewMessage::clear_adminplayerid() {
  adminplayerid_ = 0u;
  clear_has_adminplayerid();
}
inline ::google::protobuf::uint32 GameListNewMessage::adminplayerid() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.adminPlayerId)
  return adminplayerid_;
}
inline void GameListNewMessage::set_adminplayerid(::google::protobuf::uint32 value) {
  set_has_adminplayerid();
  adminplayerid_ = value;
  // @@protoc_insertion_point(field_set:GameListNewMessage.adminPlayerId)
}

// required .NetGameInfo gameInfo = 6;
inline bool GameListNewMessage::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameListNewMessage::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameListNewMessage::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameListNewMessage::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::NetGameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::NetGameInfo& GameListNewMessage::gameinfo() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.gameInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance().gameinfo_;
#else
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
#endif
}
inline ::NetGameInfo* GameListNewMessage::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::NetGameInfo;
  // @@protoc_insertion_point(field_mutable:GameListNewMessage.gameInfo)
  return gameinfo_;
}
inline ::NetGameInfo* GameListNewMessage::release_gameinfo() {
  clear_has_gameinfo();
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}
inline void GameListNewMessage::set_allocated_gameinfo(::NetGameInfo* gameinfo) {
  delete gameinfo_;
  gameinfo_ = gameinfo;
  if (gameinfo) {
    set_has_gameinfo();
  } else {
    clear_has_gameinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:GameListNewMessage.gameInfo)
}

// repeated uint32 spectatorIds = 7 [packed = true];
inline int GameListNewMessage::spectatorids_size() const {
  return spectatorids_.size();
}
inline void GameListNewMessage::clear_spectatorids() {
  spectatorids_.Clear();
}
inline ::google::protobuf::uint32 GameListNewMessage::spectatorids(int index) const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.spectatorIds)
  return spectatorids_.Get(index);
}
inline void GameListNewMessage::set_spectatorids(int index, ::google::protobuf::uint32 value) {
  spectatorids_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameListNewMessage.spectatorIds)
}
inline void GameListNewMessage::add_spectatorids(::google::protobuf::uint32 value) {
  spectatorids_.Add(value);
  // @@protoc_insertion_point(field_add:GameListNewMessage.spectatorIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameListNewMessage::spectatorids() const {
  // @@protoc_insertion_point(field_list:GameListNewMessage.spectatorIds)
  return spectatorids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameListNewMessage::mutable_spectatorids() {
  // @@protoc_insertion_point(field_mutable_list:GameListNewMessage.spectatorIds)
  return &spectatorids_;
}

// -------------------------------------------------------------------

// GameListUpdateMessage

// required uint32 gameId = 1;
inline bool GameListUpdateMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListUpdateMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListUpdateMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListUpdateMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListUpdateMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListUpdateMessage.gameId)
  return gameid_;
}
inline void GameListUpdateMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListUpdateMessage.gameId)
}

// required .NetGameMode gameMode = 2;
inline bool GameListUpdateMessage::has_gamemode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListUpdateMessage::set_has_gamemode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListUpdateMessage::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListUpdateMessage::clear_gamemode() {
  gamemode_ = 1;
  clear_has_gamemode();
}
inline ::NetGameMode GameListUpdateMessage::gamemode() const {
  // @@protoc_insertion_point(field_get:GameListUpdateMessage.gameMode)
  return static_cast< ::NetGameMode >(gamemode_);
}
inline void GameListUpdateMessage::set_gamemode(::NetGameMode value) {
  assert(::NetGameMode_IsValid(value));
  set_has_gamemode();
  gamemode_ = value;
  // @@protoc_insertion_point(field_set:GameListUpdateMessage.gameMode)
}

// -------------------------------------------------------------------

// GameListPlayerJoinedMessage

// required uint32 gameId = 1;
inline bool GameListPlayerJoinedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListPlayerJoinedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListPlayerJoinedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListPlayerJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListPlayerJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerJoinedMessage.gameId)
  return gameid_;
}
inline void GameListPlayerJoinedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListPlayerJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListPlayerJoinedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListPlayerJoinedMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListPlayerJoinedMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListPlayerJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GameListPlayerJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerJoinedMessage.playerId)
  return playerid_;
}
inline void GameListPlayerJoinedMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameListPlayerJoinedMessage.playerId)
}

// -------------------------------------------------------------------

// GameListPlayerLeftMessage

// required uint32 gameId = 1;
inline bool GameListPlayerLeftMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListPlayerLeftMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListPlayerLeftMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListPlayerLeftMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListPlayerLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerLeftMessage.gameId)
  return gameid_;
}
inline void GameListPlayerLeftMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListPlayerLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListPlayerLeftMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListPlayerLeftMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListPlayerLeftMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListPlayerLeftMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GameListPlayerLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerLeftMessage.playerId)
  return playerid_;
}
inline void GameListPlayerLeftMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameListPlayerLeftMessage.playerId)
}

// -------------------------------------------------------------------

// GameListSpectatorJoinedMessage

// required uint32 gameId = 1;
inline bool GameListSpectatorJoinedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListSpectatorJoinedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListSpectatorJoinedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListSpectatorJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListSpectatorJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorJoinedMessage.gameId)
  return gameid_;
}
inline void GameListSpectatorJoinedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListSpectatorJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListSpectatorJoinedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListSpectatorJoinedMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListSpectatorJoinedMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListSpectatorJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GameListSpectatorJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorJoinedMessage.playerId)
  return playerid_;
}
inline void GameListSpectatorJoinedMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameListSpectatorJoinedMessage.playerId)
}

// -------------------------------------------------------------------

// GameListSpectatorLeftMessage

// required uint32 gameId = 1;
inline bool GameListSpectatorLeftMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListSpectatorLeftMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListSpectatorLeftMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListSpectatorLeftMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListSpectatorLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorLeftMessage.gameId)
  return gameid_;
}
inline void GameListSpectatorLeftMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListSpectatorLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListSpectatorLeftMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListSpectatorLeftMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListSpectatorLeftMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListSpectatorLeftMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GameListSpectatorLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorLeftMessage.playerId)
  return playerid_;
}
inline void GameListSpectatorLeftMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameListSpectatorLeftMessage.playerId)
}

// -------------------------------------------------------------------

// GameListAdminChangedMessage

// required uint32 gameId = 1;
inline bool GameListAdminChangedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListAdminChangedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameListAdminChangedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameListAdminChangedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameListAdminChangedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListAdminChangedMessage.gameId)
  return gameid_;
}
inline void GameListAdminChangedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListAdminChangedMessage.gameId)
}

// required uint32 newAdminPlayerId = 2;
inline bool GameListAdminChangedMessage::has_newadminplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListAdminChangedMessage::set_has_newadminplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameListAdminChangedMessage::clear_has_newadminplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameListAdminChangedMessage::clear_newadminplayerid() {
  newadminplayerid_ = 0u;
  clear_has_newadminplayerid();
}
inline ::google::protobuf::uint32 GameListAdminChangedMessage::newadminplayerid() const {
  // @@protoc_insertion_point(field_get:GameListAdminChangedMessage.newAdminPlayerId)
  return newadminplayerid_;
}
inline void GameListAdminChangedMessage::set_newadminplayerid(::google::protobuf::uint32 value) {
  set_has_newadminplayerid();
  newadminplayerid_ = value;
  // @@protoc_insertion_point(field_set:GameListAdminChangedMessage.newAdminPlayerId)
}

// -------------------------------------------------------------------

// PlayerInfoRequestMessage

// repeated uint32 playerId = 1 [packed = true];
inline int PlayerInfoRequestMessage::playerid_size() const {
  return playerid_.size();
}
inline void PlayerInfoRequestMessage::clear_playerid() {
  playerid_.Clear();
}
inline ::google::protobuf::uint32 PlayerInfoRequestMessage::playerid(int index) const {
  // @@protoc_insertion_point(field_get:PlayerInfoRequestMessage.playerId)
  return playerid_.Get(index);
}
inline void PlayerInfoRequestMessage::set_playerid(int index, ::google::protobuf::uint32 value) {
  playerid_.Set(index, value);
  // @@protoc_insertion_point(field_set:PlayerInfoRequestMessage.playerId)
}
inline void PlayerInfoRequestMessage::add_playerid(::google::protobuf::uint32 value) {
  playerid_.Add(value);
  // @@protoc_insertion_point(field_add:PlayerInfoRequestMessage.playerId)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PlayerInfoRequestMessage::playerid() const {
  // @@protoc_insertion_point(field_list:PlayerInfoRequestMessage.playerId)
  return playerid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PlayerInfoRequestMessage::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable_list:PlayerInfoRequestMessage.playerId)
  return &playerid_;
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage_PlayerInfoData_AvatarData

// required .NetAvatarType avatarType = 1;
inline bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::has_avatartype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_has_avatartype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_has_avatartype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_avatartype() {
  avatartype_ = 1;
  clear_has_avatartype();
}
inline ::NetAvatarType PlayerInfoReplyMessage_PlayerInfoData_AvatarData::avatartype() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarType)
  return static_cast< ::NetAvatarType >(avatartype_);
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatartype(::NetAvatarType value) {
  assert(::NetAvatarType_IsValid(value));
  set_has_avatartype();
  avatartype_ = value;
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarType)
}

// required bytes avatarHash = 2;
inline bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::has_avatarhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_has_avatarhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_has_avatarhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_avatarhash() {
  if (avatarhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_->clear();
  }
  clear_has_avatarhash();
}
inline const ::std::string& PlayerInfoReplyMessage_PlayerInfoData_AvatarData::avatarhash() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
  return *avatarhash_;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(const ::std::string& value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(const char* value) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(value);
  // @@protoc_insertion_point(field_set_char:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(const void* value, size_t size) {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  avatarhash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::mutable_avatarhash() {
  set_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatarhash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
  return avatarhash_;
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::release_avatarhash() {
  clear_has_avatarhash();
  if (avatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatarhash_;
    avatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_allocated_avatarhash(::std::string* avatarhash) {
  if (avatarhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatarhash_;
  }
  if (avatarhash) {
    set_has_avatarhash();
    avatarhash_ = avatarhash;
  } else {
    clear_has_avatarhash();
    avatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage_PlayerInfoData

// required string playerName = 1;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_playername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_has_playername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_has_playername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_playername() {
  if (playername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_->clear();
  }
  clear_has_playername();
}
inline const ::std::string& PlayerInfoReplyMessage_PlayerInfoData::playername() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.playerName)
  return *playername_;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playername(const ::std::string& value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playername(const char* value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
  // @@protoc_insertion_point(field_set_char:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playername(const char* value, size_t size) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::mutable_playername() {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    playername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.playerName)
  return playername_;
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::release_playername() {
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_allocated_playername(::std::string* playername) {
  if (playername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete playername_;
  }
  if (playername) {
    set_has_playername();
    playername_ = playername;
  } else {
    clear_has_playername();
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}

// required bool isHuman = 2;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_ishuman() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_has_ishuman() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_has_ishuman() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_ishuman() {
  ishuman_ = false;
  clear_has_ishuman();
}
inline bool PlayerInfoReplyMessage_PlayerInfoData::ishuman() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.isHuman)
  return ishuman_;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_ishuman(bool value) {
  set_has_ishuman();
  ishuman_ = value;
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.isHuman)
}

// required .NetPlayerInfoRights playerRights = 3;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_playerrights() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_has_playerrights() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_has_playerrights() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_playerrights() {
  playerrights_ = 1;
  clear_has_playerrights();
}
inline ::NetPlayerInfoRights PlayerInfoReplyMessage_PlayerInfoData::playerrights() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.playerRights)
  return static_cast< ::NetPlayerInfoRights >(playerrights_);
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playerrights(::NetPlayerInfoRights value) {
  assert(::NetPlayerInfoRights_IsValid(value));
  set_has_playerrights();
  playerrights_ = value;
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.playerRights)
}

// optional string countryCode = 4;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_countrycode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_has_countrycode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_has_countrycode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_countrycode() {
  if (countrycode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countrycode_->clear();
  }
  clear_has_countrycode();
}
inline const ::std::string& PlayerInfoReplyMessage_PlayerInfoData::countrycode() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
  return *countrycode_;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(const ::std::string& value) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(value);
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(const char* value) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(value);
  // @@protoc_insertion_point(field_set_char:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(const char* value, size_t size) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::mutable_countrycode() {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countrycode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
  return countrycode_;
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::release_countrycode() {
  clear_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = countrycode_;
    countrycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_allocated_countrycode(::std::string* countrycode) {
  if (countrycode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete countrycode_;
  }
  if (countrycode) {
    set_has_countrycode();
    countrycode_ = countrycode;
  } else {
    clear_has_countrycode();
    countrycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}

// optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_avatardata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_has_avatardata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_has_avatardata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_avatardata() {
  if (avatardata_ != NULL) avatardata_->::PlayerInfoReplyMessage_PlayerInfoData_AvatarData::Clear();
  clear_has_avatardata();
}
inline const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& PlayerInfoReplyMessage_PlayerInfoData::avatardata() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return avatardata_ != NULL ? *avatardata_ : *default_instance().avatardata_;
#else
  return avatardata_ != NULL ? *avatardata_ : *default_instance_->avatardata_;
#endif
}
inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* PlayerInfoReplyMessage_PlayerInfoData::mutable_avatardata() {
  set_has_avatardata();
  if (avatardata_ == NULL) avatardata_ = new ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData;
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
  return avatardata_;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* PlayerInfoReplyMessage_PlayerInfoData::release_avatardata() {
  clear_has_avatardata();
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* temp = avatardata_;
  avatardata_ = NULL;
  return temp;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_allocated_avatardata(::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata) {
  delete avatardata_;
  avatardata_ = avatardata;
  if (avatardata) {
    set_has_avatardata();
  } else {
    clear_has_avatardata();
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage

// required uint32 playerId = 1;
inline bool PlayerInfoReplyMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoReplyMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfoReplyMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfoReplyMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayerInfoReplyMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.playerId)
  return playerid_;
}
inline void PlayerInfoReplyMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.playerId)
}

// optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
inline bool PlayerInfoReplyMessage::has_playerinfodata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoReplyMessage::set_has_playerinfodata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfoReplyMessage::clear_has_playerinfodata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfoReplyMessage::clear_playerinfodata() {
  if (playerinfodata_ != NULL) playerinfodata_->::PlayerInfoReplyMessage_PlayerInfoData::Clear();
  clear_has_playerinfodata();
}
inline const ::PlayerInfoReplyMessage_PlayerInfoData& PlayerInfoReplyMessage::playerinfodata() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.playerInfoData)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerinfodata_ != NULL ? *playerinfodata_ : *default_instance().playerinfodata_;
#else
  return playerinfodata_ != NULL ? *playerinfodata_ : *default_instance_->playerinfodata_;
#endif
}
inline ::PlayerInfoReplyMessage_PlayerInfoData* PlayerInfoReplyMessage::mutable_playerinfodata() {
  set_has_playerinfodata();
  if (playerinfodata_ == NULL) playerinfodata_ = new ::PlayerInfoReplyMessage_PlayerInfoData;
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.playerInfoData)
  return playerinfodata_;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData* PlayerInfoReplyMessage::release_playerinfodata() {
  clear_has_playerinfodata();
  ::PlayerInfoReplyMessage_PlayerInfoData* temp = playerinfodata_;
  playerinfodata_ = NULL;
  return temp;
}
inline void PlayerInfoReplyMessage::set_allocated_playerinfodata(::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata) {
  delete playerinfodata_;
  playerinfodata_ = playerinfodata;
  if (playerinfodata) {
    set_has_playerinfodata();
  } else {
    clear_has_playerinfodata();
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.playerInfoData)
}

// -------------------------------------------------------------------

// SubscriptionRequestMessage

// required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
inline bool SubscriptionRequestMessage::has_subscriptionaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscriptionRequestMessage::set_has_subscriptionaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscriptionRequestMessage::clear_has_subscriptionaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscriptionRequestMessage::clear_subscriptionaction() {
  subscriptionaction_ = 1;
  clear_has_subscriptionaction();
}
inline ::SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage::subscriptionaction() const {
  // @@protoc_insertion_point(field_get:SubscriptionRequestMessage.subscriptionAction)
  return static_cast< ::SubscriptionRequestMessage_SubscriptionAction >(subscriptionaction_);
}
inline void SubscriptionRequestMessage::set_subscriptionaction(::SubscriptionRequestMessage_SubscriptionAction value) {
  assert(::SubscriptionRequestMessage_SubscriptionAction_IsValid(value));
  set_has_subscriptionaction();
  subscriptionaction_ = value;
  // @@protoc_insertion_point(field_set:SubscriptionRequestMessage.subscriptionAction)
}

// -------------------------------------------------------------------

// JoinExistingGameMessage

// required uint32 gameId = 1;
inline bool JoinExistingGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinExistingGameMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinExistingGameMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinExistingGameMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 JoinExistingGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.gameId)
  return gameid_;
}
inline void JoinExistingGameMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.gameId)
}

// optional string password = 2;
inline bool JoinExistingGameMessage::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinExistingGameMessage::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinExistingGameMessage::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinExistingGameMessage::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& JoinExistingGameMessage::password() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.password)
  return *password_;
}
inline void JoinExistingGameMessage::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.password)
}
inline void JoinExistingGameMessage::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:JoinExistingGameMessage.password)
}
inline void JoinExistingGameMessage::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JoinExistingGameMessage.password)
}
inline ::std::string* JoinExistingGameMessage::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:JoinExistingGameMessage.password)
  return password_;
}
inline ::std::string* JoinExistingGameMessage::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JoinExistingGameMessage::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:JoinExistingGameMessage.password)
}

// optional bool autoLeave = 3 [default = false];
inline bool JoinExistingGameMessage::has_autoleave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinExistingGameMessage::set_has_autoleave() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinExistingGameMessage::clear_has_autoleave() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinExistingGameMessage::clear_autoleave() {
  autoleave_ = false;
  clear_has_autoleave();
}
inline bool JoinExistingGameMessage::autoleave() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.autoLeave)
  return autoleave_;
}
inline void JoinExistingGameMessage::set_autoleave(bool value) {
  set_has_autoleave();
  autoleave_ = value;
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.autoLeave)
}

// optional bool spectateOnly = 4 [default = false];
inline bool JoinExistingGameMessage::has_spectateonly() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinExistingGameMessage::set_has_spectateonly() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JoinExistingGameMessage::clear_has_spectateonly() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JoinExistingGameMessage::clear_spectateonly() {
  spectateonly_ = false;
  clear_has_spectateonly();
}
inline bool JoinExistingGameMessage::spectateonly() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.spectateOnly)
  return spectateonly_;
}
inline void JoinExistingGameMessage::set_spectateonly(bool value) {
  set_has_spectateonly();
  spectateonly_ = value;
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.spectateOnly)
}

// -------------------------------------------------------------------

// JoinNewGameMessage

// required .NetGameInfo gameInfo = 1;
inline bool JoinNewGameMessage::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinNewGameMessage::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinNewGameMessage::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinNewGameMessage::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::NetGameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::NetGameInfo& JoinNewGameMessage::gameinfo() const {
  // @@protoc_insertion_point(field_get:JoinNewGameMessage.gameInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance().gameinfo_;
#else
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
#endif
}
inline ::NetGameInfo* JoinNewGameMessage::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::NetGameInfo;
  // @@protoc_insertion_point(field_mutable:JoinNewGameMessage.gameInfo)
  return gameinfo_;
}
inline ::NetGameInfo* JoinNewGameMessage::release_gameinfo() {
  clear_has_gameinfo();
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}
inline void JoinNewGameMessage::set_allocated_gameinfo(::NetGameInfo* gameinfo) {
  delete gameinfo_;
  gameinfo_ = gameinfo;
  if (gameinfo) {
    set_has_gameinfo();
  } else {
    clear_has_gameinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:JoinNewGameMessage.gameInfo)
}

// optional string password = 2;
inline bool JoinNewGameMessage::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinNewGameMessage::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinNewGameMessage::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinNewGameMessage::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& JoinNewGameMessage::password() const {
  // @@protoc_insertion_point(field_get:JoinNewGameMessage.password)
  return *password_;
}
inline void JoinNewGameMessage::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:JoinNewGameMessage.password)
}
inline void JoinNewGameMessage::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:JoinNewGameMessage.password)
}
inline void JoinNewGameMessage::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JoinNewGameMessage.password)
}
inline ::std::string* JoinNewGameMessage::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:JoinNewGameMessage.password)
  return password_;
}
inline ::std::string* JoinNewGameMessage::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JoinNewGameMessage::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:JoinNewGameMessage.password)
}

// optional bool autoLeave = 3;
inline bool JoinNewGameMessage::has_autoleave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinNewGameMessage::set_has_autoleave() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinNewGameMessage::clear_has_autoleave() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinNewGameMessage::clear_autoleave() {
  autoleave_ = false;
  clear_has_autoleave();
}
inline bool JoinNewGameMessage::autoleave() const {
  // @@protoc_insertion_point(field_get:JoinNewGameMessage.autoLeave)
  return autoleave_;
}
inline void JoinNewGameMessage::set_autoleave(bool value) {
  set_has_autoleave();
  autoleave_ = value;
  // @@protoc_insertion_point(field_set:JoinNewGameMessage.autoLeave)
}

// -------------------------------------------------------------------

// RejoinExistingGameMessage

// required uint32 gameId = 1;
inline bool RejoinExistingGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejoinExistingGameMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejoinExistingGameMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejoinExistingGameMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 RejoinExistingGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RejoinExistingGameMessage.gameId)
  return gameid_;
}
inline void RejoinExistingGameMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:RejoinExistingGameMessage.gameId)
}

// optional bool autoLeave = 2;
inline bool RejoinExistingGameMessage::has_autoleave() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejoinExistingGameMessage::set_has_autoleave() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejoinExistingGameMessage::clear_has_autoleave() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejoinExistingGameMessage::clear_autoleave() {
  autoleave_ = false;
  clear_has_autoleave();
}
inline bool RejoinExistingGameMessage::autoleave() const {
  // @@protoc_insertion_point(field_get:RejoinExistingGameMessage.autoLeave)
  return autoleave_;
}
inline void RejoinExistingGameMessage::set_autoleave(bool value) {
  set_has_autoleave();
  autoleave_ = value;
  // @@protoc_insertion_point(field_set:RejoinExistingGameMessage.autoLeave)
}

// -------------------------------------------------------------------

// JoinGameAckMessage

// required uint32 gameId = 1;
inline bool JoinGameAckMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGameAckMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGameAckMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGameAckMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 JoinGameAckMessage::gameid() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.gameId)
  return gameid_;
}
inline void JoinGameAckMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:JoinGameAckMessage.gameId)
}

// required bool areYouGameAdmin = 2;
inline bool JoinGameAckMessage::has_areyougameadmin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinGameAckMessage::set_has_areyougameadmin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinGameAckMessage::clear_has_areyougameadmin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinGameAckMessage::clear_areyougameadmin() {
  areyougameadmin_ = false;
  clear_has_areyougameadmin();
}
inline bool JoinGameAckMessage::areyougameadmin() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.areYouGameAdmin)
  return areyougameadmin_;
}
inline void JoinGameAckMessage::set_areyougameadmin(bool value) {
  set_has_areyougameadmin();
  areyougameadmin_ = value;
  // @@protoc_insertion_point(field_set:JoinGameAckMessage.areYouGameAdmin)
}

// required .NetGameInfo gameInfo = 3;
inline bool JoinGameAckMessage::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinGameAckMessage::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinGameAckMessage::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinGameAckMessage::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::NetGameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::NetGameInfo& JoinGameAckMessage::gameinfo() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.gameInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance().gameinfo_;
#else
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
#endif
}
inline ::NetGameInfo* JoinGameAckMessage::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::NetGameInfo;
  // @@protoc_insertion_point(field_mutable:JoinGameAckMessage.gameInfo)
  return gameinfo_;
}
inline ::NetGameInfo* JoinGameAckMessage::release_gameinfo() {
  clear_has_gameinfo();
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}
inline void JoinGameAckMessage::set_allocated_gameinfo(::NetGameInfo* gameinfo) {
  delete gameinfo_;
  gameinfo_ = gameinfo;
  if (gameinfo) {
    set_has_gameinfo();
  } else {
    clear_has_gameinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:JoinGameAckMessage.gameInfo)
}

// optional bool spectateOnly = 4;
inline bool JoinGameAckMessage::has_spectateonly() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinGameAckMessage::set_has_spectateonly() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JoinGameAckMessage::clear_has_spectateonly() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JoinGameAckMessage::clear_spectateonly() {
  spectateonly_ = false;
  clear_has_spectateonly();
}
inline bool JoinGameAckMessage::spectateonly() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.spectateOnly)
  return spectateonly_;
}
inline void JoinGameAckMessage::set_spectateonly(bool value) {
  set_has_spectateonly();
  spectateonly_ = value;
  // @@protoc_insertion_point(field_set:JoinGameAckMessage.spectateOnly)
}

// -------------------------------------------------------------------

// JoinGameFailedMessage

// required uint32 gameId = 1;
inline bool JoinGameFailedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGameFailedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGameFailedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGameFailedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 JoinGameFailedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:JoinGameFailedMessage.gameId)
  return gameid_;
}
inline void JoinGameFailedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:JoinGameFailedMessage.gameId)
}

// required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
inline bool JoinGameFailedMessage::has_joingamefailurereason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinGameFailedMessage::set_has_joingamefailurereason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinGameFailedMessage::clear_has_joingamefailurereason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinGameFailedMessage::clear_joingamefailurereason() {
  joingamefailurereason_ = 1;
  clear_has_joingamefailurereason();
}
inline ::JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::joingamefailurereason() const {
  // @@protoc_insertion_point(field_get:JoinGameFailedMessage.joinGameFailureReason)
  return static_cast< ::JoinGameFailedMessage_JoinGameFailureReason >(joingamefailurereason_);
}
inline void JoinGameFailedMessage::set_joingamefailurereason(::JoinGameFailedMessage_JoinGameFailureReason value) {
  assert(::JoinGameFailedMessage_JoinGameFailureReason_IsValid(value));
  set_has_joingamefailurereason();
  joingamefailurereason_ = value;
  // @@protoc_insertion_point(field_set:JoinGameFailedMessage.joinGameFailureReason)
}

// -------------------------------------------------------------------

// GamePlayerJoinedMessage

// required uint32 gameId = 1;
inline bool GamePlayerJoinedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePlayerJoinedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamePlayerJoinedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamePlayerJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GamePlayerJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GamePlayerJoinedMessage.gameId)
  return gameid_;
}
inline void GamePlayerJoinedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GamePlayerJoinedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePlayerJoinedMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamePlayerJoinedMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamePlayerJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GamePlayerJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GamePlayerJoinedMessage.playerId)
  return playerid_;
}
inline void GamePlayerJoinedMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerJoinedMessage.playerId)
}

// required bool isGameAdmin = 3;
inline bool GamePlayerJoinedMessage::has_isgameadmin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePlayerJoinedMessage::set_has_isgameadmin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GamePlayerJoinedMessage::clear_has_isgameadmin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GamePlayerJoinedMessage::clear_isgameadmin() {
  isgameadmin_ = false;
  clear_has_isgameadmin();
}
inline bool GamePlayerJoinedMessage::isgameadmin() const {
  // @@protoc_insertion_point(field_get:GamePlayerJoinedMessage.isGameAdmin)
  return isgameadmin_;
}
inline void GamePlayerJoinedMessage::set_isgameadmin(bool value) {
  set_has_isgameadmin();
  isgameadmin_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerJoinedMessage.isGameAdmin)
}

// -------------------------------------------------------------------

// GamePlayerLeftMessage

// required uint32 gameId = 1;
inline bool GamePlayerLeftMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePlayerLeftMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamePlayerLeftMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamePlayerLeftMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GamePlayerLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GamePlayerLeftMessage.gameId)
  return gameid_;
}
inline void GamePlayerLeftMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GamePlayerLeftMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePlayerLeftMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamePlayerLeftMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamePlayerLeftMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GamePlayerLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GamePlayerLeftMessage.playerId)
  return playerid_;
}
inline void GamePlayerLeftMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerLeftMessage.playerId)
}

// required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
inline bool GamePlayerLeftMessage::has_gameplayerleftreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePlayerLeftMessage::set_has_gameplayerleftreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GamePlayerLeftMessage::clear_has_gameplayerleftreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GamePlayerLeftMessage::clear_gameplayerleftreason() {
  gameplayerleftreason_ = 0;
  clear_has_gameplayerleftreason();
}
inline ::GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage::gameplayerleftreason() const {
  // @@protoc_insertion_point(field_get:GamePlayerLeftMessage.gamePlayerLeftReason)
  return static_cast< ::GamePlayerLeftMessage_GamePlayerLeftReason >(gameplayerleftreason_);
}
inline void GamePlayerLeftMessage::set_gameplayerleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value) {
  assert(::GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value));
  set_has_gameplayerleftreason();
  gameplayerleftreason_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerLeftMessage.gamePlayerLeftReason)
}

// -------------------------------------------------------------------

// GameSpectatorJoinedMessage

// required uint32 gameId = 1;
inline bool GameSpectatorJoinedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSpectatorJoinedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameSpectatorJoinedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameSpectatorJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameSpectatorJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorJoinedMessage.gameId)
  return gameid_;
}
inline void GameSpectatorJoinedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameSpectatorJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameSpectatorJoinedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameSpectatorJoinedMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameSpectatorJoinedMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameSpectatorJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GameSpectatorJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorJoinedMessage.playerId)
  return playerid_;
}
inline void GameSpectatorJoinedMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameSpectatorJoinedMessage.playerId)
}

// -------------------------------------------------------------------

// GameSpectatorLeftMessage

// required uint32 gameId = 1;
inline bool GameSpectatorLeftMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSpectatorLeftMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameSpectatorLeftMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameSpectatorLeftMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameSpectatorLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorLeftMessage.gameId)
  return gameid_;
}
inline void GameSpectatorLeftMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameSpectatorLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameSpectatorLeftMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameSpectatorLeftMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameSpectatorLeftMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameSpectatorLeftMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GameSpectatorLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorLeftMessage.playerId)
  return playerid_;
}
inline void GameSpectatorLeftMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameSpectatorLeftMessage.playerId)
}

// required .GamePlayerLeftMessage.GamePlayerLeftReason gameSpectatorLeftReason = 3;
inline bool GameSpectatorLeftMessage::has_gamespectatorleftreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameSpectatorLeftMessage::set_has_gamespectatorleftreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameSpectatorLeftMessage::clear_has_gamespectatorleftreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameSpectatorLeftMessage::clear_gamespectatorleftreason() {
  gamespectatorleftreason_ = 0;
  clear_has_gamespectatorleftreason();
}
inline ::GamePlayerLeftMessage_GamePlayerLeftReason GameSpectatorLeftMessage::gamespectatorleftreason() const {
  // @@protoc_insertion_point(field_get:GameSpectatorLeftMessage.gameSpectatorLeftReason)
  return static_cast< ::GamePlayerLeftMessage_GamePlayerLeftReason >(gamespectatorleftreason_);
}
inline void GameSpectatorLeftMessage::set_gamespectatorleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value) {
  assert(::GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value));
  set_has_gamespectatorleftreason();
  gamespectatorleftreason_ = value;
  // @@protoc_insertion_point(field_set:GameSpectatorLeftMessage.gameSpectatorLeftReason)
}

// -------------------------------------------------------------------

// GameAdminChangedMessage

// required uint32 gameId = 1;
inline bool GameAdminChangedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameAdminChangedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameAdminChangedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameAdminChangedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameAdminChangedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameAdminChangedMessage.gameId)
  return gameid_;
}
inline void GameAdminChangedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameAdminChangedMessage.gameId)
}

// required uint32 newAdminPlayerId = 2;
inline bool GameAdminChangedMessage::has_newadminplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameAdminChangedMessage::set_has_newadminplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameAdminChangedMessage::clear_has_newadminplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameAdminChangedMessage::clear_newadminplayerid() {
  newadminplayerid_ = 0u;
  clear_has_newadminplayerid();
}
inline ::google::protobuf::uint32 GameAdminChangedMessage::newadminplayerid() const {
  // @@protoc_insertion_point(field_get:GameAdminChangedMessage.newAdminPlayerId)
  return newadminplayerid_;
}
inline void GameAdminChangedMessage::set_newadminplayerid(::google::protobuf::uint32 value) {
  set_has_newadminplayerid();
  newadminplayerid_ = value;
  // @@protoc_insertion_point(field_set:GameAdminChangedMessage.newAdminPlayerId)
}

// -------------------------------------------------------------------

// RemovedFromGameMessage

// required uint32 gameId = 1;
inline bool RemovedFromGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemovedFromGameMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemovedFromGameMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemovedFromGameMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 RemovedFromGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RemovedFromGameMessage.gameId)
  return gameid_;
}
inline void RemovedFromGameMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:RemovedFromGameMessage.gameId)
}

// required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
inline bool RemovedFromGameMessage::has_removedfromgamereason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemovedFromGameMessage::set_has_removedfromgamereason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemovedFromGameMessage::clear_has_removedfromgamereason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemovedFromGameMessage::clear_removedfromgamereason() {
  removedfromgamereason_ = 0;
  clear_has_removedfromgamereason();
}
inline ::RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::removedfromgamereason() const {
  // @@protoc_insertion_point(field_get:RemovedFromGameMessage.removedFromGameReason)
  return static_cast< ::RemovedFromGameMessage_RemovedFromGameReason >(removedfromgamereason_);
}
inline void RemovedFromGameMessage::set_removedfromgamereason(::RemovedFromGameMessage_RemovedFromGameReason value) {
  assert(::RemovedFromGameMessage_RemovedFromGameReason_IsValid(value));
  set_has_removedfromgamereason();
  removedfromgamereason_ = value;
  // @@protoc_insertion_point(field_set:RemovedFromGameMessage.removedFromGameReason)
}

// -------------------------------------------------------------------

// KickPlayerRequestMessage

// required uint32 gameId = 1;
inline bool KickPlayerRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickPlayerRequestMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickPlayerRequestMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickPlayerRequestMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 KickPlayerRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:KickPlayerRequestMessage.gameId)
  return gameid_;
}
inline void KickPlayerRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:KickPlayerRequestMessage.gameId)
}

// required uint32 playerId = 2;
inline bool KickPlayerRequestMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickPlayerRequestMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickPlayerRequestMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickPlayerRequestMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 KickPlayerRequestMessage::playerid() const {
  // @@protoc_insertion_point(field_get:KickPlayerRequestMessage.playerId)
  return playerid_;
}
inline void KickPlayerRequestMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:KickPlayerRequestMessage.playerId)
}

// -------------------------------------------------------------------

// LeaveGameRequestMessage

// required uint32 gameId = 1;
inline bool LeaveGameRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveGameRequestMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveGameRequestMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveGameRequestMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 LeaveGameRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:LeaveGameRequestMessage.gameId)
  return gameid_;
}
inline void LeaveGameRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:LeaveGameRequestMessage.gameId)
}

// -------------------------------------------------------------------

// InvitePlayerToGameMessage

// required uint32 gameId = 1;
inline bool InvitePlayerToGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvitePlayerToGameMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvitePlayerToGameMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvitePlayerToGameMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 InvitePlayerToGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:InvitePlayerToGameMessage.gameId)
  return gameid_;
}
inline void InvitePlayerToGameMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:InvitePlayerToGameMessage.gameId)
}

// required uint32 playerId = 2;
inline bool InvitePlayerToGameMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvitePlayerToGameMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvitePlayerToGameMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvitePlayerToGameMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 InvitePlayerToGameMessage::playerid() const {
  // @@protoc_insertion_point(field_get:InvitePlayerToGameMessage.playerId)
  return playerid_;
}
inline void InvitePlayerToGameMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:InvitePlayerToGameMessage.playerId)
}

// -------------------------------------------------------------------

// InviteNotifyMessage

// required uint32 gameId = 1;
inline bool InviteNotifyMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteNotifyMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteNotifyMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteNotifyMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 InviteNotifyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:InviteNotifyMessage.gameId)
  return gameid_;
}
inline void InviteNotifyMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:InviteNotifyMessage.gameId)
}

// required uint32 playerIdWho = 2;
inline bool InviteNotifyMessage::has_playeridwho() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteNotifyMessage::set_has_playeridwho() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteNotifyMessage::clear_has_playeridwho() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteNotifyMessage::clear_playeridwho() {
  playeridwho_ = 0u;
  clear_has_playeridwho();
}
inline ::google::protobuf::uint32 InviteNotifyMessage::playeridwho() const {
  // @@protoc_insertion_point(field_get:InviteNotifyMessage.playerIdWho)
  return playeridwho_;
}
inline void InviteNotifyMessage::set_playeridwho(::google::protobuf::uint32 value) {
  set_has_playeridwho();
  playeridwho_ = value;
  // @@protoc_insertion_point(field_set:InviteNotifyMessage.playerIdWho)
}

// required uint32 playerIdByWhom = 3;
inline bool InviteNotifyMessage::has_playeridbywhom() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InviteNotifyMessage::set_has_playeridbywhom() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InviteNotifyMessage::clear_has_playeridbywhom() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InviteNotifyMessage::clear_playeridbywhom() {
  playeridbywhom_ = 0u;
  clear_has_playeridbywhom();
}
inline ::google::protobuf::uint32 InviteNotifyMessage::playeridbywhom() const {
  // @@protoc_insertion_point(field_get:InviteNotifyMessage.playerIdByWhom)
  return playeridbywhom_;
}
inline void InviteNotifyMessage::set_playeridbywhom(::google::protobuf::uint32 value) {
  set_has_playeridbywhom();
  playeridbywhom_ = value;
  // @@protoc_insertion_point(field_set:InviteNotifyMessage.playerIdByWhom)
}

// -------------------------------------------------------------------

// RejectGameInvitationMessage

// required uint32 gameId = 1;
inline bool RejectGameInvitationMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectGameInvitationMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectGameInvitationMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectGameInvitationMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 RejectGameInvitationMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RejectGameInvitationMessage.gameId)
  return gameid_;
}
inline void RejectGameInvitationMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:RejectGameInvitationMessage.gameId)
}

// required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
inline bool RejectGameInvitationMessage::has_myrejectreason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectGameInvitationMessage::set_has_myrejectreason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectGameInvitationMessage::clear_has_myrejectreason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectGameInvitationMessage::clear_myrejectreason() {
  myrejectreason_ = 0;
  clear_has_myrejectreason();
}
inline ::RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage::myrejectreason() const {
  // @@protoc_insertion_point(field_get:RejectGameInvitationMessage.myRejectReason)
  return static_cast< ::RejectGameInvitationMessage_RejectGameInvReason >(myrejectreason_);
}
inline void RejectGameInvitationMessage::set_myrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value) {
  assert(::RejectGameInvitationMessage_RejectGameInvReason_IsValid(value));
  set_has_myrejectreason();
  myrejectreason_ = value;
  // @@protoc_insertion_point(field_set:RejectGameInvitationMessage.myRejectReason)
}

// -------------------------------------------------------------------

// RejectInvNotifyMessage

// required uint32 gameId = 1;
inline bool RejectInvNotifyMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectInvNotifyMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectInvNotifyMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectInvNotifyMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 RejectInvNotifyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RejectInvNotifyMessage.gameId)
  return gameid_;
}
inline void RejectInvNotifyMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:RejectInvNotifyMessage.gameId)
}

// required uint32 playerId = 2;
inline bool RejectInvNotifyMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectInvNotifyMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectInvNotifyMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectInvNotifyMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 RejectInvNotifyMessage::playerid() const {
  // @@protoc_insertion_point(field_get:RejectInvNotifyMessage.playerId)
  return playerid_;
}
inline void RejectInvNotifyMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:RejectInvNotifyMessage.playerId)
}

// required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
inline bool RejectInvNotifyMessage::has_playerrejectreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RejectInvNotifyMessage::set_has_playerrejectreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RejectInvNotifyMessage::clear_has_playerrejectreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RejectInvNotifyMessage::clear_playerrejectreason() {
  playerrejectreason_ = 0;
  clear_has_playerrejectreason();
}
inline ::RejectGameInvitationMessage_RejectGameInvReason RejectInvNotifyMessage::playerrejectreason() const {
  // @@protoc_insertion_point(field_get:RejectInvNotifyMessage.playerRejectReason)
  return static_cast< ::RejectGameInvitationMessage_RejectGameInvReason >(playerrejectreason_);
}
inline void RejectInvNotifyMessage::set_playerrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value) {
  assert(::RejectGameInvitationMessage_RejectGameInvReason_IsValid(value));
  set_has_playerrejectreason();
  playerrejectreason_ = value;
  // @@protoc_insertion_point(field_set:RejectInvNotifyMessage.playerRejectReason)
}

// -------------------------------------------------------------------

// StartEventMessage

// required uint32 gameId = 1;
inline bool StartEventMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartEventMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartEventMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartEventMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 StartEventMessage::gameid() const {
  // @@protoc_insertion_point(field_get:StartEventMessage.gameId)
  return gameid_;
}
inline void StartEventMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:StartEventMessage.gameId)
}

// required .StartEventMessage.StartEventType startEventType = 2;
inline bool StartEventMessage::has_starteventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartEventMessage::set_has_starteventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartEventMessage::clear_has_starteventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartEventMessage::clear_starteventtype() {
  starteventtype_ = 0;
  clear_has_starteventtype();
}
inline ::StartEventMessage_StartEventType StartEventMessage::starteventtype() const {
  // @@protoc_insertion_point(field_get:StartEventMessage.startEventType)
  return static_cast< ::StartEventMessage_StartEventType >(starteventtype_);
}
inline void StartEventMessage::set_starteventtype(::StartEventMessage_StartEventType value) {
  assert(::StartEventMessage_StartEventType_IsValid(value));
  set_has_starteventtype();
  starteventtype_ = value;
  // @@protoc_insertion_point(field_set:StartEventMessage.startEventType)
}

// optional bool fillWithComputerPlayers = 3;
inline bool StartEventMessage::has_fillwithcomputerplayers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartEventMessage::set_has_fillwithcomputerplayers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartEventMessage::clear_has_fillwithcomputerplayers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartEventMessage::clear_fillwithcomputerplayers() {
  fillwithcomputerplayers_ = false;
  clear_has_fillwithcomputerplayers();
}
inline bool StartEventMessage::fillwithcomputerplayers() const {
  // @@protoc_insertion_point(field_get:StartEventMessage.fillWithComputerPlayers)
  return fillwithcomputerplayers_;
}
inline void StartEventMessage::set_fillwithcomputerplayers(bool value) {
  set_has_fillwithcomputerplayers();
  fillwithcomputerplayers_ = value;
  // @@protoc_insertion_point(field_set:StartEventMessage.fillWithComputerPlayers)
}

// -------------------------------------------------------------------

// StartEventAckMessage

// required uint32 gameId = 1;
inline bool StartEventAckMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartEventAckMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartEventAckMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartEventAckMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 StartEventAckMessage::gameid() const {
  // @@protoc_insertion_point(field_get:StartEventAckMessage.gameId)
  return gameid_;
}
inline void StartEventAckMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:StartEventAckMessage.gameId)
}

// -------------------------------------------------------------------

// GameStartInitialMessage

// required uint32 gameId = 1;
inline bool GameStartInitialMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStartInitialMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStartInitialMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStartInitialMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameStartInitialMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameStartInitialMessage.gameId)
  return gameid_;
}
inline void GameStartInitialMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameStartInitialMessage.gameId)
}

// required uint32 startDealerPlayerId = 2;
inline bool GameStartInitialMessage::has_startdealerplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStartInitialMessage::set_has_startdealerplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStartInitialMessage::clear_has_startdealerplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStartInitialMessage::clear_startdealerplayerid() {
  startdealerplayerid_ = 0u;
  clear_has_startdealerplayerid();
}
inline ::google::protobuf::uint32 GameStartInitialMessage::startdealerplayerid() const {
  // @@protoc_insertion_point(field_get:GameStartInitialMessage.startDealerPlayerId)
  return startdealerplayerid_;
}
inline void GameStartInitialMessage::set_startdealerplayerid(::google::protobuf::uint32 value) {
  set_has_startdealerplayerid();
  startdealerplayerid_ = value;
  // @@protoc_insertion_point(field_set:GameStartInitialMessage.startDealerPlayerId)
}

// repeated uint32 playerSeats = 3 [packed = true];
inline int GameStartInitialMessage::playerseats_size() const {
  return playerseats_.size();
}
inline void GameStartInitialMessage::clear_playerseats() {
  playerseats_.Clear();
}
inline ::google::protobuf::uint32 GameStartInitialMessage::playerseats(int index) const {
  // @@protoc_insertion_point(field_get:GameStartInitialMessage.playerSeats)
  return playerseats_.Get(index);
}
inline void GameStartInitialMessage::set_playerseats(int index, ::google::protobuf::uint32 value) {
  playerseats_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameStartInitialMessage.playerSeats)
}
inline void GameStartInitialMessage::add_playerseats(::google::protobuf::uint32 value) {
  playerseats_.Add(value);
  // @@protoc_insertion_point(field_add:GameStartInitialMessage.playerSeats)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameStartInitialMessage::playerseats() const {
  // @@protoc_insertion_point(field_list:GameStartInitialMessage.playerSeats)
  return playerseats_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameStartInitialMessage::mutable_playerseats() {
  // @@protoc_insertion_point(field_mutable_list:GameStartInitialMessage.playerSeats)
  return &playerseats_;
}

// -------------------------------------------------------------------

// GameStartRejoinMessage_RejoinPlayerData

// required uint32 playerId = 1;
inline bool GameStartRejoinMessage_RejoinPlayerData::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 GameStartRejoinMessage_RejoinPlayerData::playerid() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.RejoinPlayerData.playerId)
  return playerid_;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.RejoinPlayerData.playerId)
}

// required uint32 playerMoney = 2;
inline bool GameStartRejoinMessage_RejoinPlayerData::has_playermoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_has_playermoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_has_playermoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_playermoney() {
  playermoney_ = 0u;
  clear_has_playermoney();
}
inline ::google::protobuf::uint32 GameStartRejoinMessage_RejoinPlayerData::playermoney() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.RejoinPlayerData.playerMoney)
  return playermoney_;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_playermoney(::google::protobuf::uint32 value) {
  set_has_playermoney();
  playermoney_ = value;
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.RejoinPlayerData.playerMoney)
}

// -------------------------------------------------------------------

// GameStartRejoinMessage

// required uint32 gameId = 1;
inline bool GameStartRejoinMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStartRejoinMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStartRejoinMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStartRejoinMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameStartRejoinMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.gameId)
  return gameid_;
}
inline void GameStartRejoinMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.gameId)
}

// required uint32 startDealerPlayerId = 2;
inline bool GameStartRejoinMessage::has_startdealerplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStartRejoinMessage::set_has_startdealerplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStartRejoinMessage::clear_has_startdealerplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStartRejoinMessage::clear_startdealerplayerid() {
  startdealerplayerid_ = 0u;
  clear_has_startdealerplayerid();
}
inline ::google::protobuf::uint32 GameStartRejoinMessage::startdealerplayerid() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.startDealerPlayerId)
  return startdealerplayerid_;
}
inline void GameStartRejoinMessage::set_startdealerplayerid(::google::protobuf::uint32 value) {
  set_has_startdealerplayerid();
  startdealerplayerid_ = value;
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.startDealerPlayerId)
}

// required uint32 handNum = 3;
inline bool GameStartRejoinMessage::has_handnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameStartRejoinMessage::set_has_handnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameStartRejoinMessage::clear_has_handnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameStartRejoinMessage::clear_handnum() {
  handnum_ = 0u;
  clear_has_handnum();
}
inline ::google::protobuf::uint32 GameStartRejoinMessage::handnum() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.handNum)
  return handnum_;
}
inline void GameStartRejoinMessage::set_handnum(::google::protobuf::uint32 value) {
  set_has_handnum();
  handnum_ = value;
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.handNum)
}

// repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
inline int GameStartRejoinMessage::rejoinplayerdata_size() const {
  return rejoinplayerdata_.size();
}
inline void GameStartRejoinMessage::clear_rejoinplayerdata() {
  rejoinplayerdata_.Clear();
}
inline const ::GameStartRejoinMessage_RejoinPlayerData& GameStartRejoinMessage::rejoinplayerdata(int index) const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.rejoinPlayerData)
  return rejoinplayerdata_.Get(index);
}
inline ::GameStartRejoinMessage_RejoinPlayerData* GameStartRejoinMessage::mutable_rejoinplayerdata(int index) {
  // @@protoc_insertion_point(field_mutable:GameStartRejoinMessage.rejoinPlayerData)
  return rejoinplayerdata_.Mutable(index);
}
inline ::GameStartRejoinMessage_RejoinPlayerData* GameStartRejoinMessage::add_rejoinplayerdata() {
  // @@protoc_insertion_point(field_add:GameStartRejoinMessage.rejoinPlayerData)
  return rejoinplayerdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >&
GameStartRejoinMessage::rejoinplayerdata() const {
  // @@protoc_insertion_point(field_list:GameStartRejoinMessage.rejoinPlayerData)
  return rejoinplayerdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >*
GameStartRejoinMessage::mutable_rejoinplayerdata() {
  // @@protoc_insertion_point(field_mutable_list:GameStartRejoinMessage.rejoinPlayerData)
  return &rejoinplayerdata_;
}

// -------------------------------------------------------------------

// HandStartMessage_PlainCards

// required uint32 plainCard1 = 1;
inline bool HandStartMessage_PlainCards::has_plaincard1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandStartMessage_PlainCards::set_has_plaincard1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandStartMessage_PlainCards::clear_has_plaincard1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandStartMessage_PlainCards::clear_plaincard1() {
  plaincard1_ = 0u;
  clear_has_plaincard1();
}
inline ::google::protobuf::uint32 HandStartMessage_PlainCards::plaincard1() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.PlainCards.plainCard1)
  return plaincard1_;
}
inline void HandStartMessage_PlainCards::set_plaincard1(::google::protobuf::uint32 value) {
  set_has_plaincard1();
  plaincard1_ = value;
  // @@protoc_insertion_point(field_set:HandStartMessage.PlainCards.plainCard1)
}

// required uint32 plainCard2 = 2;
inline bool HandStartMessage_PlainCards::has_plaincard2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandStartMessage_PlainCards::set_has_plaincard2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandStartMessage_PlainCards::clear_has_plaincard2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandStartMessage_PlainCards::clear_plaincard2() {
  plaincard2_ = 0u;
  clear_has_plaincard2();
}
inline ::google::protobuf::uint32 HandStartMessage_PlainCards::plaincard2() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.PlainCards.plainCard2)
  return plaincard2_;
}
inline void HandStartMessage_PlainCards::set_plaincard2(::google::protobuf::uint32 value) {
  set_has_plaincard2();
  plaincard2_ = value;
  // @@protoc_insertion_point(field_set:HandStartMessage.PlainCards.plainCard2)
}

// -------------------------------------------------------------------

// HandStartMessage

// required uint32 gameId = 1;
inline bool HandStartMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandStartMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandStartMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandStartMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 HandStartMessage::gameid() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.gameId)
  return gameid_;
}
inline void HandStartMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:HandStartMessage.gameId)
}

// optional .HandStartMessage.PlainCards plainCards = 2;
inline bool HandStartMessage::has_plaincards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandStartMessage::set_has_plaincards() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandStartMessage::clear_has_plaincards() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandStartMessage::clear_plaincards() {
  if (plaincards_ != NULL) plaincards_->::HandStartMessage_PlainCards::Clear();
  clear_has_plaincards();
}
inline const ::HandStartMessage_PlainCards& HandStartMessage::plaincards() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.plainCards)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return plaincards_ != NULL ? *plaincards_ : *default_instance().plaincards_;
#else
  return plaincards_ != NULL ? *plaincards_ : *default_instance_->plaincards_;
#endif
}
inline ::HandStartMessage_PlainCards* HandStartMessage::mutable_plaincards() {
  set_has_plaincards();
  if (plaincards_ == NULL) plaincards_ = new ::HandStartMessage_PlainCards;
  // @@protoc_insertion_point(field_mutable:HandStartMessage.plainCards)
  return plaincards_;
}
inline ::HandStartMessage_PlainCards* HandStartMessage::release_plaincards() {
  clear_has_plaincards();
  ::HandStartMessage_PlainCards* temp = plaincards_;
  plaincards_ = NULL;
  return temp;
}
inline void HandStartMessage::set_allocated_plaincards(::HandStartMessage_PlainCards* plaincards) {
  delete plaincards_;
  plaincards_ = plaincards;
  if (plaincards) {
    set_has_plaincards();
  } else {
    clear_has_plaincards();
  }
  // @@protoc_insertion_point(field_set_allocated:HandStartMessage.plainCards)
}

// optional bytes encryptedCards = 3;
inline bool HandStartMessage::has_encryptedcards() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HandStartMessage::set_has_encryptedcards() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HandStartMessage::clear_has_encryptedcards() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HandStartMessage::clear_encryptedcards() {
  if (encryptedcards_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptedcards_->clear();
  }
  clear_has_encryptedcards();
}
inline const ::std::string& HandStartMessage::encryptedcards() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.encryptedCards)
  return *encryptedcards_;
}
inline void HandStartMessage::set_encryptedcards(const ::std::string& value) {
  set_has_encryptedcards();
  if (encryptedcards_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptedcards_ = new ::std::string;
  }
  encryptedcards_->assign(value);
  // @@protoc_insertion_point(field_set:HandStartMessage.encryptedCards)
}
inline void HandStartMessage::set_encryptedcards(const char* value) {
  set_has_encryptedcards();
  if (encryptedcards_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptedcards_ = new ::std::string;
  }
  encryptedcards_->assign(value);
  // @@protoc_insertion_point(field_set_char:HandStartMessage.encryptedCards)
}
inline void HandStartMessage::set_encryptedcards(const void* value, size_t size) {
  set_has_encryptedcards();
  if (encryptedcards_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptedcards_ = new ::std::string;
  }
  encryptedcards_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HandStartMessage.encryptedCards)
}
inline ::std::string* HandStartMessage::mutable_encryptedcards() {
  set_has_encryptedcards();
  if (encryptedcards_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptedcards_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:HandStartMessage.encryptedCards)
  return encryptedcards_;
}
inline ::std::string* HandStartMessage::release_encryptedcards() {
  clear_has_encryptedcards();
  if (encryptedcards_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encryptedcards_;
    encryptedcards_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HandStartMessage::set_allocated_encryptedcards(::std::string* encryptedcards) {
  if (encryptedcards_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encryptedcards_;
  }
  if (encryptedcards) {
    set_has_encryptedcards();
    encryptedcards_ = encryptedcards;
  } else {
    clear_has_encryptedcards();
    encryptedcards_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:HandStartMessage.encryptedCards)
}

// required uint32 smallBlind = 4;
inline bool HandStartMessage::has_smallblind() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HandStartMessage::set_has_smallblind() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HandStartMessage::clear_has_smallblind() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HandStartMessage::clear_smallblind() {
  smallblind_ = 0u;
  clear_has_smallblind();
}
inline ::google::protobuf::uint32 HandStartMessage::smallblind() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.smallBlind)
  return smallblind_;
}
inline void HandStartMessage::set_smallblind(::google::protobuf::uint32 value) {
  set_has_smallblind();
  smallblind_ = value;
  // @@protoc_insertion_point(field_set:HandStartMessage.smallBlind)
}

// repeated .NetPlayerState seatStates = 5;
inline int HandStartMessage::seatstates_size() const {
  return seatstates_.size();
}
inline void HandStartMessage::clear_seatstates() {
  seatstates_.Clear();
}
inline ::NetPlayerState HandStartMessage::seatstates(int index) const {
  // @@protoc_insertion_point(field_get:HandStartMessage.seatStates)
  return static_cast< ::NetPlayerState >(seatstates_.Get(index));
}
inline void HandStartMessage::set_seatstates(int index, ::NetPlayerState value) {
  assert(::NetPlayerState_IsValid(value));
  seatstates_.Set(index, value);
  // @@protoc_insertion_point(field_set:HandStartMessage.seatStates)
}
inline void HandStartMessage::add_seatstates(::NetPlayerState value) {
  assert(::NetPlayerState_IsValid(value));
  seatstates_.Add(value);
  // @@protoc_insertion_point(field_add:HandStartMessage.seatStates)
}
inline const ::google::protobuf::RepeatedField<int>&
HandStartMessage::seatstates() const {
  // @@protoc_insertion_point(field_list:HandStartMessage.seatStates)
  return seatstates_;
}
inline ::google::protobuf::RepeatedField<int>*
HandStartMessage::mutable_seatstates() {
  // @@protoc_insertion_point(field_mutable_list:HandStartMessage.seatStates)
  return &seatstates_;
}

// optional uint32 dealerPlayerId = 6;
inline bool HandStartMessage::has_dealerplayerid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HandStartMessage::set_has_dealerplayerid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HandStartMessage::clear_has_dealerplayerid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HandStartMessage::clear_dealerplayerid() {
  dealerplayerid_ = 0u;
  clear_has_dealerplayerid();
}
inline ::google::protobuf::uint32 HandStartMessage::dealerplayerid() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.dealerPlayerId)
  return dealerplayerid_;
}
inline void HandStartMessage::set_dealerplayerid(::google::protobuf::uint32 value) {
  set_has_dealerplayerid();
  dealerplayerid_ = value;
  // @@protoc_insertion_point(field_set:HandStartMessage.dealerPlayerId)
}

// -------------------------------------------------------------------

// PlayersTurnMessage

// required uint32 gameId = 1;
inline bool PlayersTurnMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayersTurnMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayersTurnMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayersTurnMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 PlayersTurnMessage::gameid() const {
  // @@protoc_insertion_point(field_get:PlayersTurnMessage.gameId)
  return gameid_;
}
inline void PlayersTurnMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:PlayersTurnMessage.gameId)
}

// required uint32 playerId = 2;
inline bool PlayersTurnMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayersTurnMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayersTurnMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayersTurnMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayersTurnMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayersTurnMessage.playerId)
  return playerid_;
}
inline void PlayersTurnMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayersTurnMessage.playerId)
}

// required .NetGameState gameState = 3;
inline bool PlayersTurnMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayersTurnMessage::set_has_gamestate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayersTurnMessage::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayersTurnMessage::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline ::NetGameState PlayersTurnMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:PlayersTurnMessage.gameState)
  return static_cast< ::NetGameState >(gamestate_);
}
inline void PlayersTurnMessage::set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  set_has_gamestate();
  gamestate_ = value;
  // @@protoc_insertion_point(field_set:PlayersTurnMessage.gameState)
}

// -------------------------------------------------------------------

// MyActionRequestMessage

// required uint32 gameId = 1;
inline bool MyActionRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyActionRequestMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyActionRequestMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyActionRequestMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 MyActionRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.gameId)
  return gameid_;
}
inline void MyActionRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.gameId)
}

// required uint32 handNum = 2;
inline bool MyActionRequestMessage::has_handnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MyActionRequestMessage::set_has_handnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MyActionRequestMessage::clear_has_handnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MyActionRequestMessage::clear_handnum() {
  handnum_ = 0u;
  clear_has_handnum();
}
inline ::google::protobuf::uint32 MyActionRequestMessage::handnum() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.handNum)
  return handnum_;
}
inline void MyActionRequestMessage::set_handnum(::google::protobuf::uint32 value) {
  set_has_handnum();
  handnum_ = value;
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.handNum)
}

// required .NetGameState gameState = 3;
inline bool MyActionRequestMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MyActionRequestMessage::set_has_gamestate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MyActionRequestMessage::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MyActionRequestMessage::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline ::NetGameState MyActionRequestMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.gameState)
  return static_cast< ::NetGameState >(gamestate_);
}
inline void MyActionRequestMessage::set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  set_has_gamestate();
  gamestate_ = value;
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.gameState)
}

// required .NetPlayerAction myAction = 4;
inline bool MyActionRequestMessage::has_myaction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MyActionRequestMessage::set_has_myaction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MyActionRequestMessage::clear_has_myaction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MyActionRequestMessage::clear_myaction() {
  myaction_ = 0;
  clear_has_myaction();
}
inline ::NetPlayerAction MyActionRequestMessage::myaction() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.myAction)
  return static_cast< ::NetPlayerAction >(myaction_);
}
inline void MyActionRequestMessage::set_myaction(::NetPlayerAction value) {
  assert(::NetPlayerAction_IsValid(value));
  set_has_myaction();
  myaction_ = value;
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.myAction)
}

// required uint32 myRelativeBet = 5;
inline bool MyActionRequestMessage::has_myrelativebet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MyActionRequestMessage::set_has_myrelativebet() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MyActionRequestMessage::clear_has_myrelativebet() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MyActionRequestMessage::clear_myrelativebet() {
  myrelativebet_ = 0u;
  clear_has_myrelativebet();
}
inline ::google::protobuf::uint32 MyActionRequestMessage::myrelativebet() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.myRelativeBet)
  return myrelativebet_;
}
inline void MyActionRequestMessage::set_myrelativebet(::google::protobuf::uint32 value) {
  set_has_myrelativebet();
  myrelativebet_ = value;
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.myRelativeBet)
}

// -------------------------------------------------------------------

// YourActionRejectedMessage

// required uint32 gameId = 1;
inline bool YourActionRejectedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YourActionRejectedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YourActionRejectedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YourActionRejectedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 YourActionRejectedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.gameId)
  return gameid_;
}
inline void YourActionRejectedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.gameId)
}

// required .NetGameState gameState = 2;
inline bool YourActionRejectedMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YourActionRejectedMessage::set_has_gamestate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YourActionRejectedMessage::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YourActionRejectedMessage::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline ::NetGameState YourActionRejectedMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.gameState)
  return static_cast< ::NetGameState >(gamestate_);
}
inline void YourActionRejectedMessage::set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  set_has_gamestate();
  gamestate_ = value;
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.gameState)
}

// required .NetPlayerAction yourAction = 3;
inline bool YourActionRejectedMessage::has_youraction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YourActionRejectedMessage::set_has_youraction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YourActionRejectedMessage::clear_has_youraction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YourActionRejectedMessage::clear_youraction() {
  youraction_ = 0;
  clear_has_youraction();
}
inline ::NetPlayerAction YourActionRejectedMessage::youraction() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.yourAction)
  return static_cast< ::NetPlayerAction >(youraction_);
}
inline void YourActionRejectedMessage::set_youraction(::NetPlayerAction value) {
  assert(::NetPlayerAction_IsValid(value));
  set_has_youraction();
  youraction_ = value;
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.yourAction)
}

// required uint32 yourRelativeBet = 4;
inline bool YourActionRejectedMessage::has_yourrelativebet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YourActionRejectedMessage::set_has_yourrelativebet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YourActionRejectedMessage::clear_has_yourrelativebet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YourActionRejectedMessage::clear_yourrelativebet() {
  yourrelativebet_ = 0u;
  clear_has_yourrelativebet();
}
inline ::google::protobuf::uint32 YourActionRejectedMessage::yourrelativebet() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.yourRelativeBet)
  return yourrelativebet_;
}
inline void YourActionRejectedMessage::set_yourrelativebet(::google::protobuf::uint32 value) {
  set_has_yourrelativebet();
  yourrelativebet_ = value;
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.yourRelativeBet)
}

// required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
inline bool YourActionRejectedMessage::has_rejectionreason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void YourActionRejectedMessage::set_has_rejectionreason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void YourActionRejectedMessage::clear_has_rejectionreason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void YourActionRejectedMessage::clear_rejectionreason() {
  rejectionreason_ = 1;
  clear_has_rejectionreason();
}
inline ::YourActionRejectedMessage_RejectionReason YourActionRejectedMessage::rejectionreason() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.rejectionReason)
  return static_cast< ::YourActionRejectedMessage_RejectionReason >(rejectionreason_);
}
inline void YourActionRejectedMessage::set_rejectionreason(::YourActionRejectedMessage_RejectionReason value) {
  assert(::YourActionRejectedMessage_RejectionReason_IsValid(value));
  set_has_rejectionreason();
  rejectionreason_ = value;
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.rejectionReason)
}

// -------------------------------------------------------------------

// PlayersActionDoneMessage

// required uint32 gameId = 1;
inline bool PlayersActionDoneMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayersActionDoneMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayersActionDoneMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayersActionDoneMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::gameid() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.gameId)
  return gameid_;
}
inline void PlayersActionDoneMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.gameId)
}

// required uint32 playerId = 2;
inline bool PlayersActionDoneMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayersActionDoneMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayersActionDoneMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayersActionDoneMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.playerId)
  return playerid_;
}
inline void PlayersActionDoneMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.playerId)
}

// required .NetGameState gameState = 3;
inline bool PlayersActionDoneMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayersActionDoneMessage::set_has_gamestate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayersActionDoneMessage::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayersActionDoneMessage::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline ::NetGameState PlayersActionDoneMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.gameState)
  return static_cast< ::NetGameState >(gamestate_);
}
inline void PlayersActionDoneMessage::set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  set_has_gamestate();
  gamestate_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.gameState)
}

// required .NetPlayerAction playerAction = 4;
inline bool PlayersActionDoneMessage::has_playeraction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayersActionDoneMessage::set_has_playeraction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayersActionDoneMessage::clear_has_playeraction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayersActionDoneMessage::clear_playeraction() {
  playeraction_ = 0;
  clear_has_playeraction();
}
inline ::NetPlayerAction PlayersActionDoneMessage::playeraction() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.playerAction)
  return static_cast< ::NetPlayerAction >(playeraction_);
}
inline void PlayersActionDoneMessage::set_playeraction(::NetPlayerAction value) {
  assert(::NetPlayerAction_IsValid(value));
  set_has_playeraction();
  playeraction_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.playerAction)
}

// required uint32 totalPlayerBet = 5;
inline bool PlayersActionDoneMessage::has_totalplayerbet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayersActionDoneMessage::set_has_totalplayerbet() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayersActionDoneMessage::clear_has_totalplayerbet() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayersActionDoneMessage::clear_totalplayerbet() {
  totalplayerbet_ = 0u;
  clear_has_totalplayerbet();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::totalplayerbet() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.totalPlayerBet)
  return totalplayerbet_;
}
inline void PlayersActionDoneMessage::set_totalplayerbet(::google::protobuf::uint32 value) {
  set_has_totalplayerbet();
  totalplayerbet_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.totalPlayerBet)
}

// required uint32 playerMoney = 6;
inline bool PlayersActionDoneMessage::has_playermoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayersActionDoneMessage::set_has_playermoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayersActionDoneMessage::clear_has_playermoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayersActionDoneMessage::clear_playermoney() {
  playermoney_ = 0u;
  clear_has_playermoney();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::playermoney() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.playerMoney)
  return playermoney_;
}
inline void PlayersActionDoneMessage::set_playermoney(::google::protobuf::uint32 value) {
  set_has_playermoney();
  playermoney_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.playerMoney)
}

// required uint32 highestSet = 7;
inline bool PlayersActionDoneMessage::has_highestset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayersActionDoneMessage::set_has_highestset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayersActionDoneMessage::clear_has_highestset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayersActionDoneMessage::clear_highestset() {
  highestset_ = 0u;
  clear_has_highestset();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::highestset() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.highestSet)
  return highestset_;
}
inline void PlayersActionDoneMessage::set_highestset(::google::protobuf::uint32 value) {
  set_has_highestset();
  highestset_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.highestSet)
}

// required uint32 minimumRaise = 8;
inline bool PlayersActionDoneMessage::has_minimumraise() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayersActionDoneMessage::set_has_minimumraise() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayersActionDoneMessage::clear_has_minimumraise() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayersActionDoneMessage::clear_minimumraise() {
  minimumraise_ = 0u;
  clear_has_minimumraise();
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::minimumraise() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.minimumRaise)
  return minimumraise_;
}
inline void PlayersActionDoneMessage::set_minimumraise(::google::protobuf::uint32 value) {
  set_has_minimumraise();
  minimumraise_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.minimumRaise)
}

// -------------------------------------------------------------------

// DealFlopCardsMessage

// required uint32 gameId = 1;
inline bool DealFlopCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealFlopCardsMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DealFlopCardsMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DealFlopCardsMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.gameId)
  return gameid_;
}
inline void DealFlopCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.gameId)
}

// required uint32 flopCard1 = 2;
inline bool DealFlopCardsMessage::has_flopcard1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealFlopCardsMessage::set_has_flopcard1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DealFlopCardsMessage::clear_has_flopcard1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DealFlopCardsMessage::clear_flopcard1() {
  flopcard1_ = 0u;
  clear_has_flopcard1();
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::flopcard1() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.flopCard1)
  return flopcard1_;
}
inline void DealFlopCardsMessage::set_flopcard1(::google::protobuf::uint32 value) {
  set_has_flopcard1();
  flopcard1_ = value;
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.flopCard1)
}

// required uint32 flopCard2 = 3;
inline bool DealFlopCardsMessage::has_flopcard2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DealFlopCardsMessage::set_has_flopcard2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DealFlopCardsMessage::clear_has_flopcard2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DealFlopCardsMessage::clear_flopcard2() {
  flopcard2_ = 0u;
  clear_has_flopcard2();
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::flopcard2() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.flopCard2)
  return flopcard2_;
}
inline void DealFlopCardsMessage::set_flopcard2(::google::protobuf::uint32 value) {
  set_has_flopcard2();
  flopcard2_ = value;
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.flopCard2)
}

// required uint32 flopCard3 = 4;
inline bool DealFlopCardsMessage::has_flopcard3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DealFlopCardsMessage::set_has_flopcard3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DealFlopCardsMessage::clear_has_flopcard3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DealFlopCardsMessage::clear_flopcard3() {
  flopcard3_ = 0u;
  clear_has_flopcard3();
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::flopcard3() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.flopCard3)
  return flopcard3_;
}
inline void DealFlopCardsMessage::set_flopcard3(::google::protobuf::uint32 value) {
  set_has_flopcard3();
  flopcard3_ = value;
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.flopCard3)
}

// -------------------------------------------------------------------

// DealTurnCardMessage

// required uint32 gameId = 1;
inline bool DealTurnCardMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealTurnCardMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DealTurnCardMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DealTurnCardMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 DealTurnCardMessage::gameid() const {
  // @@protoc_insertion_point(field_get:DealTurnCardMessage.gameId)
  return gameid_;
}
inline void DealTurnCardMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:DealTurnCardMessage.gameId)
}

// required uint32 turnCard = 2;
inline bool DealTurnCardMessage::has_turncard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealTurnCardMessage::set_has_turncard() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DealTurnCardMessage::clear_has_turncard() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DealTurnCardMessage::clear_turncard() {
  turncard_ = 0u;
  clear_has_turncard();
}
inline ::google::protobuf::uint32 DealTurnCardMessage::turncard() const {
  // @@protoc_insertion_point(field_get:DealTurnCardMessage.turnCard)
  return turncard_;
}
inline void DealTurnCardMessage::set_turncard(::google::protobuf::uint32 value) {
  set_has_turncard();
  turncard_ = value;
  // @@protoc_insertion_point(field_set:DealTurnCardMessage.turnCard)
}

// -------------------------------------------------------------------

// DealRiverCardMessage

// required uint32 gameId = 1;
inline bool DealRiverCardMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealRiverCardMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DealRiverCardMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DealRiverCardMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 DealRiverCardMessage::gameid() const {
  // @@protoc_insertion_point(field_get:DealRiverCardMessage.gameId)
  return gameid_;
}
inline void DealRiverCardMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:DealRiverCardMessage.gameId)
}

// required uint32 riverCard = 2;
inline bool DealRiverCardMessage::has_rivercard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealRiverCardMessage::set_has_rivercard() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DealRiverCardMessage::clear_has_rivercard() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DealRiverCardMessage::clear_rivercard() {
  rivercard_ = 0u;
  clear_has_rivercard();
}
inline ::google::protobuf::uint32 DealRiverCardMessage::rivercard() const {
  // @@protoc_insertion_point(field_get:DealRiverCardMessage.riverCard)
  return rivercard_;
}
inline void DealRiverCardMessage::set_rivercard(::google::protobuf::uint32 value) {
  set_has_rivercard();
  rivercard_ = value;
  // @@protoc_insertion_point(field_set:DealRiverCardMessage.riverCard)
}

// -------------------------------------------------------------------

// AllInShowCardsMessage_PlayerAllIn

// required uint32 playerId = 1;
inline bool AllInShowCardsMessage_PlayerAllIn::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 AllInShowCardsMessage_PlayerAllIn::playerid() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.PlayerAllIn.playerId)
  return playerid_;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.PlayerAllIn.playerId)
}

// required uint32 allInCard1 = 2;
inline bool AllInShowCardsMessage_PlayerAllIn::has_allincard1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_has_allincard1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_has_allincard1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_allincard1() {
  allincard1_ = 0u;
  clear_has_allincard1();
}
inline ::google::protobuf::uint32 AllInShowCardsMessage_PlayerAllIn::allincard1() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.PlayerAllIn.allInCard1)
  return allincard1_;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_allincard1(::google::protobuf::uint32 value) {
  set_has_allincard1();
  allincard1_ = value;
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.PlayerAllIn.allInCard1)
}

// required uint32 allInCard2 = 3;
inline bool AllInShowCardsMessage_PlayerAllIn::has_allincard2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_has_allincard2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_has_allincard2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_allincard2() {
  allincard2_ = 0u;
  clear_has_allincard2();
}
inline ::google::protobuf::uint32 AllInShowCardsMessage_PlayerAllIn::allincard2() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.PlayerAllIn.allInCard2)
  return allincard2_;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_allincard2(::google::protobuf::uint32 value) {
  set_has_allincard2();
  allincard2_ = value;
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.PlayerAllIn.allInCard2)
}

// -------------------------------------------------------------------

// AllInShowCardsMessage

// required uint32 gameId = 1;
inline bool AllInShowCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllInShowCardsMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllInShowCardsMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllInShowCardsMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 AllInShowCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.gameId)
  return gameid_;
}
inline void AllInShowCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.gameId)
}

// repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
inline int AllInShowCardsMessage::playersallin_size() const {
  return playersallin_.size();
}
inline void AllInShowCardsMessage::clear_playersallin() {
  playersallin_.Clear();
}
inline const ::AllInShowCardsMessage_PlayerAllIn& AllInShowCardsMessage::playersallin(int index) const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.playersAllIn)
  return playersallin_.Get(index);
}
inline ::AllInShowCardsMessage_PlayerAllIn* AllInShowCardsMessage::mutable_playersallin(int index) {
  // @@protoc_insertion_point(field_mutable:AllInShowCardsMessage.playersAllIn)
  return playersallin_.Mutable(index);
}
inline ::AllInShowCardsMessage_PlayerAllIn* AllInShowCardsMessage::add_playersallin() {
  // @@protoc_insertion_point(field_add:AllInShowCardsMessage.playersAllIn)
  return playersallin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >&
AllInShowCardsMessage::playersallin() const {
  // @@protoc_insertion_point(field_list:AllInShowCardsMessage.playersAllIn)
  return playersallin_;
}
inline ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >*
AllInShowCardsMessage::mutable_playersallin() {
  // @@protoc_insertion_point(field_mutable_list:AllInShowCardsMessage.playersAllIn)
  return &playersallin_;
}

// -------------------------------------------------------------------

// EndOfHandShowCardsMessage

// required uint32 gameId = 1;
inline bool EndOfHandShowCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndOfHandShowCardsMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndOfHandShowCardsMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndOfHandShowCardsMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 EndOfHandShowCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndOfHandShowCardsMessage.gameId)
  return gameid_;
}
inline void EndOfHandShowCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:EndOfHandShowCardsMessage.gameId)
}

// repeated .PlayerResult playerResults = 2;
inline int EndOfHandShowCardsMessage::playerresults_size() const {
  return playerresults_.size();
}
inline void EndOfHandShowCardsMessage::clear_playerresults() {
  playerresults_.Clear();
}
inline const ::PlayerResult& EndOfHandShowCardsMessage::playerresults(int index) const {
  // @@protoc_insertion_point(field_get:EndOfHandShowCardsMessage.playerResults)
  return playerresults_.Get(index);
}
inline ::PlayerResult* EndOfHandShowCardsMessage::mutable_playerresults(int index) {
  // @@protoc_insertion_point(field_mutable:EndOfHandShowCardsMessage.playerResults)
  return playerresults_.Mutable(index);
}
inline ::PlayerResult* EndOfHandShowCardsMessage::add_playerresults() {
  // @@protoc_insertion_point(field_add:EndOfHandShowCardsMessage.playerResults)
  return playerresults_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerResult >&
EndOfHandShowCardsMessage::playerresults() const {
  // @@protoc_insertion_point(field_list:EndOfHandShowCardsMessage.playerResults)
  return playerresults_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerResult >*
EndOfHandShowCardsMessage::mutable_playerresults() {
  // @@protoc_insertion_point(field_mutable_list:EndOfHandShowCardsMessage.playerResults)
  return &playerresults_;
}

// -------------------------------------------------------------------

// EndOfHandHideCardsMessage

// required uint32 gameId = 1;
inline bool EndOfHandHideCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndOfHandHideCardsMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndOfHandHideCardsMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndOfHandHideCardsMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.gameId)
  return gameid_;
}
inline void EndOfHandHideCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.gameId)
}

// required uint32 playerId = 2;
inline bool EndOfHandHideCardsMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndOfHandHideCardsMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndOfHandHideCardsMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndOfHandHideCardsMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::playerid() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.playerId)
  return playerid_;
}
inline void EndOfHandHideCardsMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.playerId)
}

// required uint32 moneyWon = 3;
inline bool EndOfHandHideCardsMessage::has_moneywon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EndOfHandHideCardsMessage::set_has_moneywon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EndOfHandHideCardsMessage::clear_has_moneywon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EndOfHandHideCardsMessage::clear_moneywon() {
  moneywon_ = 0u;
  clear_has_moneywon();
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::moneywon() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.moneyWon)
  return moneywon_;
}
inline void EndOfHandHideCardsMessage::set_moneywon(::google::protobuf::uint32 value) {
  set_has_moneywon();
  moneywon_ = value;
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.moneyWon)
}

// required uint32 playerMoney = 4;
inline bool EndOfHandHideCardsMessage::has_playermoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndOfHandHideCardsMessage::set_has_playermoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EndOfHandHideCardsMessage::clear_has_playermoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EndOfHandHideCardsMessage::clear_playermoney() {
  playermoney_ = 0u;
  clear_has_playermoney();
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::playermoney() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.playerMoney)
  return playermoney_;
}
inline void EndOfHandHideCardsMessage::set_playermoney(::google::protobuf::uint32 value) {
  set_has_playermoney();
  playermoney_ = value;
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.playerMoney)
}

// -------------------------------------------------------------------

// ShowMyCardsRequestMessage

// -------------------------------------------------------------------

// AfterHandShowCardsMessage

// required .PlayerResult playerResult = 1;
inline bool AfterHandShowCardsMessage::has_playerresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AfterHandShowCardsMessage::set_has_playerresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AfterHandShowCardsMessage::clear_has_playerresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AfterHandShowCardsMessage::clear_playerresult() {
  if (playerresult_ != NULL) playerresult_->::PlayerResult::Clear();
  clear_has_playerresult();
}
inline const ::PlayerResult& AfterHandShowCardsMessage::playerresult() const {
  // @@protoc_insertion_point(field_get:AfterHandShowCardsMessage.playerResult)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerresult_ != NULL ? *playerresult_ : *default_instance().playerresult_;
#else
  return playerresult_ != NULL ? *playerresult_ : *default_instance_->playerresult_;
#endif
}
inline ::PlayerResult* AfterHandShowCardsMessage::mutable_playerresult() {
  set_has_playerresult();
  if (playerresult_ == NULL) playerresult_ = new ::PlayerResult;
  // @@protoc_insertion_point(field_mutable:AfterHandShowCardsMessage.playerResult)
  return playerresult_;
}
inline ::PlayerResult* AfterHandShowCardsMessage::release_playerresult() {
  clear_has_playerresult();
  ::PlayerResult* temp = playerresult_;
  playerresult_ = NULL;
  return temp;
}
inline void AfterHandShowCardsMessage::set_allocated_playerresult(::PlayerResult* playerresult) {
  delete playerresult_;
  playerresult_ = playerresult;
  if (playerresult) {
    set_has_playerresult();
  } else {
    clear_has_playerresult();
  }
  // @@protoc_insertion_point(field_set_allocated:AfterHandShowCardsMessage.playerResult)
}

// -------------------------------------------------------------------

// EndOfGameMessage

// required uint32 gameId = 1;
inline bool EndOfGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndOfGameMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndOfGameMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndOfGameMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 EndOfGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndOfGameMessage.gameId)
  return gameid_;
}
inline void EndOfGameMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:EndOfGameMessage.gameId)
}

// required uint32 winnerPlayerId = 2;
inline bool EndOfGameMessage::has_winnerplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndOfGameMessage::set_has_winnerplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndOfGameMessage::clear_has_winnerplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndOfGameMessage::clear_winnerplayerid() {
  winnerplayerid_ = 0u;
  clear_has_winnerplayerid();
}
inline ::google::protobuf::uint32 EndOfGameMessage::winnerplayerid() const {
  // @@protoc_insertion_point(field_get:EndOfGameMessage.winnerPlayerId)
  return winnerplayerid_;
}
inline void EndOfGameMessage::set_winnerplayerid(::google::protobuf::uint32 value) {
  set_has_winnerplayerid();
  winnerplayerid_ = value;
  // @@protoc_insertion_point(field_set:EndOfGameMessage.winnerPlayerId)
}

// -------------------------------------------------------------------

// PlayerIdChangedMessage

// required uint32 oldPlayerId = 1;
inline bool PlayerIdChangedMessage::has_oldplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerIdChangedMessage::set_has_oldplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerIdChangedMessage::clear_has_oldplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerIdChangedMessage::clear_oldplayerid() {
  oldplayerid_ = 0u;
  clear_has_oldplayerid();
}
inline ::google::protobuf::uint32 PlayerIdChangedMessage::oldplayerid() const {
  // @@protoc_insertion_point(field_get:PlayerIdChangedMessage.oldPlayerId)
  return oldplayerid_;
}
inline void PlayerIdChangedMessage::set_oldplayerid(::google::protobuf::uint32 value) {
  set_has_oldplayerid();
  oldplayerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerIdChangedMessage.oldPlayerId)
}

// required uint32 newPlayerId = 2;
inline bool PlayerIdChangedMessage::has_newplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerIdChangedMessage::set_has_newplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerIdChangedMessage::clear_has_newplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerIdChangedMessage::clear_newplayerid() {
  newplayerid_ = 0u;
  clear_has_newplayerid();
}
inline ::google::protobuf::uint32 PlayerIdChangedMessage::newplayerid() const {
  // @@protoc_insertion_point(field_get:PlayerIdChangedMessage.newPlayerId)
  return newplayerid_;
}
inline void PlayerIdChangedMessage::set_newplayerid(::google::protobuf::uint32 value) {
  set_has_newplayerid();
  newplayerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerIdChangedMessage.newPlayerId)
}

// -------------------------------------------------------------------

// AskKickPlayerMessage

// required uint32 gameId = 1;
inline bool AskKickPlayerMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskKickPlayerMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskKickPlayerMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskKickPlayerMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 AskKickPlayerMessage::gameid() const {
  // @@protoc_insertion_point(field_get:AskKickPlayerMessage.gameId)
  return gameid_;
}
inline void AskKickPlayerMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:AskKickPlayerMessage.gameId)
}

// required uint32 playerId = 2;
inline bool AskKickPlayerMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskKickPlayerMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AskKickPlayerMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AskKickPlayerMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 AskKickPlayerMessage::playerid() const {
  // @@protoc_insertion_point(field_get:AskKickPlayerMessage.playerId)
  return playerid_;
}
inline void AskKickPlayerMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:AskKickPlayerMessage.playerId)
}

// -------------------------------------------------------------------

// AskKickDeniedMessage

// required uint32 gameId = 1;
inline bool AskKickDeniedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskKickDeniedMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskKickDeniedMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskKickDeniedMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 AskKickDeniedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:AskKickDeniedMessage.gameId)
  return gameid_;
}
inline void AskKickDeniedMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:AskKickDeniedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool AskKickDeniedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskKickDeniedMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AskKickDeniedMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AskKickDeniedMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 AskKickDeniedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:AskKickDeniedMessage.playerId)
  return playerid_;
}
inline void AskKickDeniedMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:AskKickDeniedMessage.playerId)
}

// required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
inline bool AskKickDeniedMessage::has_kickdeniedreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AskKickDeniedMessage::set_has_kickdeniedreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AskKickDeniedMessage::clear_has_kickdeniedreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AskKickDeniedMessage::clear_kickdeniedreason() {
  kickdeniedreason_ = 0;
  clear_has_kickdeniedreason();
}
inline ::AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::kickdeniedreason() const {
  // @@protoc_insertion_point(field_get:AskKickDeniedMessage.kickDeniedReason)
  return static_cast< ::AskKickDeniedMessage_KickDeniedReason >(kickdeniedreason_);
}
inline void AskKickDeniedMessage::set_kickdeniedreason(::AskKickDeniedMessage_KickDeniedReason value) {
  assert(::AskKickDeniedMessage_KickDeniedReason_IsValid(value));
  set_has_kickdeniedreason();
  kickdeniedreason_ = value;
  // @@protoc_insertion_point(field_set:AskKickDeniedMessage.kickDeniedReason)
}

// -------------------------------------------------------------------

// StartKickPetitionMessage

// required uint32 gameId = 1;
inline bool StartKickPetitionMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartKickPetitionMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartKickPetitionMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartKickPetitionMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::gameid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.gameId)
  return gameid_;
}
inline void StartKickPetitionMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool StartKickPetitionMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartKickPetitionMessage::set_has_petitionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartKickPetitionMessage::clear_has_petitionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartKickPetitionMessage::clear_petitionid() {
  petitionid_ = 0u;
  clear_has_petitionid();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.petitionId)
  return petitionid_;
}
inline void StartKickPetitionMessage::set_petitionid(::google::protobuf::uint32 value) {
  set_has_petitionid();
  petitionid_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.petitionId)
}

// required uint32 proposingPlayerId = 3;
inline bool StartKickPetitionMessage::has_proposingplayerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartKickPetitionMessage::set_has_proposingplayerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartKickPetitionMessage::clear_has_proposingplayerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartKickPetitionMessage::clear_proposingplayerid() {
  proposingplayerid_ = 0u;
  clear_has_proposingplayerid();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::proposingplayerid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.proposingPlayerId)
  return proposingplayerid_;
}
inline void StartKickPetitionMessage::set_proposingplayerid(::google::protobuf::uint32 value) {
  set_has_proposingplayerid();
  proposingplayerid_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.proposingPlayerId)
}

// required uint32 kickPlayerId = 4;
inline bool StartKickPetitionMessage::has_kickplayerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartKickPetitionMessage::set_has_kickplayerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartKickPetitionMessage::clear_has_kickplayerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartKickPetitionMessage::clear_kickplayerid() {
  kickplayerid_ = 0u;
  clear_has_kickplayerid();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::kickplayerid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.kickPlayerId)
  return kickplayerid_;
}
inline void StartKickPetitionMessage::set_kickplayerid(::google::protobuf::uint32 value) {
  set_has_kickplayerid();
  kickplayerid_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.kickPlayerId)
}

// required uint32 kickTimeoutSec = 5;
inline bool StartKickPetitionMessage::has_kicktimeoutsec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartKickPetitionMessage::set_has_kicktimeoutsec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartKickPetitionMessage::clear_has_kicktimeoutsec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartKickPetitionMessage::clear_kicktimeoutsec() {
  kicktimeoutsec_ = 0u;
  clear_has_kicktimeoutsec();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::kicktimeoutsec() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.kickTimeoutSec)
  return kicktimeoutsec_;
}
inline void StartKickPetitionMessage::set_kicktimeoutsec(::google::protobuf::uint32 value) {
  set_has_kicktimeoutsec();
  kicktimeoutsec_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.kickTimeoutSec)
}

// required uint32 numVotesNeededToKick = 6;
inline bool StartKickPetitionMessage::has_numvotesneededtokick() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartKickPetitionMessage::set_has_numvotesneededtokick() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StartKickPetitionMessage::clear_has_numvotesneededtokick() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StartKickPetitionMessage::clear_numvotesneededtokick() {
  numvotesneededtokick_ = 0u;
  clear_has_numvotesneededtokick();
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::numvotesneededtokick() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.numVotesNeededToKick)
  return numvotesneededtokick_;
}
inline void StartKickPetitionMessage::set_numvotesneededtokick(::google::protobuf::uint32 value) {
  set_has_numvotesneededtokick();
  numvotesneededtokick_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.numVotesNeededToKick)
}

// -------------------------------------------------------------------

// VoteKickRequestMessage

// required uint32 gameId = 1;
inline bool VoteKickRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoteKickRequestMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VoteKickRequestMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VoteKickRequestMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 VoteKickRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:VoteKickRequestMessage.gameId)
  return gameid_;
}
inline void VoteKickRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:VoteKickRequestMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool VoteKickRequestMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoteKickRequestMessage::set_has_petitionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VoteKickRequestMessage::clear_has_petitionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VoteKickRequestMessage::clear_petitionid() {
  petitionid_ = 0u;
  clear_has_petitionid();
}
inline ::google::protobuf::uint32 VoteKickRequestMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:VoteKickRequestMessage.petitionId)
  return petitionid_;
}
inline void VoteKickRequestMessage::set_petitionid(::google::protobuf::uint32 value) {
  set_has_petitionid();
  petitionid_ = value;
  // @@protoc_insertion_point(field_set:VoteKickRequestMessage.petitionId)
}

// required bool voteKick = 3;
inline bool VoteKickRequestMessage::has_votekick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VoteKickRequestMessage::set_has_votekick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VoteKickRequestMessage::clear_has_votekick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VoteKickRequestMessage::clear_votekick() {
  votekick_ = false;
  clear_has_votekick();
}
inline bool VoteKickRequestMessage::votekick() const {
  // @@protoc_insertion_point(field_get:VoteKickRequestMessage.voteKick)
  return votekick_;
}
inline void VoteKickRequestMessage::set_votekick(bool value) {
  set_has_votekick();
  votekick_ = value;
  // @@protoc_insertion_point(field_set:VoteKickRequestMessage.voteKick)
}

// -------------------------------------------------------------------

// VoteKickReplyMessage

// required uint32 gameId = 1;
inline bool VoteKickReplyMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoteKickReplyMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VoteKickReplyMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VoteKickReplyMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 VoteKickReplyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:VoteKickReplyMessage.gameId)
  return gameid_;
}
inline void VoteKickReplyMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:VoteKickReplyMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool VoteKickReplyMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoteKickReplyMessage::set_has_petitionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VoteKickReplyMessage::clear_has_petitionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VoteKickReplyMessage::clear_petitionid() {
  petitionid_ = 0u;
  clear_has_petitionid();
}
inline ::google::protobuf::uint32 VoteKickReplyMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:VoteKickReplyMessage.petitionId)
  return petitionid_;
}
inline void VoteKickReplyMessage::set_petitionid(::google::protobuf::uint32 value) {
  set_has_petitionid();
  petitionid_ = value;
  // @@protoc_insertion_point(field_set:VoteKickReplyMessage.petitionId)
}

// required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
inline bool VoteKickReplyMessage::has_votekickreplytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VoteKickReplyMessage::set_has_votekickreplytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VoteKickReplyMessage::clear_has_votekickreplytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VoteKickReplyMessage::clear_votekickreplytype() {
  votekickreplytype_ = 0;
  clear_has_votekickreplytype();
}
inline ::VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage::votekickreplytype() const {
  // @@protoc_insertion_point(field_get:VoteKickReplyMessage.voteKickReplyType)
  return static_cast< ::VoteKickReplyMessage_VoteKickReplyType >(votekickreplytype_);
}
inline void VoteKickReplyMessage::set_votekickreplytype(::VoteKickReplyMessage_VoteKickReplyType value) {
  assert(::VoteKickReplyMessage_VoteKickReplyType_IsValid(value));
  set_has_votekickreplytype();
  votekickreplytype_ = value;
  // @@protoc_insertion_point(field_set:VoteKickReplyMessage.voteKickReplyType)
}

// -------------------------------------------------------------------

// KickPetitionUpdateMessage

// required uint32 gameId = 1;
inline bool KickPetitionUpdateMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickPetitionUpdateMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickPetitionUpdateMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickPetitionUpdateMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::gameid() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.gameId)
  return gameid_;
}
inline void KickPetitionUpdateMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool KickPetitionUpdateMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickPetitionUpdateMessage::set_has_petitionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickPetitionUpdateMessage::clear_has_petitionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickPetitionUpdateMessage::clear_petitionid() {
  petitionid_ = 0u;
  clear_has_petitionid();
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.petitionId)
  return petitionid_;
}
inline void KickPetitionUpdateMessage::set_petitionid(::google::protobuf::uint32 value) {
  set_has_petitionid();
  petitionid_ = value;
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.petitionId)
}

// required uint32 numVotesAgainstKicking = 3;
inline bool KickPetitionUpdateMessage::has_numvotesagainstkicking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KickPetitionUpdateMessage::set_has_numvotesagainstkicking() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KickPetitionUpdateMessage::clear_has_numvotesagainstkicking() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KickPetitionUpdateMessage::clear_numvotesagainstkicking() {
  numvotesagainstkicking_ = 0u;
  clear_has_numvotesagainstkicking();
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::numvotesagainstkicking() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.numVotesAgainstKicking)
  return numvotesagainstkicking_;
}
inline void KickPetitionUpdateMessage::set_numvotesagainstkicking(::google::protobuf::uint32 value) {
  set_has_numvotesagainstkicking();
  numvotesagainstkicking_ = value;
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.numVotesAgainstKicking)
}

// required uint32 numVotesInFavourOfKicking = 4;
inline bool KickPetitionUpdateMessage::has_numvotesinfavourofkicking() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KickPetitionUpdateMessage::set_has_numvotesinfavourofkicking() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KickPetitionUpdateMessage::clear_has_numvotesinfavourofkicking() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KickPetitionUpdateMessage::clear_numvotesinfavourofkicking() {
  numvotesinfavourofkicking_ = 0u;
  clear_has_numvotesinfavourofkicking();
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::numvotesinfavourofkicking() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.numVotesInFavourOfKicking)
  return numvotesinfavourofkicking_;
}
inline void KickPetitionUpdateMessage::set_numvotesinfavourofkicking(::google::protobuf::uint32 value) {
  set_has_numvotesinfavourofkicking();
  numvotesinfavourofkicking_ = value;
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.numVotesInFavourOfKicking)
}

// required uint32 numVotesNeededToKick = 5;
inline bool KickPetitionUpdateMessage::has_numvotesneededtokick() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KickPetitionUpdateMessage::set_has_numvotesneededtokick() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KickPetitionUpdateMessage::clear_has_numvotesneededtokick() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KickPetitionUpdateMessage::clear_numvotesneededtokick() {
  numvotesneededtokick_ = 0u;
  clear_has_numvotesneededtokick();
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::numvotesneededtokick() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.numVotesNeededToKick)
  return numvotesneededtokick_;
}
inline void KickPetitionUpdateMessage::set_numvotesneededtokick(::google::protobuf::uint32 value) {
  set_has_numvotesneededtokick();
  numvotesneededtokick_ = value;
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.numVotesNeededToKick)
}

// -------------------------------------------------------------------

// EndKickPetitionMessage

// required uint32 gameId = 1;
inline bool EndKickPetitionMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndKickPetitionMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndKickPetitionMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndKickPetitionMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.gameId)
  return gameid_;
}
inline void EndKickPetitionMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool EndKickPetitionMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndKickPetitionMessage::set_has_petitionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndKickPetitionMessage::clear_has_petitionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndKickPetitionMessage::clear_petitionid() {
  petitionid_ = 0u;
  clear_has_petitionid();
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.petitionId)
  return petitionid_;
}
inline void EndKickPetitionMessage::set_petitionid(::google::protobuf::uint32 value) {
  set_has_petitionid();
  petitionid_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.petitionId)
}

// required uint32 numVotesAgainstKicking = 3;
inline bool EndKickPetitionMessage::has_numvotesagainstkicking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EndKickPetitionMessage::set_has_numvotesagainstkicking() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EndKickPetitionMessage::clear_has_numvotesagainstkicking() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EndKickPetitionMessage::clear_numvotesagainstkicking() {
  numvotesagainstkicking_ = 0u;
  clear_has_numvotesagainstkicking();
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::numvotesagainstkicking() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.numVotesAgainstKicking)
  return numvotesagainstkicking_;
}
inline void EndKickPetitionMessage::set_numvotesagainstkicking(::google::protobuf::uint32 value) {
  set_has_numvotesagainstkicking();
  numvotesagainstkicking_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.numVotesAgainstKicking)
}

// required uint32 numVotesInFavourOfKicking = 4;
inline bool EndKickPetitionMessage::has_numvotesinfavourofkicking() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndKickPetitionMessage::set_has_numvotesinfavourofkicking() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EndKickPetitionMessage::clear_has_numvotesinfavourofkicking() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EndKickPetitionMessage::clear_numvotesinfavourofkicking() {
  numvotesinfavourofkicking_ = 0u;
  clear_has_numvotesinfavourofkicking();
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::numvotesinfavourofkicking() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.numVotesInFavourOfKicking)
  return numvotesinfavourofkicking_;
}
inline void EndKickPetitionMessage::set_numvotesinfavourofkicking(::google::protobuf::uint32 value) {
  set_has_numvotesinfavourofkicking();
  numvotesinfavourofkicking_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.numVotesInFavourOfKicking)
}

// required uint32 resultPlayerKicked = 5;
inline bool EndKickPetitionMessage::has_resultplayerkicked() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EndKickPetitionMessage::set_has_resultplayerkicked() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EndKickPetitionMessage::clear_has_resultplayerkicked() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EndKickPetitionMessage::clear_resultplayerkicked() {
  resultplayerkicked_ = 0u;
  clear_has_resultplayerkicked();
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::resultplayerkicked() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.resultPlayerKicked)
  return resultplayerkicked_;
}
inline void EndKickPetitionMessage::set_resultplayerkicked(::google::protobuf::uint32 value) {
  set_has_resultplayerkicked();
  resultplayerkicked_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.resultPlayerKicked)
}

// required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
inline bool EndKickPetitionMessage::has_petitionendreason() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EndKickPetitionMessage::set_has_petitionendreason() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EndKickPetitionMessage::clear_has_petitionendreason() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EndKickPetitionMessage::clear_petitionendreason() {
  petitionendreason_ = 0;
  clear_has_petitionendreason();
}
inline ::EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::petitionendreason() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.petitionEndReason)
  return static_cast< ::EndKickPetitionMessage_PetitionEndReason >(petitionendreason_);
}
inline void EndKickPetitionMessage::set_petitionendreason(::EndKickPetitionMessage_PetitionEndReason value) {
  assert(::EndKickPetitionMessage_PetitionEndReason_IsValid(value));
  set_has_petitionendreason();
  petitionendreason_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.petitionEndReason)
}

// -------------------------------------------------------------------

// StatisticsMessage_StatisticsData

// required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
inline bool StatisticsMessage_StatisticsData::has_statisticstype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatisticsMessage_StatisticsData::set_has_statisticstype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatisticsMessage_StatisticsData::clear_has_statisticstype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatisticsMessage_StatisticsData::clear_statisticstype() {
  statisticstype_ = 1;
  clear_has_statisticstype();
}
inline ::StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData::statisticstype() const {
  // @@protoc_insertion_point(field_get:StatisticsMessage.StatisticsData.statisticsType)
  return static_cast< ::StatisticsMessage_StatisticsData_StatisticsType >(statisticstype_);
}
inline void StatisticsMessage_StatisticsData::set_statisticstype(::StatisticsMessage_StatisticsData_StatisticsType value) {
  assert(::StatisticsMessage_StatisticsData_StatisticsType_IsValid(value));
  set_has_statisticstype();
  statisticstype_ = value;
  // @@protoc_insertion_point(field_set:StatisticsMessage.StatisticsData.statisticsType)
}

// required uint32 statisticsValue = 2;
inline bool StatisticsMessage_StatisticsData::has_statisticsvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatisticsMessage_StatisticsData::set_has_statisticsvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatisticsMessage_StatisticsData::clear_has_statisticsvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatisticsMessage_StatisticsData::clear_statisticsvalue() {
  statisticsvalue_ = 0u;
  clear_has_statisticsvalue();
}
inline ::google::protobuf::uint32 StatisticsMessage_StatisticsData::statisticsvalue() const {
  // @@protoc_insertion_point(field_get:StatisticsMessage.StatisticsData.statisticsValue)
  return statisticsvalue_;
}
inline void StatisticsMessage_StatisticsData::set_statisticsvalue(::google::protobuf::uint32 value) {
  set_has_statisticsvalue();
  statisticsvalue_ = value;
  // @@protoc_insertion_point(field_set:StatisticsMessage.StatisticsData.statisticsValue)
}

// -------------------------------------------------------------------

// StatisticsMessage

// repeated .StatisticsMessage.StatisticsData statisticsData = 1;
inline int StatisticsMessage::statisticsdata_size() const {
  return statisticsdata_.size();
}
inline void StatisticsMessage::clear_statisticsdata() {
  statisticsdata_.Clear();
}
inline const ::StatisticsMessage_StatisticsData& StatisticsMessage::statisticsdata(int index) const {
  // @@protoc_insertion_point(field_get:StatisticsMessage.statisticsData)
  return statisticsdata_.Get(index);
}
inline ::StatisticsMessage_StatisticsData* StatisticsMessage::mutable_statisticsdata(int index) {
  // @@protoc_insertion_point(field_mutable:StatisticsMessage.statisticsData)
  return statisticsdata_.Mutable(index);
}
inline ::StatisticsMessage_StatisticsData* StatisticsMessage::add_statisticsdata() {
  // @@protoc_insertion_point(field_add:StatisticsMessage.statisticsData)
  return statisticsdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >&
StatisticsMessage::statisticsdata() const {
  // @@protoc_insertion_point(field_list:StatisticsMessage.statisticsData)
  return statisticsdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >*
StatisticsMessage::mutable_statisticsdata() {
  // @@protoc_insertion_point(field_mutable_list:StatisticsMessage.statisticsData)
  return &statisticsdata_;
}

// -------------------------------------------------------------------

// ChatRequestMessage

// optional uint32 targetGameId = 1;
inline bool ChatRequestMessage::has_targetgameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRequestMessage::set_has_targetgameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRequestMessage::clear_has_targetgameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRequestMessage::clear_targetgameid() {
  targetgameid_ = 0u;
  clear_has_targetgameid();
}
inline ::google::protobuf::uint32 ChatRequestMessage::targetgameid() const {
  // @@protoc_insertion_point(field_get:ChatRequestMessage.targetGameId)
  return targetgameid_;
}
inline void ChatRequestMessage::set_targetgameid(::google::protobuf::uint32 value) {
  set_has_targetgameid();
  targetgameid_ = value;
  // @@protoc_insertion_point(field_set:ChatRequestMessage.targetGameId)
}

// optional uint32 targetPlayerId = 2;
inline bool ChatRequestMessage::has_targetplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRequestMessage::set_has_targetplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatRequestMessage::clear_has_targetplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatRequestMessage::clear_targetplayerid() {
  targetplayerid_ = 0u;
  clear_has_targetplayerid();
}
inline ::google::protobuf::uint32 ChatRequestMessage::targetplayerid() const {
  // @@protoc_insertion_point(field_get:ChatRequestMessage.targetPlayerId)
  return targetplayerid_;
}
inline void ChatRequestMessage::set_targetplayerid(::google::protobuf::uint32 value) {
  set_has_targetplayerid();
  targetplayerid_ = value;
  // @@protoc_insertion_point(field_set:ChatRequestMessage.targetPlayerId)
}

// required string chatText = 3;
inline bool ChatRequestMessage::has_chattext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatRequestMessage::set_has_chattext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatRequestMessage::clear_has_chattext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatRequestMessage::clear_chattext() {
  if (chattext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_->clear();
  }
  clear_has_chattext();
}
inline const ::std::string& ChatRequestMessage::chattext() const {
  // @@protoc_insertion_point(field_get:ChatRequestMessage.chatText)
  return *chattext_;
}
inline void ChatRequestMessage::set_chattext(const ::std::string& value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
  // @@protoc_insertion_point(field_set:ChatRequestMessage.chatText)
}
inline void ChatRequestMessage::set_chattext(const char* value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
  // @@protoc_insertion_point(field_set_char:ChatRequestMessage.chatText)
}
inline void ChatRequestMessage::set_chattext(const char* value, size_t size) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChatRequestMessage.chatText)
}
inline ::std::string* ChatRequestMessage::mutable_chattext() {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ChatRequestMessage.chatText)
  return chattext_;
}
inline ::std::string* ChatRequestMessage::release_chattext() {
  clear_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = chattext_;
    chattext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatRequestMessage::set_allocated_chattext(::std::string* chattext) {
  if (chattext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete chattext_;
  }
  if (chattext) {
    set_has_chattext();
    chattext_ = chattext;
  } else {
    clear_has_chattext();
    chattext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ChatRequestMessage.chatText)
}

// -------------------------------------------------------------------

// ChatMessage

// optional uint32 gameId = 1;
inline bool ChatMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMessage::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMessage::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMessage::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 ChatMessage::gameid() const {
  // @@protoc_insertion_point(field_get:ChatMessage.gameId)
  return gameid_;
}
inline void ChatMessage::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:ChatMessage.gameId)
}

// optional uint32 playerId = 2;
inline bool ChatMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMessage::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMessage::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMessage::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 ChatMessage::playerid() const {
  // @@protoc_insertion_point(field_get:ChatMessage.playerId)
  return playerid_;
}
inline void ChatMessage::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:ChatMessage.playerId)
}

// required .ChatMessage.ChatType chatType = 3;
inline bool ChatMessage::has_chattype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatMessage::set_has_chattype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatMessage::clear_has_chattype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatMessage::clear_chattype() {
  chattype_ = 0;
  clear_has_chattype();
}
inline ::ChatMessage_ChatType ChatMessage::chattype() const {
  // @@protoc_insertion_point(field_get:ChatMessage.chatType)
  return static_cast< ::ChatMessage_ChatType >(chattype_);
}
inline void ChatMessage::set_chattype(::ChatMessage_ChatType value) {
  assert(::ChatMessage_ChatType_IsValid(value));
  set_has_chattype();
  chattype_ = value;
  // @@protoc_insertion_point(field_set:ChatMessage.chatType)
}

// required string chatText = 4;
inline bool ChatMessage::has_chattext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatMessage::set_has_chattext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatMessage::clear_has_chattext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatMessage::clear_chattext() {
  if (chattext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_->clear();
  }
  clear_has_chattext();
}
inline const ::std::string& ChatMessage::chattext() const {
  // @@protoc_insertion_point(field_get:ChatMessage.chatText)
  return *chattext_;
}
inline void ChatMessage::set_chattext(const ::std::string& value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
  // @@protoc_insertion_point(field_set:ChatMessage.chatText)
}
inline void ChatMessage::set_chattext(const char* value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
  // @@protoc_insertion_point(field_set_char:ChatMessage.chatText)
}
inline void ChatMessage::set_chattext(const char* value, size_t size) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChatMessage.chatText)
}
inline ::std::string* ChatMessage::mutable_chattext() {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ChatMessage.chatText)
  return chattext_;
}
inline ::std::string* ChatMessage::release_chattext() {
  clear_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = chattext_;
    chattext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatMessage::set_allocated_chattext(::std::string* chattext) {
  if (chattext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete chattext_;
  }
  if (chattext) {
    set_has_chattext();
    chattext_ = chattext;
  } else {
    clear_has_chattext();
    chattext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ChatMessage.chatText)
}

// -------------------------------------------------------------------

// ChatRejectMessage

// required string chatText = 1;
inline bool ChatRejectMessage::has_chattext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRejectMessage::set_has_chattext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRejectMessage::clear_has_chattext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRejectMessage::clear_chattext() {
  if (chattext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_->clear();
  }
  clear_has_chattext();
}
inline const ::std::string& ChatRejectMessage::chattext() const {
  // @@protoc_insertion_point(field_get:ChatRejectMessage.chatText)
  return *chattext_;
}
inline void ChatRejectMessage::set_chattext(const ::std::string& value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
  // @@protoc_insertion_point(field_set:ChatRejectMessage.chatText)
}
inline void ChatRejectMessage::set_chattext(const char* value) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(value);
  // @@protoc_insertion_point(field_set_char:ChatRejectMessage.chatText)
}
inline void ChatRejectMessage::set_chattext(const char* value, size_t size) {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  chattext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChatRejectMessage.chatText)
}
inline ::std::string* ChatRejectMessage::mutable_chattext() {
  set_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chattext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ChatRejectMessage.chatText)
  return chattext_;
}
inline ::std::string* ChatRejectMessage::release_chattext() {
  clear_has_chattext();
  if (chattext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = chattext_;
    chattext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatRejectMessage::set_allocated_chattext(::std::string* chattext) {
  if (chattext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete chattext_;
  }
  if (chattext) {
    set_has_chattext();
    chattext_ = chattext;
  } else {
    clear_has_chattext();
    chattext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ChatRejectMessage.chatText)
}

// -------------------------------------------------------------------

// DialogMessage

// required string notificationText = 1;
inline bool DialogMessage::has_notificationtext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DialogMessage::set_has_notificationtext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DialogMessage::clear_has_notificationtext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DialogMessage::clear_notificationtext() {
  if (notificationtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notificationtext_->clear();
  }
  clear_has_notificationtext();
}
inline const ::std::string& DialogMessage::notificationtext() const {
  // @@protoc_insertion_point(field_get:DialogMessage.notificationText)
  return *notificationtext_;
}
inline void DialogMessage::set_notificationtext(const ::std::string& value) {
  set_has_notificationtext();
  if (notificationtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notificationtext_ = new ::std::string;
  }
  notificationtext_->assign(value);
  // @@protoc_insertion_point(field_set:DialogMessage.notificationText)
}
inline void DialogMessage::set_notificationtext(const char* value) {
  set_has_notificationtext();
  if (notificationtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notificationtext_ = new ::std::string;
  }
  notificationtext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DialogMessage.notificationText)
}
inline void DialogMessage::set_notificationtext(const char* value, size_t size) {
  set_has_notificationtext();
  if (notificationtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notificationtext_ = new ::std::string;
  }
  notificationtext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DialogMessage.notificationText)
}
inline ::std::string* DialogMessage::mutable_notificationtext() {
  set_has_notificationtext();
  if (notificationtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notificationtext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DialogMessage.notificationText)
  return notificationtext_;
}
inline ::std::string* DialogMessage::release_notificationtext() {
  clear_has_notificationtext();
  if (notificationtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = notificationtext_;
    notificationtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DialogMessage::set_allocated_notificationtext(::std::string* notificationtext) {
  if (notificationtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete notificationtext_;
  }
  if (notificationtext) {
    set_has_notificationtext();
    notificationtext_ = notificationtext;
  } else {
    clear_has_notificationtext();
    notificationtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DialogMessage.notificationText)
}

// -------------------------------------------------------------------

// TimeoutWarningMessage

// required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
inline bool TimeoutWarningMessage::has_timeoutreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeoutWarningMessage::set_has_timeoutreason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeoutWarningMessage::clear_has_timeoutreason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeoutWarningMessage::clear_timeoutreason() {
  timeoutreason_ = 0;
  clear_has_timeoutreason();
}
inline ::TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage::timeoutreason() const {
  // @@protoc_insertion_point(field_get:TimeoutWarningMessage.timeoutReason)
  return static_cast< ::TimeoutWarningMessage_TimeoutReason >(timeoutreason_);
}
inline void TimeoutWarningMessage::set_timeoutreason(::TimeoutWarningMessage_TimeoutReason value) {
  assert(::TimeoutWarningMessage_TimeoutReason_IsValid(value));
  set_has_timeoutreason();
  timeoutreason_ = value;
  // @@protoc_insertion_point(field_set:TimeoutWarningMessage.timeoutReason)
}

// required uint32 remainingSeconds = 2;
inline bool TimeoutWarningMessage::has_remainingseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeoutWarningMessage::set_has_remainingseconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeoutWarningMessage::clear_has_remainingseconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeoutWarningMessage::clear_remainingseconds() {
  remainingseconds_ = 0u;
  clear_has_remainingseconds();
}
inline ::google::protobuf::uint32 TimeoutWarningMessage::remainingseconds() const {
  // @@protoc_insertion_point(field_get:TimeoutWarningMessage.remainingSeconds)
  return remainingseconds_;
}
inline void TimeoutWarningMessage::set_remainingseconds(::google::protobuf::uint32 value) {
  set_has_remainingseconds();
  remainingseconds_ = value;
  // @@protoc_insertion_point(field_set:TimeoutWarningMessage.remainingSeconds)
}

// -------------------------------------------------------------------

// ResetTimeoutMessage

// -------------------------------------------------------------------

// ReportAvatarMessage

// required uint32 reportedPlayerId = 1;
inline bool ReportAvatarMessage::has_reportedplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportAvatarMessage::set_has_reportedplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportAvatarMessage::clear_has_reportedplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportAvatarMessage::clear_reportedplayerid() {
  reportedplayerid_ = 0u;
  clear_has_reportedplayerid();
}
inline ::google::protobuf::uint32 ReportAvatarMessage::reportedplayerid() const {
  // @@protoc_insertion_point(field_get:ReportAvatarMessage.reportedPlayerId)
  return reportedplayerid_;
}
inline void ReportAvatarMessage::set_reportedplayerid(::google::protobuf::uint32 value) {
  set_has_reportedplayerid();
  reportedplayerid_ = value;
  // @@protoc_insertion_point(field_set:ReportAvatarMessage.reportedPlayerId)
}

// required bytes reportedAvatarHash = 2;
inline bool ReportAvatarMessage::has_reportedavatarhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportAvatarMessage::set_has_reportedavatarhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportAvatarMessage::clear_has_reportedavatarhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportAvatarMessage::clear_reportedavatarhash() {
  if (reportedavatarhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reportedavatarhash_->clear();
  }
  clear_has_reportedavatarhash();
}
inline const ::std::string& ReportAvatarMessage::reportedavatarhash() const {
  // @@protoc_insertion_point(field_get:ReportAvatarMessage.reportedAvatarHash)
  return *reportedavatarhash_;
}
inline void ReportAvatarMessage::set_reportedavatarhash(const ::std::string& value) {
  set_has_reportedavatarhash();
  if (reportedavatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reportedavatarhash_ = new ::std::string;
  }
  reportedavatarhash_->assign(value);
  // @@protoc_insertion_point(field_set:ReportAvatarMessage.reportedAvatarHash)
}
inline void ReportAvatarMessage::set_reportedavatarhash(const char* value) {
  set_has_reportedavatarhash();
  if (reportedavatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reportedavatarhash_ = new ::std::string;
  }
  reportedavatarhash_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReportAvatarMessage.reportedAvatarHash)
}
inline void ReportAvatarMessage::set_reportedavatarhash(const void* value, size_t size) {
  set_has_reportedavatarhash();
  if (reportedavatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reportedavatarhash_ = new ::std::string;
  }
  reportedavatarhash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReportAvatarMessage.reportedAvatarHash)
}
inline ::std::string* ReportAvatarMessage::mutable_reportedavatarhash() {
  set_has_reportedavatarhash();
  if (reportedavatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reportedavatarhash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReportAvatarMessage.reportedAvatarHash)
  return reportedavatarhash_;
}
inline ::std::string* ReportAvatarMessage::release_reportedavatarhash() {
  clear_has_reportedavatarhash();
  if (reportedavatarhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reportedavatarhash_;
    reportedavatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReportAvatarMessage::set_allocated_reportedavatarhash(::std::string* reportedavatarhash) {
  if (reportedavatarhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reportedavatarhash_;
  }
  if (reportedavatarhash) {
    set_has_reportedavatarhash();
    reportedavatarhash_ = reportedavatarhash;
  } else {
    clear_has_reportedavatarhash();
    reportedavatarhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReportAvatarMessage.reportedAvatarHash)
}

// -------------------------------------------------------------------

// ReportAvatarAckMessage

// required uint32 reportedPlayerId = 1;
inline bool ReportAvatarAckMessage::has_reportedplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportAvatarAckMessage::set_has_reportedplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportAvatarAckMessage::clear_has_reportedplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportAvatarAckMessage::clear_reportedplayerid() {
  reportedplayerid_ = 0u;
  clear_has_reportedplayerid();
}
inline ::google::protobuf::uint32 ReportAvatarAckMessage::reportedplayerid() const {
  // @@protoc_insertion_point(field_get:ReportAvatarAckMessage.reportedPlayerId)
  return reportedplayerid_;
}
inline void ReportAvatarAckMessage::set_reportedplayerid(::google::protobuf::uint32 value) {
  set_has_reportedplayerid();
  reportedplayerid_ = value;
  // @@protoc_insertion_point(field_set:ReportAvatarAckMessage.reportedPlayerId)
}

// required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
inline bool ReportAvatarAckMessage::has_reportavatarresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportAvatarAckMessage::set_has_reportavatarresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportAvatarAckMessage::clear_has_reportavatarresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportAvatarAckMessage::clear_reportavatarresult() {
  reportavatarresult_ = 0;
  clear_has_reportavatarresult();
}
inline ::ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage::reportavatarresult() const {
  // @@protoc_insertion_point(field_get:ReportAvatarAckMessage.reportAvatarResult)
  return static_cast< ::ReportAvatarAckMessage_ReportAvatarResult >(reportavatarresult_);
}
inline void ReportAvatarAckMessage::set_reportavatarresult(::ReportAvatarAckMessage_ReportAvatarResult value) {
  assert(::ReportAvatarAckMessage_ReportAvatarResult_IsValid(value));
  set_has_reportavatarresult();
  reportavatarresult_ = value;
  // @@protoc_insertion_point(field_set:ReportAvatarAckMessage.reportAvatarResult)
}

// -------------------------------------------------------------------

// ReportGameMessage

// required uint32 reportedGameId = 1;
inline bool ReportGameMessage::has_reportedgameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportGameMessage::set_has_reportedgameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportGameMessage::clear_has_reportedgameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportGameMessage::clear_reportedgameid() {
  reportedgameid_ = 0u;
  clear_has_reportedgameid();
}
inline ::google::protobuf::uint32 ReportGameMessage::reportedgameid() const {
  // @@protoc_insertion_point(field_get:ReportGameMessage.reportedGameId)
  return reportedgameid_;
}
inline void ReportGameMessage::set_reportedgameid(::google::protobuf::uint32 value) {
  set_has_reportedgameid();
  reportedgameid_ = value;
  // @@protoc_insertion_point(field_set:ReportGameMessage.reportedGameId)
}

// -------------------------------------------------------------------

// ReportGameAckMessage

// required uint32 reportedGameId = 1;
inline bool ReportGameAckMessage::has_reportedgameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportGameAckMessage::set_has_reportedgameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportGameAckMessage::clear_has_reportedgameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportGameAckMessage::clear_reportedgameid() {
  reportedgameid_ = 0u;
  clear_has_reportedgameid();
}
inline ::google::protobuf::uint32 ReportGameAckMessage::reportedgameid() const {
  // @@protoc_insertion_point(field_get:ReportGameAckMessage.reportedGameId)
  return reportedgameid_;
}
inline void ReportGameAckMessage::set_reportedgameid(::google::protobuf::uint32 value) {
  set_has_reportedgameid();
  reportedgameid_ = value;
  // @@protoc_insertion_point(field_set:ReportGameAckMessage.reportedGameId)
}

// required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
inline bool ReportGameAckMessage::has_reportgameresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportGameAckMessage::set_has_reportgameresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportGameAckMessage::clear_has_reportgameresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportGameAckMessage::clear_reportgameresult() {
  reportgameresult_ = 0;
  clear_has_reportgameresult();
}
inline ::ReportGameAckMessage_ReportGameResult ReportGameAckMessage::reportgameresult() const {
  // @@protoc_insertion_point(field_get:ReportGameAckMessage.reportGameResult)
  return static_cast< ::ReportGameAckMessage_ReportGameResult >(reportgameresult_);
}
inline void ReportGameAckMessage::set_reportgameresult(::ReportGameAckMessage_ReportGameResult value) {
  assert(::ReportGameAckMessage_ReportGameResult_IsValid(value));
  set_has_reportgameresult();
  reportgameresult_ = value;
  // @@protoc_insertion_point(field_set:ReportGameAckMessage.reportGameResult)
}

// -------------------------------------------------------------------

// ErrorMessage

// required .ErrorMessage.ErrorReason errorReason = 1;
inline bool ErrorMessage::has_errorreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorMessage::set_has_errorreason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorMessage::clear_has_errorreason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorMessage::clear_errorreason() {
  errorreason_ = 0;
  clear_has_errorreason();
}
inline ::ErrorMessage_ErrorReason ErrorMessage::errorreason() const {
  // @@protoc_insertion_point(field_get:ErrorMessage.errorReason)
  return static_cast< ::ErrorMessage_ErrorReason >(errorreason_);
}
inline void ErrorMessage::set_errorreason(::ErrorMessage_ErrorReason value) {
  assert(::ErrorMessage_ErrorReason_IsValid(value));
  set_has_errorreason();
  errorreason_ = value;
  // @@protoc_insertion_point(field_set:ErrorMessage.errorReason)
}

// -------------------------------------------------------------------

// AdminRemoveGameMessage

// required uint32 removeGameId = 1;
inline bool AdminRemoveGameMessage::has_removegameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminRemoveGameMessage::set_has_removegameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminRemoveGameMessage::clear_has_removegameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminRemoveGameMessage::clear_removegameid() {
  removegameid_ = 0u;
  clear_has_removegameid();
}
inline ::google::protobuf::uint32 AdminRemoveGameMessage::removegameid() const {
  // @@protoc_insertion_point(field_get:AdminRemoveGameMessage.removeGameId)
  return removegameid_;
}
inline void AdminRemoveGameMessage::set_removegameid(::google::protobuf::uint32 value) {
  set_has_removegameid();
  removegameid_ = value;
  // @@protoc_insertion_point(field_set:AdminRemoveGameMessage.removeGameId)
}

// -------------------------------------------------------------------

// AdminRemoveGameAckMessage

// required uint32 removeGameId = 1;
inline bool AdminRemoveGameAckMessage::has_removegameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminRemoveGameAckMessage::set_has_removegameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminRemoveGameAckMessage::clear_has_removegameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminRemoveGameAckMessage::clear_removegameid() {
  removegameid_ = 0u;
  clear_has_removegameid();
}
inline ::google::protobuf::uint32 AdminRemoveGameAckMessage::removegameid() const {
  // @@protoc_insertion_point(field_get:AdminRemoveGameAckMessage.removeGameId)
  return removegameid_;
}
inline void AdminRemoveGameAckMessage::set_removegameid(::google::protobuf::uint32 value) {
  set_has_removegameid();
  removegameid_ = value;
  // @@protoc_insertion_point(field_set:AdminRemoveGameAckMessage.removeGameId)
}

// required .AdminRemoveGameAckMessage.AdminRemoveGameResult removeGameResult = 2;
inline bool AdminRemoveGameAckMessage::has_removegameresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminRemoveGameAckMessage::set_has_removegameresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminRemoveGameAckMessage::clear_has_removegameresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminRemoveGameAckMessage::clear_removegameresult() {
  removegameresult_ = 0;
  clear_has_removegameresult();
}
inline ::AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage::removegameresult() const {
  // @@protoc_insertion_point(field_get:AdminRemoveGameAckMessage.removeGameResult)
  return static_cast< ::AdminRemoveGameAckMessage_AdminRemoveGameResult >(removegameresult_);
}
inline void AdminRemoveGameAckMessage::set_removegameresult(::AdminRemoveGameAckMessage_AdminRemoveGameResult value) {
  assert(::AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(value));
  set_has_removegameresult();
  removegameresult_ = value;
  // @@protoc_insertion_point(field_set:AdminRemoveGameAckMessage.removeGameResult)
}

// -------------------------------------------------------------------

// AdminBanPlayerMessage

// required uint32 banPlayerId = 1;
inline bool AdminBanPlayerMessage::has_banplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminBanPlayerMessage::set_has_banplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminBanPlayerMessage::clear_has_banplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminBanPlayerMessage::clear_banplayerid() {
  banplayerid_ = 0u;
  clear_has_banplayerid();
}
inline ::google::protobuf::uint32 AdminBanPlayerMessage::banplayerid() const {
  // @@protoc_insertion_point(field_get:AdminBanPlayerMessage.banPlayerId)
  return banplayerid_;
}
inline void AdminBanPlayerMessage::set_banplayerid(::google::protobuf::uint32 value) {
  set_has_banplayerid();
  banplayerid_ = value;
  // @@protoc_insertion_point(field_set:AdminBanPlayerMessage.banPlayerId)
}

// -------------------------------------------------------------------

// AdminBanPlayerAckMessage

// required uint32 banPlayerId = 1;
inline bool AdminBanPlayerAckMessage::has_banplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminBanPlayerAckMessage::set_has_banplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminBanPlayerAckMessage::clear_has_banplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminBanPlayerAckMessage::clear_banplayerid() {
  banplayerid_ = 0u;
  clear_has_banplayerid();
}
inline ::google::protobuf::uint32 AdminBanPlayerAckMessage::banplayerid() const {
  // @@protoc_insertion_point(field_get:AdminBanPlayerAckMessage.banPlayerId)
  return banplayerid_;
}
inline void AdminBanPlayerAckMessage::set_banplayerid(::google::protobuf::uint32 value) {
  set_has_banplayerid();
  banplayerid_ = value;
  // @@protoc_insertion_point(field_set:AdminBanPlayerAckMessage.banPlayerId)
}

// required .AdminBanPlayerAckMessage.AdminBanPlayerResult banPlayerResult = 2;
inline bool AdminBanPlayerAckMessage::has_banplayerresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminBanPlayerAckMessage::set_has_banplayerresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminBanPlayerAckMessage::clear_has_banplayerresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminBanPlayerAckMessage::clear_banplayerresult() {
  banplayerresult_ = 0;
  clear_has_banplayerresult();
}
inline ::AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::banplayerresult() const {
  // @@protoc_insertion_point(field_get:AdminBanPlayerAckMessage.banPlayerResult)
  return static_cast< ::AdminBanPlayerAckMessage_AdminBanPlayerResult >(banplayerresult_);
}
inline void AdminBanPlayerAckMessage::set_banplayerresult(::AdminBanPlayerAckMessage_AdminBanPlayerResult value) {
  assert(::AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(value));
  set_has_banplayerresult();
  banplayerresult_ = value;
  // @@protoc_insertion_point(field_set:AdminBanPlayerAckMessage.banPlayerResult)
}

// -------------------------------------------------------------------

// PokerTHMessage

// required .PokerTHMessage.PokerTHMessageType messageType = 1;
inline bool PokerTHMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PokerTHMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PokerTHMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PokerTHMessage::clear_messagetype() {
  messagetype_ = 1;
  clear_has_messagetype();
}
inline ::PokerTHMessage_PokerTHMessageType PokerTHMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.messageType)
  return static_cast< ::PokerTHMessage_PokerTHMessageType >(messagetype_);
}
inline void PokerTHMessage::set_messagetype(::PokerTHMessage_PokerTHMessageType value) {
  assert(::PokerTHMessage_PokerTHMessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:PokerTHMessage.messageType)
}

// optional .AnnounceMessage announceMessage = 2;
inline bool PokerTHMessage::has_announcemessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PokerTHMessage::set_has_announcemessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PokerTHMessage::clear_has_announcemessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PokerTHMessage::clear_announcemessage() {
  if (announcemessage_ != NULL) announcemessage_->::AnnounceMessage::Clear();
  clear_has_announcemessage();
}
inline const ::AnnounceMessage& PokerTHMessage::announcemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.announceMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return announcemessage_ != NULL ? *announcemessage_ : *default_instance().announcemessage_;
#else
  return announcemessage_ != NULL ? *announcemessage_ : *default_instance_->announcemessage_;
#endif
}
inline ::AnnounceMessage* PokerTHMessage::mutable_announcemessage() {
  set_has_announcemessage();
  if (announcemessage_ == NULL) announcemessage_ = new ::AnnounceMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.announceMessage)
  return announcemessage_;
}
inline ::AnnounceMessage* PokerTHMessage::release_announcemessage() {
  clear_has_announcemessage();
  ::AnnounceMessage* temp = announcemessage_;
  announcemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_announcemessage(::AnnounceMessage* announcemessage) {
  delete announcemessage_;
  announcemessage_ = announcemessage;
  if (announcemessage) {
    set_has_announcemessage();
  } else {
    clear_has_announcemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.announceMessage)
}

// optional .InitMessage initMessage = 3;
inline bool PokerTHMessage::has_initmessage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PokerTHMessage::set_has_initmessage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PokerTHMessage::clear_has_initmessage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PokerTHMessage::clear_initmessage() {
  if (initmessage_ != NULL) initmessage_->::InitMessage::Clear();
  clear_has_initmessage();
}
inline const ::InitMessage& PokerTHMessage::initmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.initMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initmessage_ != NULL ? *initmessage_ : *default_instance().initmessage_;
#else
  return initmessage_ != NULL ? *initmessage_ : *default_instance_->initmessage_;
#endif
}
inline ::InitMessage* PokerTHMessage::mutable_initmessage() {
  set_has_initmessage();
  if (initmessage_ == NULL) initmessage_ = new ::InitMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.initMessage)
  return initmessage_;
}
inline ::InitMessage* PokerTHMessage::release_initmessage() {
  clear_has_initmessage();
  ::InitMessage* temp = initmessage_;
  initmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_initmessage(::InitMessage* initmessage) {
  delete initmessage_;
  initmessage_ = initmessage;
  if (initmessage) {
    set_has_initmessage();
  } else {
    clear_has_initmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.initMessage)
}

// optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
inline bool PokerTHMessage::has_authserverchallengemessage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PokerTHMessage::set_has_authserverchallengemessage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PokerTHMessage::clear_has_authserverchallengemessage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PokerTHMessage::clear_authserverchallengemessage() {
  if (authserverchallengemessage_ != NULL) authserverchallengemessage_->::AuthServerChallengeMessage::Clear();
  clear_has_authserverchallengemessage();
}
inline const ::AuthServerChallengeMessage& PokerTHMessage::authserverchallengemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.authServerChallengeMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return authserverchallengemessage_ != NULL ? *authserverchallengemessage_ : *default_instance().authserverchallengemessage_;
#else
  return authserverchallengemessage_ != NULL ? *authserverchallengemessage_ : *default_instance_->authserverchallengemessage_;
#endif
}
inline ::AuthServerChallengeMessage* PokerTHMessage::mutable_authserverchallengemessage() {
  set_has_authserverchallengemessage();
  if (authserverchallengemessage_ == NULL) authserverchallengemessage_ = new ::AuthServerChallengeMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.authServerChallengeMessage)
  return authserverchallengemessage_;
}
inline ::AuthServerChallengeMessage* PokerTHMessage::release_authserverchallengemessage() {
  clear_has_authserverchallengemessage();
  ::AuthServerChallengeMessage* temp = authserverchallengemessage_;
  authserverchallengemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_authserverchallengemessage(::AuthServerChallengeMessage* authserverchallengemessage) {
  delete authserverchallengemessage_;
  authserverchallengemessage_ = authserverchallengemessage;
  if (authserverchallengemessage) {
    set_has_authserverchallengemessage();
  } else {
    clear_has_authserverchallengemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.authServerChallengeMessage)
}

// optional .AuthClientResponseMessage authClientResponseMessage = 5;
inline bool PokerTHMessage::has_authclientresponsemessage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PokerTHMessage::set_has_authclientresponsemessage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PokerTHMessage::clear_has_authclientresponsemessage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PokerTHMessage::clear_authclientresponsemessage() {
  if (authclientresponsemessage_ != NULL) authclientresponsemessage_->::AuthClientResponseMessage::Clear();
  clear_has_authclientresponsemessage();
}
inline const ::AuthClientResponseMessage& PokerTHMessage::authclientresponsemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.authClientResponseMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return authclientresponsemessage_ != NULL ? *authclientresponsemessage_ : *default_instance().authclientresponsemessage_;
#else
  return authclientresponsemessage_ != NULL ? *authclientresponsemessage_ : *default_instance_->authclientresponsemessage_;
#endif
}
inline ::AuthClientResponseMessage* PokerTHMessage::mutable_authclientresponsemessage() {
  set_has_authclientresponsemessage();
  if (authclientresponsemessage_ == NULL) authclientresponsemessage_ = new ::AuthClientResponseMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.authClientResponseMessage)
  return authclientresponsemessage_;
}
inline ::AuthClientResponseMessage* PokerTHMessage::release_authclientresponsemessage() {
  clear_has_authclientresponsemessage();
  ::AuthClientResponseMessage* temp = authclientresponsemessage_;
  authclientresponsemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_authclientresponsemessage(::AuthClientResponseMessage* authclientresponsemessage) {
  delete authclientresponsemessage_;
  authclientresponsemessage_ = authclientresponsemessage;
  if (authclientresponsemessage) {
    set_has_authclientresponsemessage();
  } else {
    clear_has_authclientresponsemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.authClientResponseMessage)
}

// optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
inline bool PokerTHMessage::has_authserververificationmessage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PokerTHMessage::set_has_authserververificationmessage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PokerTHMessage::clear_has_authserververificationmessage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PokerTHMessage::clear_authserververificationmessage() {
  if (authserververificationmessage_ != NULL) authserververificationmessage_->::AuthServerVerificationMessage::Clear();
  clear_has_authserververificationmessage();
}
inline const ::AuthServerVerificationMessage& PokerTHMessage::authserververificationmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.authServerVerificationMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return authserververificationmessage_ != NULL ? *authserververificationmessage_ : *default_instance().authserververificationmessage_;
#else
  return authserververificationmessage_ != NULL ? *authserververificationmessage_ : *default_instance_->authserververificationmessage_;
#endif
}
inline ::AuthServerVerificationMessage* PokerTHMessage::mutable_authserververificationmessage() {
  set_has_authserververificationmessage();
  if (authserververificationmessage_ == NULL) authserververificationmessage_ = new ::AuthServerVerificationMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.authServerVerificationMessage)
  return authserververificationmessage_;
}
inline ::AuthServerVerificationMessage* PokerTHMessage::release_authserververificationmessage() {
  clear_has_authserververificationmessage();
  ::AuthServerVerificationMessage* temp = authserververificationmessage_;
  authserververificationmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_authserververificationmessage(::AuthServerVerificationMessage* authserververificationmessage) {
  delete authserververificationmessage_;
  authserververificationmessage_ = authserververificationmessage;
  if (authserververificationmessage) {
    set_has_authserververificationmessage();
  } else {
    clear_has_authserververificationmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.authServerVerificationMessage)
}

// optional .InitAckMessage initAckMessage = 7;
inline bool PokerTHMessage::has_initackmessage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PokerTHMessage::set_has_initackmessage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PokerTHMessage::clear_has_initackmessage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PokerTHMessage::clear_initackmessage() {
  if (initackmessage_ != NULL) initackmessage_->::InitAckMessage::Clear();
  clear_has_initackmessage();
}
inline const ::InitAckMessage& PokerTHMessage::initackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.initAckMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initackmessage_ != NULL ? *initackmessage_ : *default_instance().initackmessage_;
#else
  return initackmessage_ != NULL ? *initackmessage_ : *default_instance_->initackmessage_;
#endif
}
inline ::InitAckMessage* PokerTHMessage::mutable_initackmessage() {
  set_has_initackmessage();
  if (initackmessage_ == NULL) initackmessage_ = new ::InitAckMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.initAckMessage)
  return initackmessage_;
}
inline ::InitAckMessage* PokerTHMessage::release_initackmessage() {
  clear_has_initackmessage();
  ::InitAckMessage* temp = initackmessage_;
  initackmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_initackmessage(::InitAckMessage* initackmessage) {
  delete initackmessage_;
  initackmessage_ = initackmessage;
  if (initackmessage) {
    set_has_initackmessage();
  } else {
    clear_has_initackmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.initAckMessage)
}

// optional .AvatarRequestMessage avatarRequestMessage = 8;
inline bool PokerTHMessage::has_avatarrequestmessage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PokerTHMessage::set_has_avatarrequestmessage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PokerTHMessage::clear_has_avatarrequestmessage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PokerTHMessage::clear_avatarrequestmessage() {
  if (avatarrequestmessage_ != NULL) avatarrequestmessage_->::AvatarRequestMessage::Clear();
  clear_has_avatarrequestmessage();
}
inline const ::AvatarRequestMessage& PokerTHMessage::avatarrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarRequestMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return avatarrequestmessage_ != NULL ? *avatarrequestmessage_ : *default_instance().avatarrequestmessage_;
#else
  return avatarrequestmessage_ != NULL ? *avatarrequestmessage_ : *default_instance_->avatarrequestmessage_;
#endif
}
inline ::AvatarRequestMessage* PokerTHMessage::mutable_avatarrequestmessage() {
  set_has_avatarrequestmessage();
  if (avatarrequestmessage_ == NULL) avatarrequestmessage_ = new ::AvatarRequestMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarRequestMessage)
  return avatarrequestmessage_;
}
inline ::AvatarRequestMessage* PokerTHMessage::release_avatarrequestmessage() {
  clear_has_avatarrequestmessage();
  ::AvatarRequestMessage* temp = avatarrequestmessage_;
  avatarrequestmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_avatarrequestmessage(::AvatarRequestMessage* avatarrequestmessage) {
  delete avatarrequestmessage_;
  avatarrequestmessage_ = avatarrequestmessage;
  if (avatarrequestmessage) {
    set_has_avatarrequestmessage();
  } else {
    clear_has_avatarrequestmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarRequestMessage)
}

// optional .AvatarHeaderMessage avatarHeaderMessage = 9;
inline bool PokerTHMessage::has_avatarheadermessage() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PokerTHMessage::set_has_avatarheadermessage() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PokerTHMessage::clear_has_avatarheadermessage() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PokerTHMessage::clear_avatarheadermessage() {
  if (avatarheadermessage_ != NULL) avatarheadermessage_->::AvatarHeaderMessage::Clear();
  clear_has_avatarheadermessage();
}
inline const ::AvatarHeaderMessage& PokerTHMessage::avatarheadermessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarHeaderMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return avatarheadermessage_ != NULL ? *avatarheadermessage_ : *default_instance().avatarheadermessage_;
#else
  return avatarheadermessage_ != NULL ? *avatarheadermessage_ : *default_instance_->avatarheadermessage_;
#endif
}
inline ::AvatarHeaderMessage* PokerTHMessage::mutable_avatarheadermessage() {
  set_has_avatarheadermessage();
  if (avatarheadermessage_ == NULL) avatarheadermessage_ = new ::AvatarHeaderMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarHeaderMessage)
  return avatarheadermessage_;
}
inline ::AvatarHeaderMessage* PokerTHMessage::release_avatarheadermessage() {
  clear_has_avatarheadermessage();
  ::AvatarHeaderMessage* temp = avatarheadermessage_;
  avatarheadermessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_avatarheadermessage(::AvatarHeaderMessage* avatarheadermessage) {
  delete avatarheadermessage_;
  avatarheadermessage_ = avatarheadermessage;
  if (avatarheadermessage) {
    set_has_avatarheadermessage();
  } else {
    clear_has_avatarheadermessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarHeaderMessage)
}

// optional .AvatarDataMessage avatarDataMessage = 10;
inline bool PokerTHMessage::has_avatardatamessage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PokerTHMessage::set_has_avatardatamessage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PokerTHMessage::clear_has_avatardatamessage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PokerTHMessage::clear_avatardatamessage() {
  if (avatardatamessage_ != NULL) avatardatamessage_->::AvatarDataMessage::Clear();
  clear_has_avatardatamessage();
}
inline const ::AvatarDataMessage& PokerTHMessage::avatardatamessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarDataMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return avatardatamessage_ != NULL ? *avatardatamessage_ : *default_instance().avatardatamessage_;
#else
  return avatardatamessage_ != NULL ? *avatardatamessage_ : *default_instance_->avatardatamessage_;
#endif
}
inline ::AvatarDataMessage* PokerTHMessage::mutable_avatardatamessage() {
  set_has_avatardatamessage();
  if (avatardatamessage_ == NULL) avatardatamessage_ = new ::AvatarDataMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarDataMessage)
  return avatardatamessage_;
}
inline ::AvatarDataMessage* PokerTHMessage::release_avatardatamessage() {
  clear_has_avatardatamessage();
  ::AvatarDataMessage* temp = avatardatamessage_;
  avatardatamessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_avatardatamessage(::AvatarDataMessage* avatardatamessage) {
  delete avatardatamessage_;
  avatardatamessage_ = avatardatamessage;
  if (avatardatamessage) {
    set_has_avatardatamessage();
  } else {
    clear_has_avatardatamessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarDataMessage)
}

// optional .AvatarEndMessage avatarEndMessage = 11;
inline bool PokerTHMessage::has_avatarendmessage() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PokerTHMessage::set_has_avatarendmessage() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PokerTHMessage::clear_has_avatarendmessage() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PokerTHMessage::clear_avatarendmessage() {
  if (avatarendmessage_ != NULL) avatarendmessage_->::AvatarEndMessage::Clear();
  clear_has_avatarendmessage();
}
inline const ::AvatarEndMessage& PokerTHMessage::avatarendmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarEndMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return avatarendmessage_ != NULL ? *avatarendmessage_ : *default_instance().avatarendmessage_;
#else
  return avatarendmessage_ != NULL ? *avatarendmessage_ : *default_instance_->avatarendmessage_;
#endif
}
inline ::AvatarEndMessage* PokerTHMessage::mutable_avatarendmessage() {
  set_has_avatarendmessage();
  if (avatarendmessage_ == NULL) avatarendmessage_ = new ::AvatarEndMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarEndMessage)
  return avatarendmessage_;
}
inline ::AvatarEndMessage* PokerTHMessage::release_avatarendmessage() {
  clear_has_avatarendmessage();
  ::AvatarEndMessage* temp = avatarendmessage_;
  avatarendmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_avatarendmessage(::AvatarEndMessage* avatarendmessage) {
  delete avatarendmessage_;
  avatarendmessage_ = avatarendmessage;
  if (avatarendmessage) {
    set_has_avatarendmessage();
  } else {
    clear_has_avatarendmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarEndMessage)
}

// optional .UnknownAvatarMessage unknownAvatarMessage = 12;
inline bool PokerTHMessage::has_unknownavatarmessage() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PokerTHMessage::set_has_unknownavatarmessage() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PokerTHMessage::clear_has_unknownavatarmessage() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PokerTHMessage::clear_unknownavatarmessage() {
  if (unknownavatarmessage_ != NULL) unknownavatarmessage_->::UnknownAvatarMessage::Clear();
  clear_has_unknownavatarmessage();
}
inline const ::UnknownAvatarMessage& PokerTHMessage::unknownavatarmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.unknownAvatarMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return unknownavatarmessage_ != NULL ? *unknownavatarmessage_ : *default_instance().unknownavatarmessage_;
#else
  return unknownavatarmessage_ != NULL ? *unknownavatarmessage_ : *default_instance_->unknownavatarmessage_;
#endif
}
inline ::UnknownAvatarMessage* PokerTHMessage::mutable_unknownavatarmessage() {
  set_has_unknownavatarmessage();
  if (unknownavatarmessage_ == NULL) unknownavatarmessage_ = new ::UnknownAvatarMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.unknownAvatarMessage)
  return unknownavatarmessage_;
}
inline ::UnknownAvatarMessage* PokerTHMessage::release_unknownavatarmessage() {
  clear_has_unknownavatarmessage();
  ::UnknownAvatarMessage* temp = unknownavatarmessage_;
  unknownavatarmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_unknownavatarmessage(::UnknownAvatarMessage* unknownavatarmessage) {
  delete unknownavatarmessage_;
  unknownavatarmessage_ = unknownavatarmessage;
  if (unknownavatarmessage) {
    set_has_unknownavatarmessage();
  } else {
    clear_has_unknownavatarmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.unknownAvatarMessage)
}

// optional .PlayerListMessage playerListMessage = 13;
inline bool PokerTHMessage::has_playerlistmessage() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PokerTHMessage::set_has_playerlistmessage() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PokerTHMessage::clear_has_playerlistmessage() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PokerTHMessage::clear_playerlistmessage() {
  if (playerlistmessage_ != NULL) playerlistmessage_->::PlayerListMessage::Clear();
  clear_has_playerlistmessage();
}
inline const ::PlayerListMessage& PokerTHMessage::playerlistmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerListMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerlistmessage_ != NULL ? *playerlistmessage_ : *default_instance().playerlistmessage_;
#else
  return playerlistmessage_ != NULL ? *playerlistmessage_ : *default_instance_->playerlistmessage_;
#endif
}
inline ::PlayerListMessage* PokerTHMessage::mutable_playerlistmessage() {
  set_has_playerlistmessage();
  if (playerlistmessage_ == NULL) playerlistmessage_ = new ::PlayerListMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerListMessage)
  return playerlistmessage_;
}
inline ::PlayerListMessage* PokerTHMessage::release_playerlistmessage() {
  clear_has_playerlistmessage();
  ::PlayerListMessage* temp = playerlistmessage_;
  playerlistmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_playerlistmessage(::PlayerListMessage* playerlistmessage) {
  delete playerlistmessage_;
  playerlistmessage_ = playerlistmessage;
  if (playerlistmessage) {
    set_has_playerlistmessage();
  } else {
    clear_has_playerlistmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerListMessage)
}

// optional .GameListNewMessage gameListNewMessage = 14;
inline bool PokerTHMessage::has_gamelistnewmessage() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistnewmessage() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PokerTHMessage::clear_has_gamelistnewmessage() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PokerTHMessage::clear_gamelistnewmessage() {
  if (gamelistnewmessage_ != NULL) gamelistnewmessage_->::GameListNewMessage::Clear();
  clear_has_gamelistnewmessage();
}
inline const ::GameListNewMessage& PokerTHMessage::gamelistnewmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListNewMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamelistnewmessage_ != NULL ? *gamelistnewmessage_ : *default_instance().gamelistnewmessage_;
#else
  return gamelistnewmessage_ != NULL ? *gamelistnewmessage_ : *default_instance_->gamelistnewmessage_;
#endif
}
inline ::GameListNewMessage* PokerTHMessage::mutable_gamelistnewmessage() {
  set_has_gamelistnewmessage();
  if (gamelistnewmessage_ == NULL) gamelistnewmessage_ = new ::GameListNewMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListNewMessage)
  return gamelistnewmessage_;
}
inline ::GameListNewMessage* PokerTHMessage::release_gamelistnewmessage() {
  clear_has_gamelistnewmessage();
  ::GameListNewMessage* temp = gamelistnewmessage_;
  gamelistnewmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamelistnewmessage(::GameListNewMessage* gamelistnewmessage) {
  delete gamelistnewmessage_;
  gamelistnewmessage_ = gamelistnewmessage;
  if (gamelistnewmessage) {
    set_has_gamelistnewmessage();
  } else {
    clear_has_gamelistnewmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListNewMessage)
}

// optional .GameListUpdateMessage gameListUpdateMessage = 15;
inline bool PokerTHMessage::has_gamelistupdatemessage() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistupdatemessage() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PokerTHMessage::clear_has_gamelistupdatemessage() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PokerTHMessage::clear_gamelistupdatemessage() {
  if (gamelistupdatemessage_ != NULL) gamelistupdatemessage_->::GameListUpdateMessage::Clear();
  clear_has_gamelistupdatemessage();
}
inline const ::GameListUpdateMessage& PokerTHMessage::gamelistupdatemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListUpdateMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamelistupdatemessage_ != NULL ? *gamelistupdatemessage_ : *default_instance().gamelistupdatemessage_;
#else
  return gamelistupdatemessage_ != NULL ? *gamelistupdatemessage_ : *default_instance_->gamelistupdatemessage_;
#endif
}
inline ::GameListUpdateMessage* PokerTHMessage::mutable_gamelistupdatemessage() {
  set_has_gamelistupdatemessage();
  if (gamelistupdatemessage_ == NULL) gamelistupdatemessage_ = new ::GameListUpdateMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListUpdateMessage)
  return gamelistupdatemessage_;
}
inline ::GameListUpdateMessage* PokerTHMessage::release_gamelistupdatemessage() {
  clear_has_gamelistupdatemessage();
  ::GameListUpdateMessage* temp = gamelistupdatemessage_;
  gamelistupdatemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamelistupdatemessage(::GameListUpdateMessage* gamelistupdatemessage) {
  delete gamelistupdatemessage_;
  gamelistupdatemessage_ = gamelistupdatemessage;
  if (gamelistupdatemessage) {
    set_has_gamelistupdatemessage();
  } else {
    clear_has_gamelistupdatemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListUpdateMessage)
}

// optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
inline bool PokerTHMessage::has_gamelistplayerjoinedmessage() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistplayerjoinedmessage() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PokerTHMessage::clear_has_gamelistplayerjoinedmessage() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PokerTHMessage::clear_gamelistplayerjoinedmessage() {
  if (gamelistplayerjoinedmessage_ != NULL) gamelistplayerjoinedmessage_->::GameListPlayerJoinedMessage::Clear();
  clear_has_gamelistplayerjoinedmessage();
}
inline const ::GameListPlayerJoinedMessage& PokerTHMessage::gamelistplayerjoinedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListPlayerJoinedMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamelistplayerjoinedmessage_ != NULL ? *gamelistplayerjoinedmessage_ : *default_instance().gamelistplayerjoinedmessage_;
#else
  return gamelistplayerjoinedmessage_ != NULL ? *gamelistplayerjoinedmessage_ : *default_instance_->gamelistplayerjoinedmessage_;
#endif
}
inline ::GameListPlayerJoinedMessage* PokerTHMessage::mutable_gamelistplayerjoinedmessage() {
  set_has_gamelistplayerjoinedmessage();
  if (gamelistplayerjoinedmessage_ == NULL) gamelistplayerjoinedmessage_ = new ::GameListPlayerJoinedMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListPlayerJoinedMessage)
  return gamelistplayerjoinedmessage_;
}
inline ::GameListPlayerJoinedMessage* PokerTHMessage::release_gamelistplayerjoinedmessage() {
  clear_has_gamelistplayerjoinedmessage();
  ::GameListPlayerJoinedMessage* temp = gamelistplayerjoinedmessage_;
  gamelistplayerjoinedmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamelistplayerjoinedmessage(::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage) {
  delete gamelistplayerjoinedmessage_;
  gamelistplayerjoinedmessage_ = gamelistplayerjoinedmessage;
  if (gamelistplayerjoinedmessage) {
    set_has_gamelistplayerjoinedmessage();
  } else {
    clear_has_gamelistplayerjoinedmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListPlayerJoinedMessage)
}

// optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
inline bool PokerTHMessage::has_gamelistplayerleftmessage() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistplayerleftmessage() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PokerTHMessage::clear_has_gamelistplayerleftmessage() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PokerTHMessage::clear_gamelistplayerleftmessage() {
  if (gamelistplayerleftmessage_ != NULL) gamelistplayerleftmessage_->::GameListPlayerLeftMessage::Clear();
  clear_has_gamelistplayerleftmessage();
}
inline const ::GameListPlayerLeftMessage& PokerTHMessage::gamelistplayerleftmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListPlayerLeftMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamelistplayerleftmessage_ != NULL ? *gamelistplayerleftmessage_ : *default_instance().gamelistplayerleftmessage_;
#else
  return gamelistplayerleftmessage_ != NULL ? *gamelistplayerleftmessage_ : *default_instance_->gamelistplayerleftmessage_;
#endif
}
inline ::GameListPlayerLeftMessage* PokerTHMessage::mutable_gamelistplayerleftmessage() {
  set_has_gamelistplayerleftmessage();
  if (gamelistplayerleftmessage_ == NULL) gamelistplayerleftmessage_ = new ::GameListPlayerLeftMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListPlayerLeftMessage)
  return gamelistplayerleftmessage_;
}
inline ::GameListPlayerLeftMessage* PokerTHMessage::release_gamelistplayerleftmessage() {
  clear_has_gamelistplayerleftmessage();
  ::GameListPlayerLeftMessage* temp = gamelistplayerleftmessage_;
  gamelistplayerleftmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamelistplayerleftmessage(::GameListPlayerLeftMessage* gamelistplayerleftmessage) {
  delete gamelistplayerleftmessage_;
  gamelistplayerleftmessage_ = gamelistplayerleftmessage;
  if (gamelistplayerleftmessage) {
    set_has_gamelistplayerleftmessage();
  } else {
    clear_has_gamelistplayerleftmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListPlayerLeftMessage)
}

// optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
inline bool PokerTHMessage::has_gamelistadminchangedmessage() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistadminchangedmessage() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PokerTHMessage::clear_has_gamelistadminchangedmessage() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PokerTHMessage::clear_gamelistadminchangedmessage() {
  if (gamelistadminchangedmessage_ != NULL) gamelistadminchangedmessage_->::GameListAdminChangedMessage::Clear();
  clear_has_gamelistadminchangedmessage();
}
inline const ::GameListAdminChangedMessage& PokerTHMessage::gamelistadminchangedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListAdminChangedMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamelistadminchangedmessage_ != NULL ? *gamelistadminchangedmessage_ : *default_instance().gamelistadminchangedmessage_;
#else
  return gamelistadminchangedmessage_ != NULL ? *gamelistadminchangedmessage_ : *default_instance_->gamelistadminchangedmessage_;
#endif
}
inline ::GameListAdminChangedMessage* PokerTHMessage::mutable_gamelistadminchangedmessage() {
  set_has_gamelistadminchangedmessage();
  if (gamelistadminchangedmessage_ == NULL) gamelistadminchangedmessage_ = new ::GameListAdminChangedMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListAdminChangedMessage)
  return gamelistadminchangedmessage_;
}
inline ::GameListAdminChangedMessage* PokerTHMessage::release_gamelistadminchangedmessage() {
  clear_has_gamelistadminchangedmessage();
  ::GameListAdminChangedMessage* temp = gamelistadminchangedmessage_;
  gamelistadminchangedmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamelistadminchangedmessage(::GameListAdminChangedMessage* gamelistadminchangedmessage) {
  delete gamelistadminchangedmessage_;
  gamelistadminchangedmessage_ = gamelistadminchangedmessage;
  if (gamelistadminchangedmessage) {
    set_has_gamelistadminchangedmessage();
  } else {
    clear_has_gamelistadminchangedmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListAdminChangedMessage)
}

// optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
inline bool PokerTHMessage::has_playerinforequestmessage() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PokerTHMessage::set_has_playerinforequestmessage() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PokerTHMessage::clear_has_playerinforequestmessage() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PokerTHMessage::clear_playerinforequestmessage() {
  if (playerinforequestmessage_ != NULL) playerinforequestmessage_->::PlayerInfoRequestMessage::Clear();
  clear_has_playerinforequestmessage();
}
inline const ::PlayerInfoRequestMessage& PokerTHMessage::playerinforequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerInfoRequestMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerinforequestmessage_ != NULL ? *playerinforequestmessage_ : *default_instance().playerinforequestmessage_;
#else
  return playerinforequestmessage_ != NULL ? *playerinforequestmessage_ : *default_instance_->playerinforequestmessage_;
#endif
}
inline ::PlayerInfoRequestMessage* PokerTHMessage::mutable_playerinforequestmessage() {
  set_has_playerinforequestmessage();
  if (playerinforequestmessage_ == NULL) playerinforequestmessage_ = new ::PlayerInfoRequestMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerInfoRequestMessage)
  return playerinforequestmessage_;
}
inline ::PlayerInfoRequestMessage* PokerTHMessage::release_playerinforequestmessage() {
  clear_has_playerinforequestmessage();
  ::PlayerInfoRequestMessage* temp = playerinforequestmessage_;
  playerinforequestmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_playerinforequestmessage(::PlayerInfoRequestMessage* playerinforequestmessage) {
  delete playerinforequestmessage_;
  playerinforequestmessage_ = playerinforequestmessage;
  if (playerinforequestmessage) {
    set_has_playerinforequestmessage();
  } else {
    clear_has_playerinforequestmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerInfoRequestMessage)
}

// optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
inline bool PokerTHMessage::has_playerinforeplymessage() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PokerTHMessage::set_has_playerinforeplymessage() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PokerTHMessage::clear_has_playerinforeplymessage() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PokerTHMessage::clear_playerinforeplymessage() {
  if (playerinforeplymessage_ != NULL) playerinforeplymessage_->::PlayerInfoReplyMessage::Clear();
  clear_has_playerinforeplymessage();
}
inline const ::PlayerInfoReplyMessage& PokerTHMessage::playerinforeplymessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerInfoReplyMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerinforeplymessage_ != NULL ? *playerinforeplymessage_ : *default_instance().playerinforeplymessage_;
#else
  return playerinforeplymessage_ != NULL ? *playerinforeplymessage_ : *default_instance_->playerinforeplymessage_;
#endif
}
inline ::PlayerInfoReplyMessage* PokerTHMessage::mutable_playerinforeplymessage() {
  set_has_playerinforeplymessage();
  if (playerinforeplymessage_ == NULL) playerinforeplymessage_ = new ::PlayerInfoReplyMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerInfoReplyMessage)
  return playerinforeplymessage_;
}
inline ::PlayerInfoReplyMessage* PokerTHMessage::release_playerinforeplymessage() {
  clear_has_playerinforeplymessage();
  ::PlayerInfoReplyMessage* temp = playerinforeplymessage_;
  playerinforeplymessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_playerinforeplymessage(::PlayerInfoReplyMessage* playerinforeplymessage) {
  delete playerinforeplymessage_;
  playerinforeplymessage_ = playerinforeplymessage;
  if (playerinforeplymessage) {
    set_has_playerinforeplymessage();
  } else {
    clear_has_playerinforeplymessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerInfoReplyMessage)
}

// optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
inline bool PokerTHMessage::has_subscriptionrequestmessage() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PokerTHMessage::set_has_subscriptionrequestmessage() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PokerTHMessage::clear_has_subscriptionrequestmessage() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PokerTHMessage::clear_subscriptionrequestmessage() {
  if (subscriptionrequestmessage_ != NULL) subscriptionrequestmessage_->::SubscriptionRequestMessage::Clear();
  clear_has_subscriptionrequestmessage();
}
inline const ::SubscriptionRequestMessage& PokerTHMessage::subscriptionrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.subscriptionRequestMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return subscriptionrequestmessage_ != NULL ? *subscriptionrequestmessage_ : *default_instance().subscriptionrequestmessage_;
#else
  return subscriptionrequestmessage_ != NULL ? *subscriptionrequestmessage_ : *default_instance_->subscriptionrequestmessage_;
#endif
}
inline ::SubscriptionRequestMessage* PokerTHMessage::mutable_subscriptionrequestmessage() {
  set_has_subscriptionrequestmessage();
  if (subscriptionrequestmessage_ == NULL) subscriptionrequestmessage_ = new ::SubscriptionRequestMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.subscriptionRequestMessage)
  return subscriptionrequestmessage_;
}
inline ::SubscriptionRequestMessage* PokerTHMessage::release_subscriptionrequestmessage() {
  clear_has_subscriptionrequestmessage();
  ::SubscriptionRequestMessage* temp = subscriptionrequestmessage_;
  subscriptionrequestmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_subscriptionrequestmessage(::SubscriptionRequestMessage* subscriptionrequestmessage) {
  delete subscriptionrequestmessage_;
  subscriptionrequestmessage_ = subscriptionrequestmessage;
  if (subscriptionrequestmessage) {
    set_has_subscriptionrequestmessage();
  } else {
    clear_has_subscriptionrequestmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.subscriptionRequestMessage)
}

// optional .JoinExistingGameMessage joinExistingGameMessage = 22;
inline bool PokerTHMessage::has_joinexistinggamemessage() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PokerTHMessage::set_has_joinexistinggamemessage() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PokerTHMessage::clear_has_joinexistinggamemessage() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PokerTHMessage::clear_joinexistinggamemessage() {
  if (joinexistinggamemessage_ != NULL) joinexistinggamemessage_->::JoinExistingGameMessage::Clear();
  clear_has_joinexistinggamemessage();
}
inline const ::JoinExistingGameMessage& PokerTHMessage::joinexistinggamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinExistingGameMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return joinexistinggamemessage_ != NULL ? *joinexistinggamemessage_ : *default_instance().joinexistinggamemessage_;
#else
  return joinexistinggamemessage_ != NULL ? *joinexistinggamemessage_ : *default_instance_->joinexistinggamemessage_;
#endif
}
inline ::JoinExistingGameMessage* PokerTHMessage::mutable_joinexistinggamemessage() {
  set_has_joinexistinggamemessage();
  if (joinexistinggamemessage_ == NULL) joinexistinggamemessage_ = new ::JoinExistingGameMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinExistingGameMessage)
  return joinexistinggamemessage_;
}
inline ::JoinExistingGameMessage* PokerTHMessage::release_joinexistinggamemessage() {
  clear_has_joinexistinggamemessage();
  ::JoinExistingGameMessage* temp = joinexistinggamemessage_;
  joinexistinggamemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_joinexistinggamemessage(::JoinExistingGameMessage* joinexistinggamemessage) {
  delete joinexistinggamemessage_;
  joinexistinggamemessage_ = joinexistinggamemessage;
  if (joinexistinggamemessage) {
    set_has_joinexistinggamemessage();
  } else {
    clear_has_joinexistinggamemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinExistingGameMessage)
}

// optional .JoinNewGameMessage joinNewGameMessage = 23;
inline bool PokerTHMessage::has_joinnewgamemessage() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PokerTHMessage::set_has_joinnewgamemessage() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PokerTHMessage::clear_has_joinnewgamemessage() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PokerTHMessage::clear_joinnewgamemessage() {
  if (joinnewgamemessage_ != NULL) joinnewgamemessage_->::JoinNewGameMessage::Clear();
  clear_has_joinnewgamemessage();
}
inline const ::JoinNewGameMessage& PokerTHMessage::joinnewgamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinNewGameMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return joinnewgamemessage_ != NULL ? *joinnewgamemessage_ : *default_instance().joinnewgamemessage_;
#else
  return joinnewgamemessage_ != NULL ? *joinnewgamemessage_ : *default_instance_->joinnewgamemessage_;
#endif
}
inline ::JoinNewGameMessage* PokerTHMessage::mutable_joinnewgamemessage() {
  set_has_joinnewgamemessage();
  if (joinnewgamemessage_ == NULL) joinnewgamemessage_ = new ::JoinNewGameMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinNewGameMessage)
  return joinnewgamemessage_;
}
inline ::JoinNewGameMessage* PokerTHMessage::release_joinnewgamemessage() {
  clear_has_joinnewgamemessage();
  ::JoinNewGameMessage* temp = joinnewgamemessage_;
  joinnewgamemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_joinnewgamemessage(::JoinNewGameMessage* joinnewgamemessage) {
  delete joinnewgamemessage_;
  joinnewgamemessage_ = joinnewgamemessage;
  if (joinnewgamemessage) {
    set_has_joinnewgamemessage();
  } else {
    clear_has_joinnewgamemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinNewGameMessage)
}

// optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
inline bool PokerTHMessage::has_rejoinexistinggamemessage() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PokerTHMessage::set_has_rejoinexistinggamemessage() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PokerTHMessage::clear_has_rejoinexistinggamemessage() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PokerTHMessage::clear_rejoinexistinggamemessage() {
  if (rejoinexistinggamemessage_ != NULL) rejoinexistinggamemessage_->::RejoinExistingGameMessage::Clear();
  clear_has_rejoinexistinggamemessage();
}
inline const ::RejoinExistingGameMessage& PokerTHMessage::rejoinexistinggamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.rejoinExistingGameMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rejoinexistinggamemessage_ != NULL ? *rejoinexistinggamemessage_ : *default_instance().rejoinexistinggamemessage_;
#else
  return rejoinexistinggamemessage_ != NULL ? *rejoinexistinggamemessage_ : *default_instance_->rejoinexistinggamemessage_;
#endif
}
inline ::RejoinExistingGameMessage* PokerTHMessage::mutable_rejoinexistinggamemessage() {
  set_has_rejoinexistinggamemessage();
  if (rejoinexistinggamemessage_ == NULL) rejoinexistinggamemessage_ = new ::RejoinExistingGameMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.rejoinExistingGameMessage)
  return rejoinexistinggamemessage_;
}
inline ::RejoinExistingGameMessage* PokerTHMessage::release_rejoinexistinggamemessage() {
  clear_has_rejoinexistinggamemessage();
  ::RejoinExistingGameMessage* temp = rejoinexistinggamemessage_;
  rejoinexistinggamemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_rejoinexistinggamemessage(::RejoinExistingGameMessage* rejoinexistinggamemessage) {
  delete rejoinexistinggamemessage_;
  rejoinexistinggamemessage_ = rejoinexistinggamemessage;
  if (rejoinexistinggamemessage) {
    set_has_rejoinexistinggamemessage();
  } else {
    clear_has_rejoinexistinggamemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.rejoinExistingGameMessage)
}

// optional .JoinGameAckMessage joinGameAckMessage = 25;
inline bool PokerTHMessage::has_joingameackmessage() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PokerTHMessage::set_has_joingameackmessage() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PokerTHMessage::clear_has_joingameackmessage() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PokerTHMessage::clear_joingameackmessage() {
  if (joingameackmessage_ != NULL) joingameackmessage_->::JoinGameAckMessage::Clear();
  clear_has_joingameackmessage();
}
inline const ::JoinGameAckMessage& PokerTHMessage::joingameackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinGameAckMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return joingameackmessage_ != NULL ? *joingameackmessage_ : *default_instance().joingameackmessage_;
#else
  return joingameackmessage_ != NULL ? *joingameackmessage_ : *default_instance_->joingameackmessage_;
#endif
}
inline ::JoinGameAckMessage* PokerTHMessage::mutable_joingameackmessage() {
  set_has_joingameackmessage();
  if (joingameackmessage_ == NULL) joingameackmessage_ = new ::JoinGameAckMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinGameAckMessage)
  return joingameackmessage_;
}
inline ::JoinGameAckMessage* PokerTHMessage::release_joingameackmessage() {
  clear_has_joingameackmessage();
  ::JoinGameAckMessage* temp = joingameackmessage_;
  joingameackmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_joingameackmessage(::JoinGameAckMessage* joingameackmessage) {
  delete joingameackmessage_;
  joingameackmessage_ = joingameackmessage;
  if (joingameackmessage) {
    set_has_joingameackmessage();
  } else {
    clear_has_joingameackmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinGameAckMessage)
}

// optional .JoinGameFailedMessage joinGameFailedMessage = 26;
inline bool PokerTHMessage::has_joingamefailedmessage() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PokerTHMessage::set_has_joingamefailedmessage() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PokerTHMessage::clear_has_joingamefailedmessage() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PokerTHMessage::clear_joingamefailedmessage() {
  if (joingamefailedmessage_ != NULL) joingamefailedmessage_->::JoinGameFailedMessage::Clear();
  clear_has_joingamefailedmessage();
}
inline const ::JoinGameFailedMessage& PokerTHMessage::joingamefailedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinGameFailedMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return joingamefailedmessage_ != NULL ? *joingamefailedmessage_ : *default_instance().joingamefailedmessage_;
#else
  return joingamefailedmessage_ != NULL ? *joingamefailedmessage_ : *default_instance_->joingamefailedmessage_;
#endif
}
inline ::JoinGameFailedMessage* PokerTHMessage::mutable_joingamefailedmessage() {
  set_has_joingamefailedmessage();
  if (joingamefailedmessage_ == NULL) joingamefailedmessage_ = new ::JoinGameFailedMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinGameFailedMessage)
  return joingamefailedmessage_;
}
inline ::JoinGameFailedMessage* PokerTHMessage::release_joingamefailedmessage() {
  clear_has_joingamefailedmessage();
  ::JoinGameFailedMessage* temp = joingamefailedmessage_;
  joingamefailedmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_joingamefailedmessage(::JoinGameFailedMessage* joingamefailedmessage) {
  delete joingamefailedmessage_;
  joingamefailedmessage_ = joingamefailedmessage;
  if (joingamefailedmessage) {
    set_has_joingamefailedmessage();
  } else {
    clear_has_joingamefailedmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinGameFailedMessage)
}

// optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
inline bool PokerTHMessage::has_gameplayerjoinedmessage() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PokerTHMessage::set_has_gameplayerjoinedmessage() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PokerTHMessage::clear_has_gameplayerjoinedmessage() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PokerTHMessage::clear_gameplayerjoinedmessage() {
  if (gameplayerjoinedmessage_ != NULL) gameplayerjoinedmessage_->::GamePlayerJoinedMessage::Clear();
  clear_has_gameplayerjoinedmessage();
}
inline const ::GamePlayerJoinedMessage& PokerTHMessage::gameplayerjoinedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gamePlayerJoinedMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gameplayerjoinedmessage_ != NULL ? *gameplayerjoinedmessage_ : *default_instance().gameplayerjoinedmessage_;
#else
  return gameplayerjoinedmessage_ != NULL ? *gameplayerjoinedmessage_ : *default_instance_->gameplayerjoinedmessage_;
#endif
}
inline ::GamePlayerJoinedMessage* PokerTHMessage::mutable_gameplayerjoinedmessage() {
  set_has_gameplayerjoinedmessage();
  if (gameplayerjoinedmessage_ == NULL) gameplayerjoinedmessage_ = new ::GamePlayerJoinedMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gamePlayerJoinedMessage)
  return gameplayerjoinedmessage_;
}
inline ::GamePlayerJoinedMessage* PokerTHMessage::release_gameplayerjoinedmessage() {
  clear_has_gameplayerjoinedmessage();
  ::GamePlayerJoinedMessage* temp = gameplayerjoinedmessage_;
  gameplayerjoinedmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gameplayerjoinedmessage(::GamePlayerJoinedMessage* gameplayerjoinedmessage) {
  delete gameplayerjoinedmessage_;
  gameplayerjoinedmessage_ = gameplayerjoinedmessage;
  if (gameplayerjoinedmessage) {
    set_has_gameplayerjoinedmessage();
  } else {
    clear_has_gameplayerjoinedmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gamePlayerJoinedMessage)
}

// optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
inline bool PokerTHMessage::has_gameplayerleftmessage() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PokerTHMessage::set_has_gameplayerleftmessage() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PokerTHMessage::clear_has_gameplayerleftmessage() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PokerTHMessage::clear_gameplayerleftmessage() {
  if (gameplayerleftmessage_ != NULL) gameplayerleftmessage_->::GamePlayerLeftMessage::Clear();
  clear_has_gameplayerleftmessage();
}
inline const ::GamePlayerLeftMessage& PokerTHMessage::gameplayerleftmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gamePlayerLeftMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gameplayerleftmessage_ != NULL ? *gameplayerleftmessage_ : *default_instance().gameplayerleftmessage_;
#else
  return gameplayerleftmessage_ != NULL ? *gameplayerleftmessage_ : *default_instance_->gameplayerleftmessage_;
#endif
}
inline ::GamePlayerLeftMessage* PokerTHMessage::mutable_gameplayerleftmessage() {
  set_has_gameplayerleftmessage();
  if (gameplayerleftmessage_ == NULL) gameplayerleftmessage_ = new ::GamePlayerLeftMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gamePlayerLeftMessage)
  return gameplayerleftmessage_;
}
inline ::GamePlayerLeftMessage* PokerTHMessage::release_gameplayerleftmessage() {
  clear_has_gameplayerleftmessage();
  ::GamePlayerLeftMessage* temp = gameplayerleftmessage_;
  gameplayerleftmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gameplayerleftmessage(::GamePlayerLeftMessage* gameplayerleftmessage) {
  delete gameplayerleftmessage_;
  gameplayerleftmessage_ = gameplayerleftmessage;
  if (gameplayerleftmessage) {
    set_has_gameplayerleftmessage();
  } else {
    clear_has_gameplayerleftmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gamePlayerLeftMessage)
}

// optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
inline bool PokerTHMessage::has_gameadminchangedmessage() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PokerTHMessage::set_has_gameadminchangedmessage() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PokerTHMessage::clear_has_gameadminchangedmessage() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PokerTHMessage::clear_gameadminchangedmessage() {
  if (gameadminchangedmessage_ != NULL) gameadminchangedmessage_->::GameAdminChangedMessage::Clear();
  clear_has_gameadminchangedmessage();
}
inline const ::GameAdminChangedMessage& PokerTHMessage::gameadminchangedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameAdminChangedMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gameadminchangedmessage_ != NULL ? *gameadminchangedmessage_ : *default_instance().gameadminchangedmessage_;
#else
  return gameadminchangedmessage_ != NULL ? *gameadminchangedmessage_ : *default_instance_->gameadminchangedmessage_;
#endif
}
inline ::GameAdminChangedMessage* PokerTHMessage::mutable_gameadminchangedmessage() {
  set_has_gameadminchangedmessage();
  if (gameadminchangedmessage_ == NULL) gameadminchangedmessage_ = new ::GameAdminChangedMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameAdminChangedMessage)
  return gameadminchangedmessage_;
}
inline ::GameAdminChangedMessage* PokerTHMessage::release_gameadminchangedmessage() {
  clear_has_gameadminchangedmessage();
  ::GameAdminChangedMessage* temp = gameadminchangedmessage_;
  gameadminchangedmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gameadminchangedmessage(::GameAdminChangedMessage* gameadminchangedmessage) {
  delete gameadminchangedmessage_;
  gameadminchangedmessage_ = gameadminchangedmessage;
  if (gameadminchangedmessage) {
    set_has_gameadminchangedmessage();
  } else {
    clear_has_gameadminchangedmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameAdminChangedMessage)
}

// optional .RemovedFromGameMessage removedFromGameMessage = 30;
inline bool PokerTHMessage::has_removedfromgamemessage() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PokerTHMessage::set_has_removedfromgamemessage() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PokerTHMessage::clear_has_removedfromgamemessage() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PokerTHMessage::clear_removedfromgamemessage() {
  if (removedfromgamemessage_ != NULL) removedfromgamemessage_->::RemovedFromGameMessage::Clear();
  clear_has_removedfromgamemessage();
}
inline const ::RemovedFromGameMessage& PokerTHMessage::removedfromgamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.removedFromGameMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return removedfromgamemessage_ != NULL ? *removedfromgamemessage_ : *default_instance().removedfromgamemessage_;
#else
  return removedfromgamemessage_ != NULL ? *removedfromgamemessage_ : *default_instance_->removedfromgamemessage_;
#endif
}
inline ::RemovedFromGameMessage* PokerTHMessage::mutable_removedfromgamemessage() {
  set_has_removedfromgamemessage();
  if (removedfromgamemessage_ == NULL) removedfromgamemessage_ = new ::RemovedFromGameMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.removedFromGameMessage)
  return removedfromgamemessage_;
}
inline ::RemovedFromGameMessage* PokerTHMessage::release_removedfromgamemessage() {
  clear_has_removedfromgamemessage();
  ::RemovedFromGameMessage* temp = removedfromgamemessage_;
  removedfromgamemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_removedfromgamemessage(::RemovedFromGameMessage* removedfromgamemessage) {
  delete removedfromgamemessage_;
  removedfromgamemessage_ = removedfromgamemessage;
  if (removedfromgamemessage) {
    set_has_removedfromgamemessage();
  } else {
    clear_has_removedfromgamemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.removedFromGameMessage)
}

// optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
inline bool PokerTHMessage::has_kickplayerrequestmessage() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PokerTHMessage::set_has_kickplayerrequestmessage() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PokerTHMessage::clear_has_kickplayerrequestmessage() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PokerTHMessage::clear_kickplayerrequestmessage() {
  if (kickplayerrequestmessage_ != NULL) kickplayerrequestmessage_->::KickPlayerRequestMessage::Clear();
  clear_has_kickplayerrequestmessage();
}
inline const ::KickPlayerRequestMessage& PokerTHMessage::kickplayerrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.kickPlayerRequestMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return kickplayerrequestmessage_ != NULL ? *kickplayerrequestmessage_ : *default_instance().kickplayerrequestmessage_;
#else
  return kickplayerrequestmessage_ != NULL ? *kickplayerrequestmessage_ : *default_instance_->kickplayerrequestmessage_;
#endif
}
inline ::KickPlayerRequestMessage* PokerTHMessage::mutable_kickplayerrequestmessage() {
  set_has_kickplayerrequestmessage();
  if (kickplayerrequestmessage_ == NULL) kickplayerrequestmessage_ = new ::KickPlayerRequestMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.kickPlayerRequestMessage)
  return kickplayerrequestmessage_;
}
inline ::KickPlayerRequestMessage* PokerTHMessage::release_kickplayerrequestmessage() {
  clear_has_kickplayerrequestmessage();
  ::KickPlayerRequestMessage* temp = kickplayerrequestmessage_;
  kickplayerrequestmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_kickplayerrequestmessage(::KickPlayerRequestMessage* kickplayerrequestmessage) {
  delete kickplayerrequestmessage_;
  kickplayerrequestmessage_ = kickplayerrequestmessage;
  if (kickplayerrequestmessage) {
    set_has_kickplayerrequestmessage();
  } else {
    clear_has_kickplayerrequestmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.kickPlayerRequestMessage)
}

// optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
inline bool PokerTHMessage::has_leavegamerequestmessage() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PokerTHMessage::set_has_leavegamerequestmessage() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PokerTHMessage::clear_has_leavegamerequestmessage() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PokerTHMessage::clear_leavegamerequestmessage() {
  if (leavegamerequestmessage_ != NULL) leavegamerequestmessage_->::LeaveGameRequestMessage::Clear();
  clear_has_leavegamerequestmessage();
}
inline const ::LeaveGameRequestMessage& PokerTHMessage::leavegamerequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.leaveGameRequestMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return leavegamerequestmessage_ != NULL ? *leavegamerequestmessage_ : *default_instance().leavegamerequestmessage_;
#else
  return leavegamerequestmessage_ != NULL ? *leavegamerequestmessage_ : *default_instance_->leavegamerequestmessage_;
#endif
}
inline ::LeaveGameRequestMessage* PokerTHMessage::mutable_leavegamerequestmessage() {
  set_has_leavegamerequestmessage();
  if (leavegamerequestmessage_ == NULL) leavegamerequestmessage_ = new ::LeaveGameRequestMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.leaveGameRequestMessage)
  return leavegamerequestmessage_;
}
inline ::LeaveGameRequestMessage* PokerTHMessage::release_leavegamerequestmessage() {
  clear_has_leavegamerequestmessage();
  ::LeaveGameRequestMessage* temp = leavegamerequestmessage_;
  leavegamerequestmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_leavegamerequestmessage(::LeaveGameRequestMessage* leavegamerequestmessage) {
  delete leavegamerequestmessage_;
  leavegamerequestmessage_ = leavegamerequestmessage;
  if (leavegamerequestmessage) {
    set_has_leavegamerequestmessage();
  } else {
    clear_has_leavegamerequestmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.leaveGameRequestMessage)
}

// optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
inline bool PokerTHMessage::has_inviteplayertogamemessage() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PokerTHMessage::set_has_inviteplayertogamemessage() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PokerTHMessage::clear_has_inviteplayertogamemessage() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PokerTHMessage::clear_inviteplayertogamemessage() {
  if (inviteplayertogamemessage_ != NULL) inviteplayertogamemessage_->::InvitePlayerToGameMessage::Clear();
  clear_has_inviteplayertogamemessage();
}
inline const ::InvitePlayerToGameMessage& PokerTHMessage::inviteplayertogamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.invitePlayerToGameMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return inviteplayertogamemessage_ != NULL ? *inviteplayertogamemessage_ : *default_instance().inviteplayertogamemessage_;
#else
  return inviteplayertogamemessage_ != NULL ? *inviteplayertogamemessage_ : *default_instance_->inviteplayertogamemessage_;
#endif
}
inline ::InvitePlayerToGameMessage* PokerTHMessage::mutable_inviteplayertogamemessage() {
  set_has_inviteplayertogamemessage();
  if (inviteplayertogamemessage_ == NULL) inviteplayertogamemessage_ = new ::InvitePlayerToGameMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.invitePlayerToGameMessage)
  return inviteplayertogamemessage_;
}
inline ::InvitePlayerToGameMessage* PokerTHMessage::release_inviteplayertogamemessage() {
  clear_has_inviteplayertogamemessage();
  ::InvitePlayerToGameMessage* temp = inviteplayertogamemessage_;
  inviteplayertogamemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_inviteplayertogamemessage(::InvitePlayerToGameMessage* inviteplayertogamemessage) {
  delete inviteplayertogamemessage_;
  inviteplayertogamemessage_ = inviteplayertogamemessage;
  if (inviteplayertogamemessage) {
    set_has_inviteplayertogamemessage();
  } else {
    clear_has_inviteplayertogamemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.invitePlayerToGameMessage)
}

// optional .InviteNotifyMessage inviteNotifyMessage = 34;
inline bool PokerTHMessage::has_invitenotifymessage() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PokerTHMessage::set_has_invitenotifymessage() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PokerTHMessage::clear_has_invitenotifymessage() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PokerTHMessage::clear_invitenotifymessage() {
  if (invitenotifymessage_ != NULL) invitenotifymessage_->::InviteNotifyMessage::Clear();
  clear_has_invitenotifymessage();
}
inline const ::InviteNotifyMessage& PokerTHMessage::invitenotifymessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.inviteNotifyMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return invitenotifymessage_ != NULL ? *invitenotifymessage_ : *default_instance().invitenotifymessage_;
#else
  return invitenotifymessage_ != NULL ? *invitenotifymessage_ : *default_instance_->invitenotifymessage_;
#endif
}
inline ::InviteNotifyMessage* PokerTHMessage::mutable_invitenotifymessage() {
  set_has_invitenotifymessage();
  if (invitenotifymessage_ == NULL) invitenotifymessage_ = new ::InviteNotifyMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.inviteNotifyMessage)
  return invitenotifymessage_;
}
inline ::InviteNotifyMessage* PokerTHMessage::release_invitenotifymessage() {
  clear_has_invitenotifymessage();
  ::InviteNotifyMessage* temp = invitenotifymessage_;
  invitenotifymessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_invitenotifymessage(::InviteNotifyMessage* invitenotifymessage) {
  delete invitenotifymessage_;
  invitenotifymessage_ = invitenotifymessage;
  if (invitenotifymessage) {
    set_has_invitenotifymessage();
  } else {
    clear_has_invitenotifymessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.inviteNotifyMessage)
}

// optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
inline bool PokerTHMessage::has_rejectgameinvitationmessage() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PokerTHMessage::set_has_rejectgameinvitationmessage() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PokerTHMessage::clear_has_rejectgameinvitationmessage() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PokerTHMessage::clear_rejectgameinvitationmessage() {
  if (rejectgameinvitationmessage_ != NULL) rejectgameinvitationmessage_->::RejectGameInvitationMessage::Clear();
  clear_has_rejectgameinvitationmessage();
}
inline const ::RejectGameInvitationMessage& PokerTHMessage::rejectgameinvitationmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.rejectGameInvitationMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rejectgameinvitationmessage_ != NULL ? *rejectgameinvitationmessage_ : *default_instance().rejectgameinvitationmessage_;
#else
  return rejectgameinvitationmessage_ != NULL ? *rejectgameinvitationmessage_ : *default_instance_->rejectgameinvitationmessage_;
#endif
}
inline ::RejectGameInvitationMessage* PokerTHMessage::mutable_rejectgameinvitationmessage() {
  set_has_rejectgameinvitationmessage();
  if (rejectgameinvitationmessage_ == NULL) rejectgameinvitationmessage_ = new ::RejectGameInvitationMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.rejectGameInvitationMessage)
  return rejectgameinvitationmessage_;
}
inline ::RejectGameInvitationMessage* PokerTHMessage::release_rejectgameinvitationmessage() {
  clear_has_rejectgameinvitationmessage();
  ::RejectGameInvitationMessage* temp = rejectgameinvitationmessage_;
  rejectgameinvitationmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_rejectgameinvitationmessage(::RejectGameInvitationMessage* rejectgameinvitationmessage) {
  delete rejectgameinvitationmessage_;
  rejectgameinvitationmessage_ = rejectgameinvitationmessage;
  if (rejectgameinvitationmessage) {
    set_has_rejectgameinvitationmessage();
  } else {
    clear_has_rejectgameinvitationmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.rejectGameInvitationMessage)
}

// optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
inline bool PokerTHMessage::has_rejectinvnotifymessage() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PokerTHMessage::set_has_rejectinvnotifymessage() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PokerTHMessage::clear_has_rejectinvnotifymessage() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PokerTHMessage::clear_rejectinvnotifymessage() {
  if (rejectinvnotifymessage_ != NULL) rejectinvnotifymessage_->::RejectInvNotifyMessage::Clear();
  clear_has_rejectinvnotifymessage();
}
inline const ::RejectInvNotifyMessage& PokerTHMessage::rejectinvnotifymessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.rejectInvNotifyMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rejectinvnotifymessage_ != NULL ? *rejectinvnotifymessage_ : *default_instance().rejectinvnotifymessage_;
#else
  return rejectinvnotifymessage_ != NULL ? *rejectinvnotifymessage_ : *default_instance_->rejectinvnotifymessage_;
#endif
}
inline ::RejectInvNotifyMessage* PokerTHMessage::mutable_rejectinvnotifymessage() {
  set_has_rejectinvnotifymessage();
  if (rejectinvnotifymessage_ == NULL) rejectinvnotifymessage_ = new ::RejectInvNotifyMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.rejectInvNotifyMessage)
  return rejectinvnotifymessage_;
}
inline ::RejectInvNotifyMessage* PokerTHMessage::release_rejectinvnotifymessage() {
  clear_has_rejectinvnotifymessage();
  ::RejectInvNotifyMessage* temp = rejectinvnotifymessage_;
  rejectinvnotifymessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_rejectinvnotifymessage(::RejectInvNotifyMessage* rejectinvnotifymessage) {
  delete rejectinvnotifymessage_;
  rejectinvnotifymessage_ = rejectinvnotifymessage;
  if (rejectinvnotifymessage) {
    set_has_rejectinvnotifymessage();
  } else {
    clear_has_rejectinvnotifymessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.rejectInvNotifyMessage)
}

// optional .StartEventMessage startEventMessage = 37;
inline bool PokerTHMessage::has_starteventmessage() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PokerTHMessage::set_has_starteventmessage() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PokerTHMessage::clear_has_starteventmessage() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PokerTHMessage::clear_starteventmessage() {
  if (starteventmessage_ != NULL) starteventmessage_->::StartEventMessage::Clear();
  clear_has_starteventmessage();
}
inline const ::StartEventMessage& PokerTHMessage::starteventmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.startEventMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return starteventmessage_ != NULL ? *starteventmessage_ : *default_instance().starteventmessage_;
#else
  return starteventmessage_ != NULL ? *starteventmessage_ : *default_instance_->starteventmessage_;
#endif
}
inline ::StartEventMessage* PokerTHMessage::mutable_starteventmessage() {
  set_has_starteventmessage();
  if (starteventmessage_ == NULL) starteventmessage_ = new ::StartEventMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.startEventMessage)
  return starteventmessage_;
}
inline ::StartEventMessage* PokerTHMessage::release_starteventmessage() {
  clear_has_starteventmessage();
  ::StartEventMessage* temp = starteventmessage_;
  starteventmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_starteventmessage(::StartEventMessage* starteventmessage) {
  delete starteventmessage_;
  starteventmessage_ = starteventmessage;
  if (starteventmessage) {
    set_has_starteventmessage();
  } else {
    clear_has_starteventmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.startEventMessage)
}

// optional .StartEventAckMessage startEventAckMessage = 38;
inline bool PokerTHMessage::has_starteventackmessage() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PokerTHMessage::set_has_starteventackmessage() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PokerTHMessage::clear_has_starteventackmessage() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PokerTHMessage::clear_starteventackmessage() {
  if (starteventackmessage_ != NULL) starteventackmessage_->::StartEventAckMessage::Clear();
  clear_has_starteventackmessage();
}
inline const ::StartEventAckMessage& PokerTHMessage::starteventackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.startEventAckMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return starteventackmessage_ != NULL ? *starteventackmessage_ : *default_instance().starteventackmessage_;
#else
  return starteventackmessage_ != NULL ? *starteventackmessage_ : *default_instance_->starteventackmessage_;
#endif
}
inline ::StartEventAckMessage* PokerTHMessage::mutable_starteventackmessage() {
  set_has_starteventackmessage();
  if (starteventackmessage_ == NULL) starteventackmessage_ = new ::StartEventAckMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.startEventAckMessage)
  return starteventackmessage_;
}
inline ::StartEventAckMessage* PokerTHMessage::release_starteventackmessage() {
  clear_has_starteventackmessage();
  ::StartEventAckMessage* temp = starteventackmessage_;
  starteventackmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_starteventackmessage(::StartEventAckMessage* starteventackmessage) {
  delete starteventackmessage_;
  starteventackmessage_ = starteventackmessage;
  if (starteventackmessage) {
    set_has_starteventackmessage();
  } else {
    clear_has_starteventackmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.startEventAckMessage)
}

// optional .GameStartInitialMessage gameStartInitialMessage = 39;
inline bool PokerTHMessage::has_gamestartinitialmessage() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PokerTHMessage::set_has_gamestartinitialmessage() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PokerTHMessage::clear_has_gamestartinitialmessage() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PokerTHMessage::clear_gamestartinitialmessage() {
  if (gamestartinitialmessage_ != NULL) gamestartinitialmessage_->::GameStartInitialMessage::Clear();
  clear_has_gamestartinitialmessage();
}
inline const ::GameStartInitialMessage& PokerTHMessage::gamestartinitialmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameStartInitialMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamestartinitialmessage_ != NULL ? *gamestartinitialmessage_ : *default_instance().gamestartinitialmessage_;
#else
  return gamestartinitialmessage_ != NULL ? *gamestartinitialmessage_ : *default_instance_->gamestartinitialmessage_;
#endif
}
inline ::GameStartInitialMessage* PokerTHMessage::mutable_gamestartinitialmessage() {
  set_has_gamestartinitialmessage();
  if (gamestartinitialmessage_ == NULL) gamestartinitialmessage_ = new ::GameStartInitialMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameStartInitialMessage)
  return gamestartinitialmessage_;
}
inline ::GameStartInitialMessage* PokerTHMessage::release_gamestartinitialmessage() {
  clear_has_gamestartinitialmessage();
  ::GameStartInitialMessage* temp = gamestartinitialmessage_;
  gamestartinitialmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamestartinitialmessage(::GameStartInitialMessage* gamestartinitialmessage) {
  delete gamestartinitialmessage_;
  gamestartinitialmessage_ = gamestartinitialmessage;
  if (gamestartinitialmessage) {
    set_has_gamestartinitialmessage();
  } else {
    clear_has_gamestartinitialmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameStartInitialMessage)
}

// optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
inline bool PokerTHMessage::has_gamestartrejoinmessage() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PokerTHMessage::set_has_gamestartrejoinmessage() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PokerTHMessage::clear_has_gamestartrejoinmessage() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PokerTHMessage::clear_gamestartrejoinmessage() {
  if (gamestartrejoinmessage_ != NULL) gamestartrejoinmessage_->::GameStartRejoinMessage::Clear();
  clear_has_gamestartrejoinmessage();
}
inline const ::GameStartRejoinMessage& PokerTHMessage::gamestartrejoinmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameStartRejoinMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamestartrejoinmessage_ != NULL ? *gamestartrejoinmessage_ : *default_instance().gamestartrejoinmessage_;
#else
  return gamestartrejoinmessage_ != NULL ? *gamestartrejoinmessage_ : *default_instance_->gamestartrejoinmessage_;
#endif
}
inline ::GameStartRejoinMessage* PokerTHMessage::mutable_gamestartrejoinmessage() {
  set_has_gamestartrejoinmessage();
  if (gamestartrejoinmessage_ == NULL) gamestartrejoinmessage_ = new ::GameStartRejoinMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameStartRejoinMessage)
  return gamestartrejoinmessage_;
}
inline ::GameStartRejoinMessage* PokerTHMessage::release_gamestartrejoinmessage() {
  clear_has_gamestartrejoinmessage();
  ::GameStartRejoinMessage* temp = gamestartrejoinmessage_;
  gamestartrejoinmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamestartrejoinmessage(::GameStartRejoinMessage* gamestartrejoinmessage) {
  delete gamestartrejoinmessage_;
  gamestartrejoinmessage_ = gamestartrejoinmessage;
  if (gamestartrejoinmessage) {
    set_has_gamestartrejoinmessage();
  } else {
    clear_has_gamestartrejoinmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameStartRejoinMessage)
}

// optional .HandStartMessage handStartMessage = 41;
inline bool PokerTHMessage::has_handstartmessage() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PokerTHMessage::set_has_handstartmessage() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PokerTHMessage::clear_has_handstartmessage() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PokerTHMessage::clear_handstartmessage() {
  if (handstartmessage_ != NULL) handstartmessage_->::HandStartMessage::Clear();
  clear_has_handstartmessage();
}
inline const ::HandStartMessage& PokerTHMessage::handstartmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.handStartMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return handstartmessage_ != NULL ? *handstartmessage_ : *default_instance().handstartmessage_;
#else
  return handstartmessage_ != NULL ? *handstartmessage_ : *default_instance_->handstartmessage_;
#endif
}
inline ::HandStartMessage* PokerTHMessage::mutable_handstartmessage() {
  set_has_handstartmessage();
  if (handstartmessage_ == NULL) handstartmessage_ = new ::HandStartMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.handStartMessage)
  return handstartmessage_;
}
inline ::HandStartMessage* PokerTHMessage::release_handstartmessage() {
  clear_has_handstartmessage();
  ::HandStartMessage* temp = handstartmessage_;
  handstartmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_handstartmessage(::HandStartMessage* handstartmessage) {
  delete handstartmessage_;
  handstartmessage_ = handstartmessage;
  if (handstartmessage) {
    set_has_handstartmessage();
  } else {
    clear_has_handstartmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.handStartMessage)
}

// optional .PlayersTurnMessage playersTurnMessage = 42;
inline bool PokerTHMessage::has_playersturnmessage() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PokerTHMessage::set_has_playersturnmessage() {
  _has_bits_[1] |= 0x00000200u;
}
inline void PokerTHMessage::clear_has_playersturnmessage() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void PokerTHMessage::clear_playersturnmessage() {
  if (playersturnmessage_ != NULL) playersturnmessage_->::PlayersTurnMessage::Clear();
  clear_has_playersturnmessage();
}
inline const ::PlayersTurnMessage& PokerTHMessage::playersturnmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playersTurnMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playersturnmessage_ != NULL ? *playersturnmessage_ : *default_instance().playersturnmessage_;
#else
  return playersturnmessage_ != NULL ? *playersturnmessage_ : *default_instance_->playersturnmessage_;
#endif
}
inline ::PlayersTurnMessage* PokerTHMessage::mutable_playersturnmessage() {
  set_has_playersturnmessage();
  if (playersturnmessage_ == NULL) playersturnmessage_ = new ::PlayersTurnMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playersTurnMessage)
  return playersturnmessage_;
}
inline ::PlayersTurnMessage* PokerTHMessage::release_playersturnmessage() {
  clear_has_playersturnmessage();
  ::PlayersTurnMessage* temp = playersturnmessage_;
  playersturnmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_playersturnmessage(::PlayersTurnMessage* playersturnmessage) {
  delete playersturnmessage_;
  playersturnmessage_ = playersturnmessage;
  if (playersturnmessage) {
    set_has_playersturnmessage();
  } else {
    clear_has_playersturnmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playersTurnMessage)
}

// optional .MyActionRequestMessage myActionRequestMessage = 43;
inline bool PokerTHMessage::has_myactionrequestmessage() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PokerTHMessage::set_has_myactionrequestmessage() {
  _has_bits_[1] |= 0x00000400u;
}
inline void PokerTHMessage::clear_has_myactionrequestmessage() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void PokerTHMessage::clear_myactionrequestmessage() {
  if (myactionrequestmessage_ != NULL) myactionrequestmessage_->::MyActionRequestMessage::Clear();
  clear_has_myactionrequestmessage();
}
inline const ::MyActionRequestMessage& PokerTHMessage::myactionrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.myActionRequestMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return myactionrequestmessage_ != NULL ? *myactionrequestmessage_ : *default_instance().myactionrequestmessage_;
#else
  return myactionrequestmessage_ != NULL ? *myactionrequestmessage_ : *default_instance_->myactionrequestmessage_;
#endif
}
inline ::MyActionRequestMessage* PokerTHMessage::mutable_myactionrequestmessage() {
  set_has_myactionrequestmessage();
  if (myactionrequestmessage_ == NULL) myactionrequestmessage_ = new ::MyActionRequestMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.myActionRequestMessage)
  return myactionrequestmessage_;
}
inline ::MyActionRequestMessage* PokerTHMessage::release_myactionrequestmessage() {
  clear_has_myactionrequestmessage();
  ::MyActionRequestMessage* temp = myactionrequestmessage_;
  myactionrequestmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_myactionrequestmessage(::MyActionRequestMessage* myactionrequestmessage) {
  delete myactionrequestmessage_;
  myactionrequestmessage_ = myactionrequestmessage;
  if (myactionrequestmessage) {
    set_has_myactionrequestmessage();
  } else {
    clear_has_myactionrequestmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.myActionRequestMessage)
}

// optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
inline bool PokerTHMessage::has_youractionrejectedmessage() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void PokerTHMessage::set_has_youractionrejectedmessage() {
  _has_bits_[1] |= 0x00000800u;
}
inline void PokerTHMessage::clear_has_youractionrejectedmessage() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void PokerTHMessage::clear_youractionrejectedmessage() {
  if (youractionrejectedmessage_ != NULL) youractionrejectedmessage_->::YourActionRejectedMessage::Clear();
  clear_has_youractionrejectedmessage();
}
inline const ::YourActionRejectedMessage& PokerTHMessage::youractionrejectedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.yourActionRejectedMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return youractionrejectedmessage_ != NULL ? *youractionrejectedmessage_ : *default_instance().youractionrejectedmessage_;
#else
  return youractionrejectedmessage_ != NULL ? *youractionrejectedmessage_ : *default_instance_->youractionrejectedmessage_;
#endif
}
inline ::YourActionRejectedMessage* PokerTHMessage::mutable_youractionrejectedmessage() {
  set_has_youractionrejectedmessage();
  if (youractionrejectedmessage_ == NULL) youractionrejectedmessage_ = new ::YourActionRejectedMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.yourActionRejectedMessage)
  return youractionrejectedmessage_;
}
inline ::YourActionRejectedMessage* PokerTHMessage::release_youractionrejectedmessage() {
  clear_has_youractionrejectedmessage();
  ::YourActionRejectedMessage* temp = youractionrejectedmessage_;
  youractionrejectedmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_youractionrejectedmessage(::YourActionRejectedMessage* youractionrejectedmessage) {
  delete youractionrejectedmessage_;
  youractionrejectedmessage_ = youractionrejectedmessage;
  if (youractionrejectedmessage) {
    set_has_youractionrejectedmessage();
  } else {
    clear_has_youractionrejectedmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.yourActionRejectedMessage)
}

// optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
inline bool PokerTHMessage::has_playersactiondonemessage() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void PokerTHMessage::set_has_playersactiondonemessage() {
  _has_bits_[1] |= 0x00001000u;
}
inline void PokerTHMessage::clear_has_playersactiondonemessage() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void PokerTHMessage::clear_playersactiondonemessage() {
  if (playersactiondonemessage_ != NULL) playersactiondonemessage_->::PlayersActionDoneMessage::Clear();
  clear_has_playersactiondonemessage();
}
inline const ::PlayersActionDoneMessage& PokerTHMessage::playersactiondonemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playersActionDoneMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playersactiondonemessage_ != NULL ? *playersactiondonemessage_ : *default_instance().playersactiondonemessage_;
#else
  return playersactiondonemessage_ != NULL ? *playersactiondonemessage_ : *default_instance_->playersactiondonemessage_;
#endif
}
inline ::PlayersActionDoneMessage* PokerTHMessage::mutable_playersactiondonemessage() {
  set_has_playersactiondonemessage();
  if (playersactiondonemessage_ == NULL) playersactiondonemessage_ = new ::PlayersActionDoneMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playersActionDoneMessage)
  return playersactiondonemessage_;
}
inline ::PlayersActionDoneMessage* PokerTHMessage::release_playersactiondonemessage() {
  clear_has_playersactiondonemessage();
  ::PlayersActionDoneMessage* temp = playersactiondonemessage_;
  playersactiondonemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_playersactiondonemessage(::PlayersActionDoneMessage* playersactiondonemessage) {
  delete playersactiondonemessage_;
  playersactiondonemessage_ = playersactiondonemessage;
  if (playersactiondonemessage) {
    set_has_playersactiondonemessage();
  } else {
    clear_has_playersactiondonemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playersActionDoneMessage)
}

// optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
inline bool PokerTHMessage::has_dealflopcardsmessage() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void PokerTHMessage::set_has_dealflopcardsmessage() {
  _has_bits_[1] |= 0x00002000u;
}
inline void PokerTHMessage::clear_has_dealflopcardsmessage() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void PokerTHMessage::clear_dealflopcardsmessage() {
  if (dealflopcardsmessage_ != NULL) dealflopcardsmessage_->::DealFlopCardsMessage::Clear();
  clear_has_dealflopcardsmessage();
}
inline const ::DealFlopCardsMessage& PokerTHMessage::dealflopcardsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.dealFlopCardsMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dealflopcardsmessage_ != NULL ? *dealflopcardsmessage_ : *default_instance().dealflopcardsmessage_;
#else
  return dealflopcardsmessage_ != NULL ? *dealflopcardsmessage_ : *default_instance_->dealflopcardsmessage_;
#endif
}
inline ::DealFlopCardsMessage* PokerTHMessage::mutable_dealflopcardsmessage() {
  set_has_dealflopcardsmessage();
  if (dealflopcardsmessage_ == NULL) dealflopcardsmessage_ = new ::DealFlopCardsMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dealFlopCardsMessage)
  return dealflopcardsmessage_;
}
inline ::DealFlopCardsMessage* PokerTHMessage::release_dealflopcardsmessage() {
  clear_has_dealflopcardsmessage();
  ::DealFlopCardsMessage* temp = dealflopcardsmessage_;
  dealflopcardsmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_dealflopcardsmessage(::DealFlopCardsMessage* dealflopcardsmessage) {
  delete dealflopcardsmessage_;
  dealflopcardsmessage_ = dealflopcardsmessage;
  if (dealflopcardsmessage) {
    set_has_dealflopcardsmessage();
  } else {
    clear_has_dealflopcardsmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dealFlopCardsMessage)
}

// optional .DealTurnCardMessage dealTurnCardMessage = 47;
inline bool PokerTHMessage::has_dealturncardmessage() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void PokerTHMessage::set_has_dealturncardmessage() {
  _has_bits_[1] |= 0x00004000u;
}
inline void PokerTHMessage::clear_has_dealturncardmessage() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void PokerTHMessage::clear_dealturncardmessage() {
  if (dealturncardmessage_ != NULL) dealturncardmessage_->::DealTurnCardMessage::Clear();
  clear_has_dealturncardmessage();
}
inline const ::DealTurnCardMessage& PokerTHMessage::dealturncardmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.dealTurnCardMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dealturncardmessage_ != NULL ? *dealturncardmessage_ : *default_instance().dealturncardmessage_;
#else
  return dealturncardmessage_ != NULL ? *dealturncardmessage_ : *default_instance_->dealturncardmessage_;
#endif
}
inline ::DealTurnCardMessage* PokerTHMessage::mutable_dealturncardmessage() {
  set_has_dealturncardmessage();
  if (dealturncardmessage_ == NULL) dealturncardmessage_ = new ::DealTurnCardMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dealTurnCardMessage)
  return dealturncardmessage_;
}
inline ::DealTurnCardMessage* PokerTHMessage::release_dealturncardmessage() {
  clear_has_dealturncardmessage();
  ::DealTurnCardMessage* temp = dealturncardmessage_;
  dealturncardmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_dealturncardmessage(::DealTurnCardMessage* dealturncardmessage) {
  delete dealturncardmessage_;
  dealturncardmessage_ = dealturncardmessage;
  if (dealturncardmessage) {
    set_has_dealturncardmessage();
  } else {
    clear_has_dealturncardmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dealTurnCardMessage)
}

// optional .DealRiverCardMessage dealRiverCardMessage = 48;
inline bool PokerTHMessage::has_dealrivercardmessage() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void PokerTHMessage::set_has_dealrivercardmessage() {
  _has_bits_[1] |= 0x00008000u;
}
inline void PokerTHMessage::clear_has_dealrivercardmessage() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void PokerTHMessage::clear_dealrivercardmessage() {
  if (dealrivercardmessage_ != NULL) dealrivercardmessage_->::DealRiverCardMessage::Clear();
  clear_has_dealrivercardmessage();
}
inline const ::DealRiverCardMessage& PokerTHMessage::dealrivercardmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.dealRiverCardMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dealrivercardmessage_ != NULL ? *dealrivercardmessage_ : *default_instance().dealrivercardmessage_;
#else
  return dealrivercardmessage_ != NULL ? *dealrivercardmessage_ : *default_instance_->dealrivercardmessage_;
#endif
}
inline ::DealRiverCardMessage* PokerTHMessage::mutable_dealrivercardmessage() {
  set_has_dealrivercardmessage();
  if (dealrivercardmessage_ == NULL) dealrivercardmessage_ = new ::DealRiverCardMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dealRiverCardMessage)
  return dealrivercardmessage_;
}
inline ::DealRiverCardMessage* PokerTHMessage::release_dealrivercardmessage() {
  clear_has_dealrivercardmessage();
  ::DealRiverCardMessage* temp = dealrivercardmessage_;
  dealrivercardmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_dealrivercardmessage(::DealRiverCardMessage* dealrivercardmessage) {
  delete dealrivercardmessage_;
  dealrivercardmessage_ = dealrivercardmessage;
  if (dealrivercardmessage) {
    set_has_dealrivercardmessage();
  } else {
    clear_has_dealrivercardmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dealRiverCardMessage)
}

// optional .AllInShowCardsMessage allInShowCardsMessage = 49;
inline bool PokerTHMessage::has_allinshowcardsmessage() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void PokerTHMessage::set_has_allinshowcardsmessage() {
  _has_bits_[1] |= 0x00010000u;
}
inline void PokerTHMessage::clear_has_allinshowcardsmessage() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void PokerTHMessage::clear_allinshowcardsmessage() {
  if (allinshowcardsmessage_ != NULL) allinshowcardsmessage_->::AllInShowCardsMessage::Clear();
  clear_has_allinshowcardsmessage();
}
inline const ::AllInShowCardsMessage& PokerTHMessage::allinshowcardsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.allInShowCardsMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return allinshowcardsmessage_ != NULL ? *allinshowcardsmessage_ : *default_instance().allinshowcardsmessage_;
#else
  return allinshowcardsmessage_ != NULL ? *allinshowcardsmessage_ : *default_instance_->allinshowcardsmessage_;
#endif
}
inline ::AllInShowCardsMessage* PokerTHMessage::mutable_allinshowcardsmessage() {
  set_has_allinshowcardsmessage();
  if (allinshowcardsmessage_ == NULL) allinshowcardsmessage_ = new ::AllInShowCardsMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.allInShowCardsMessage)
  return allinshowcardsmessage_;
}
inline ::AllInShowCardsMessage* PokerTHMessage::release_allinshowcardsmessage() {
  clear_has_allinshowcardsmessage();
  ::AllInShowCardsMessage* temp = allinshowcardsmessage_;
  allinshowcardsmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_allinshowcardsmessage(::AllInShowCardsMessage* allinshowcardsmessage) {
  delete allinshowcardsmessage_;
  allinshowcardsmessage_ = allinshowcardsmessage;
  if (allinshowcardsmessage) {
    set_has_allinshowcardsmessage();
  } else {
    clear_has_allinshowcardsmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.allInShowCardsMessage)
}

// optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
inline bool PokerTHMessage::has_endofhandshowcardsmessage() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void PokerTHMessage::set_has_endofhandshowcardsmessage() {
  _has_bits_[1] |= 0x00020000u;
}
inline void PokerTHMessage::clear_has_endofhandshowcardsmessage() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void PokerTHMessage::clear_endofhandshowcardsmessage() {
  if (endofhandshowcardsmessage_ != NULL) endofhandshowcardsmessage_->::EndOfHandShowCardsMessage::Clear();
  clear_has_endofhandshowcardsmessage();
}
inline const ::EndOfHandShowCardsMessage& PokerTHMessage::endofhandshowcardsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.endOfHandShowCardsMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return endofhandshowcardsmessage_ != NULL ? *endofhandshowcardsmessage_ : *default_instance().endofhandshowcardsmessage_;
#else
  return endofhandshowcardsmessage_ != NULL ? *endofhandshowcardsmessage_ : *default_instance_->endofhandshowcardsmessage_;
#endif
}
inline ::EndOfHandShowCardsMessage* PokerTHMessage::mutable_endofhandshowcardsmessage() {
  set_has_endofhandshowcardsmessage();
  if (endofhandshowcardsmessage_ == NULL) endofhandshowcardsmessage_ = new ::EndOfHandShowCardsMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endOfHandShowCardsMessage)
  return endofhandshowcardsmessage_;
}
inline ::EndOfHandShowCardsMessage* PokerTHMessage::release_endofhandshowcardsmessage() {
  clear_has_endofhandshowcardsmessage();
  ::EndOfHandShowCardsMessage* temp = endofhandshowcardsmessage_;
  endofhandshowcardsmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_endofhandshowcardsmessage(::EndOfHandShowCardsMessage* endofhandshowcardsmessage) {
  delete endofhandshowcardsmessage_;
  endofhandshowcardsmessage_ = endofhandshowcardsmessage;
  if (endofhandshowcardsmessage) {
    set_has_endofhandshowcardsmessage();
  } else {
    clear_has_endofhandshowcardsmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endOfHandShowCardsMessage)
}

// optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
inline bool PokerTHMessage::has_endofhandhidecardsmessage() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void PokerTHMessage::set_has_endofhandhidecardsmessage() {
  _has_bits_[1] |= 0x00040000u;
}
inline void PokerTHMessage::clear_has_endofhandhidecardsmessage() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void PokerTHMessage::clear_endofhandhidecardsmessage() {
  if (endofhandhidecardsmessage_ != NULL) endofhandhidecardsmessage_->::EndOfHandHideCardsMessage::Clear();
  clear_has_endofhandhidecardsmessage();
}
inline const ::EndOfHandHideCardsMessage& PokerTHMessage::endofhandhidecardsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.endOfHandHideCardsMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return endofhandhidecardsmessage_ != NULL ? *endofhandhidecardsmessage_ : *default_instance().endofhandhidecardsmessage_;
#else
  return endofhandhidecardsmessage_ != NULL ? *endofhandhidecardsmessage_ : *default_instance_->endofhandhidecardsmessage_;
#endif
}
inline ::EndOfHandHideCardsMessage* PokerTHMessage::mutable_endofhandhidecardsmessage() {
  set_has_endofhandhidecardsmessage();
  if (endofhandhidecardsmessage_ == NULL) endofhandhidecardsmessage_ = new ::EndOfHandHideCardsMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endOfHandHideCardsMessage)
  return endofhandhidecardsmessage_;
}
inline ::EndOfHandHideCardsMessage* PokerTHMessage::release_endofhandhidecardsmessage() {
  clear_has_endofhandhidecardsmessage();
  ::EndOfHandHideCardsMessage* temp = endofhandhidecardsmessage_;
  endofhandhidecardsmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_endofhandhidecardsmessage(::EndOfHandHideCardsMessage* endofhandhidecardsmessage) {
  delete endofhandhidecardsmessage_;
  endofhandhidecardsmessage_ = endofhandhidecardsmessage;
  if (endofhandhidecardsmessage) {
    set_has_endofhandhidecardsmessage();
  } else {
    clear_has_endofhandhidecardsmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endOfHandHideCardsMessage)
}

// optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
inline bool PokerTHMessage::has_showmycardsrequestmessage() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void PokerTHMessage::set_has_showmycardsrequestmessage() {
  _has_bits_[1] |= 0x00080000u;
}
inline void PokerTHMessage::clear_has_showmycardsrequestmessage() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void PokerTHMessage::clear_showmycardsrequestmessage() {
  if (showmycardsrequestmessage_ != NULL) showmycardsrequestmessage_->::ShowMyCardsRequestMessage::Clear();
  clear_has_showmycardsrequestmessage();
}
inline const ::ShowMyCardsRequestMessage& PokerTHMessage::showmycardsrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.showMyCardsRequestMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return showmycardsrequestmessage_ != NULL ? *showmycardsrequestmessage_ : *default_instance().showmycardsrequestmessage_;
#else
  return showmycardsrequestmessage_ != NULL ? *showmycardsrequestmessage_ : *default_instance_->showmycardsrequestmessage_;
#endif
}
inline ::ShowMyCardsRequestMessage* PokerTHMessage::mutable_showmycardsrequestmessage() {
  set_has_showmycardsrequestmessage();
  if (showmycardsrequestmessage_ == NULL) showmycardsrequestmessage_ = new ::ShowMyCardsRequestMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.showMyCardsRequestMessage)
  return showmycardsrequestmessage_;
}
inline ::ShowMyCardsRequestMessage* PokerTHMessage::release_showmycardsrequestmessage() {
  clear_has_showmycardsrequestmessage();
  ::ShowMyCardsRequestMessage* temp = showmycardsrequestmessage_;
  showmycardsrequestmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_showmycardsrequestmessage(::ShowMyCardsRequestMessage* showmycardsrequestmessage) {
  delete showmycardsrequestmessage_;
  showmycardsrequestmessage_ = showmycardsrequestmessage;
  if (showmycardsrequestmessage) {
    set_has_showmycardsrequestmessage();
  } else {
    clear_has_showmycardsrequestmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.showMyCardsRequestMessage)
}

// optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
inline bool PokerTHMessage::has_afterhandshowcardsmessage() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void PokerTHMessage::set_has_afterhandshowcardsmessage() {
  _has_bits_[1] |= 0x00100000u;
}
inline void PokerTHMessage::clear_has_afterhandshowcardsmessage() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void PokerTHMessage::clear_afterhandshowcardsmessage() {
  if (afterhandshowcardsmessage_ != NULL) afterhandshowcardsmessage_->::AfterHandShowCardsMessage::Clear();
  clear_has_afterhandshowcardsmessage();
}
inline const ::AfterHandShowCardsMessage& PokerTHMessage::afterhandshowcardsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.afterHandShowCardsMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return afterhandshowcardsmessage_ != NULL ? *afterhandshowcardsmessage_ : *default_instance().afterhandshowcardsmessage_;
#else
  return afterhandshowcardsmessage_ != NULL ? *afterhandshowcardsmessage_ : *default_instance_->afterhandshowcardsmessage_;
#endif
}
inline ::AfterHandShowCardsMessage* PokerTHMessage::mutable_afterhandshowcardsmessage() {
  set_has_afterhandshowcardsmessage();
  if (afterhandshowcardsmessage_ == NULL) afterhandshowcardsmessage_ = new ::AfterHandShowCardsMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.afterHandShowCardsMessage)
  return afterhandshowcardsmessage_;
}
inline ::AfterHandShowCardsMessage* PokerTHMessage::release_afterhandshowcardsmessage() {
  clear_has_afterhandshowcardsmessage();
  ::AfterHandShowCardsMessage* temp = afterhandshowcardsmessage_;
  afterhandshowcardsmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_afterhandshowcardsmessage(::AfterHandShowCardsMessage* afterhandshowcardsmessage) {
  delete afterhandshowcardsmessage_;
  afterhandshowcardsmessage_ = afterhandshowcardsmessage;
  if (afterhandshowcardsmessage) {
    set_has_afterhandshowcardsmessage();
  } else {
    clear_has_afterhandshowcardsmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.afterHandShowCardsMessage)
}

// optional .EndOfGameMessage endOfGameMessage = 54;
inline bool PokerTHMessage::has_endofgamemessage() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void PokerTHMessage::set_has_endofgamemessage() {
  _has_bits_[1] |= 0x00200000u;
}
inline void PokerTHMessage::clear_has_endofgamemessage() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void PokerTHMessage::clear_endofgamemessage() {
  if (endofgamemessage_ != NULL) endofgamemessage_->::EndOfGameMessage::Clear();
  clear_has_endofgamemessage();
}
inline const ::EndOfGameMessage& PokerTHMessage::endofgamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.endOfGameMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return endofgamemessage_ != NULL ? *endofgamemessage_ : *default_instance().endofgamemessage_;
#else
  return endofgamemessage_ != NULL ? *endofgamemessage_ : *default_instance_->endofgamemessage_;
#endif
}
inline ::EndOfGameMessage* PokerTHMessage::mutable_endofgamemessage() {
  set_has_endofgamemessage();
  if (endofgamemessage_ == NULL) endofgamemessage_ = new ::EndOfGameMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endOfGameMessage)
  return endofgamemessage_;
}
inline ::EndOfGameMessage* PokerTHMessage::release_endofgamemessage() {
  clear_has_endofgamemessage();
  ::EndOfGameMessage* temp = endofgamemessage_;
  endofgamemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_endofgamemessage(::EndOfGameMessage* endofgamemessage) {
  delete endofgamemessage_;
  endofgamemessage_ = endofgamemessage;
  if (endofgamemessage) {
    set_has_endofgamemessage();
  } else {
    clear_has_endofgamemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endOfGameMessage)
}

// optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
inline bool PokerTHMessage::has_playeridchangedmessage() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void PokerTHMessage::set_has_playeridchangedmessage() {
  _has_bits_[1] |= 0x00400000u;
}
inline void PokerTHMessage::clear_has_playeridchangedmessage() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void PokerTHMessage::clear_playeridchangedmessage() {
  if (playeridchangedmessage_ != NULL) playeridchangedmessage_->::PlayerIdChangedMessage::Clear();
  clear_has_playeridchangedmessage();
}
inline const ::PlayerIdChangedMessage& PokerTHMessage::playeridchangedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerIdChangedMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playeridchangedmessage_ != NULL ? *playeridchangedmessage_ : *default_instance().playeridchangedmessage_;
#else
  return playeridchangedmessage_ != NULL ? *playeridchangedmessage_ : *default_instance_->playeridchangedmessage_;
#endif
}
inline ::PlayerIdChangedMessage* PokerTHMessage::mutable_playeridchangedmessage() {
  set_has_playeridchangedmessage();
  if (playeridchangedmessage_ == NULL) playeridchangedmessage_ = new ::PlayerIdChangedMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerIdChangedMessage)
  return playeridchangedmessage_;
}
inline ::PlayerIdChangedMessage* PokerTHMessage::release_playeridchangedmessage() {
  clear_has_playeridchangedmessage();
  ::PlayerIdChangedMessage* temp = playeridchangedmessage_;
  playeridchangedmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_playeridchangedmessage(::PlayerIdChangedMessage* playeridchangedmessage) {
  delete playeridchangedmessage_;
  playeridchangedmessage_ = playeridchangedmessage;
  if (playeridchangedmessage) {
    set_has_playeridchangedmessage();
  } else {
    clear_has_playeridchangedmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerIdChangedMessage)
}

// optional .AskKickPlayerMessage askKickPlayerMessage = 56;
inline bool PokerTHMessage::has_askkickplayermessage() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void PokerTHMessage::set_has_askkickplayermessage() {
  _has_bits_[1] |= 0x00800000u;
}
inline void PokerTHMessage::clear_has_askkickplayermessage() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void PokerTHMessage::clear_askkickplayermessage() {
  if (askkickplayermessage_ != NULL) askkickplayermessage_->::AskKickPlayerMessage::Clear();
  clear_has_askkickplayermessage();
}
inline const ::AskKickPlayerMessage& PokerTHMessage::askkickplayermessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.askKickPlayerMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return askkickplayermessage_ != NULL ? *askkickplayermessage_ : *default_instance().askkickplayermessage_;
#else
  return askkickplayermessage_ != NULL ? *askkickplayermessage_ : *default_instance_->askkickplayermessage_;
#endif
}
inline ::AskKickPlayerMessage* PokerTHMessage::mutable_askkickplayermessage() {
  set_has_askkickplayermessage();
  if (askkickplayermessage_ == NULL) askkickplayermessage_ = new ::AskKickPlayerMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.askKickPlayerMessage)
  return askkickplayermessage_;
}
inline ::AskKickPlayerMessage* PokerTHMessage::release_askkickplayermessage() {
  clear_has_askkickplayermessage();
  ::AskKickPlayerMessage* temp = askkickplayermessage_;
  askkickplayermessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_askkickplayermessage(::AskKickPlayerMessage* askkickplayermessage) {
  delete askkickplayermessage_;
  askkickplayermessage_ = askkickplayermessage;
  if (askkickplayermessage) {
    set_has_askkickplayermessage();
  } else {
    clear_has_askkickplayermessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.askKickPlayerMessage)
}

// optional .AskKickDeniedMessage askKickDeniedMessage = 57;
inline bool PokerTHMessage::has_askkickdeniedmessage() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void PokerTHMessage::set_has_askkickdeniedmessage() {
  _has_bits_[1] |= 0x01000000u;
}
inline void PokerTHMessage::clear_has_askkickdeniedmessage() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void PokerTHMessage::clear_askkickdeniedmessage() {
  if (askkickdeniedmessage_ != NULL) askkickdeniedmessage_->::AskKickDeniedMessage::Clear();
  clear_has_askkickdeniedmessage();
}
inline const ::AskKickDeniedMessage& PokerTHMessage::askkickdeniedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.askKickDeniedMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return askkickdeniedmessage_ != NULL ? *askkickdeniedmessage_ : *default_instance().askkickdeniedmessage_;
#else
  return askkickdeniedmessage_ != NULL ? *askkickdeniedmessage_ : *default_instance_->askkickdeniedmessage_;
#endif
}
inline ::AskKickDeniedMessage* PokerTHMessage::mutable_askkickdeniedmessage() {
  set_has_askkickdeniedmessage();
  if (askkickdeniedmessage_ == NULL) askkickdeniedmessage_ = new ::AskKickDeniedMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.askKickDeniedMessage)
  return askkickdeniedmessage_;
}
inline ::AskKickDeniedMessage* PokerTHMessage::release_askkickdeniedmessage() {
  clear_has_askkickdeniedmessage();
  ::AskKickDeniedMessage* temp = askkickdeniedmessage_;
  askkickdeniedmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_askkickdeniedmessage(::AskKickDeniedMessage* askkickdeniedmessage) {
  delete askkickdeniedmessage_;
  askkickdeniedmessage_ = askkickdeniedmessage;
  if (askkickdeniedmessage) {
    set_has_askkickdeniedmessage();
  } else {
    clear_has_askkickdeniedmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.askKickDeniedMessage)
}

// optional .StartKickPetitionMessage startKickPetitionMessage = 58;
inline bool PokerTHMessage::has_startkickpetitionmessage() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void PokerTHMessage::set_has_startkickpetitionmessage() {
  _has_bits_[1] |= 0x02000000u;
}
inline void PokerTHMessage::clear_has_startkickpetitionmessage() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void PokerTHMessage::clear_startkickpetitionmessage() {
  if (startkickpetitionmessage_ != NULL) startkickpetitionmessage_->::StartKickPetitionMessage::Clear();
  clear_has_startkickpetitionmessage();
}
inline const ::StartKickPetitionMessage& PokerTHMessage::startkickpetitionmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.startKickPetitionMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return startkickpetitionmessage_ != NULL ? *startkickpetitionmessage_ : *default_instance().startkickpetitionmessage_;
#else
  return startkickpetitionmessage_ != NULL ? *startkickpetitionmessage_ : *default_instance_->startkickpetitionmessage_;
#endif
}
inline ::StartKickPetitionMessage* PokerTHMessage::mutable_startkickpetitionmessage() {
  set_has_startkickpetitionmessage();
  if (startkickpetitionmessage_ == NULL) startkickpetitionmessage_ = new ::StartKickPetitionMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.startKickPetitionMessage)
  return startkickpetitionmessage_;
}
inline ::StartKickPetitionMessage* PokerTHMessage::release_startkickpetitionmessage() {
  clear_has_startkickpetitionmessage();
  ::StartKickPetitionMessage* temp = startkickpetitionmessage_;
  startkickpetitionmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_startkickpetitionmessage(::StartKickPetitionMessage* startkickpetitionmessage) {
  delete startkickpetitionmessage_;
  startkickpetitionmessage_ = startkickpetitionmessage;
  if (startkickpetitionmessage) {
    set_has_startkickpetitionmessage();
  } else {
    clear_has_startkickpetitionmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.startKickPetitionMessage)
}

// optional .VoteKickRequestMessage voteKickRequestMessage = 59;
inline bool PokerTHMessage::has_votekickrequestmessage() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void PokerTHMessage::set_has_votekickrequestmessage() {
  _has_bits_[1] |= 0x04000000u;
}
inline void PokerTHMessage::clear_has_votekickrequestmessage() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void PokerTHMessage::clear_votekickrequestmessage() {
  if (votekickrequestmessage_ != NULL) votekickrequestmessage_->::VoteKickRequestMessage::Clear();
  clear_has_votekickrequestmessage();
}
inline const ::VoteKickRequestMessage& PokerTHMessage::votekickrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.voteKickRequestMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return votekickrequestmessage_ != NULL ? *votekickrequestmessage_ : *default_instance().votekickrequestmessage_;
#else
  return votekickrequestmessage_ != NULL ? *votekickrequestmessage_ : *default_instance_->votekickrequestmessage_;
#endif
}
inline ::VoteKickRequestMessage* PokerTHMessage::mutable_votekickrequestmessage() {
  set_has_votekickrequestmessage();
  if (votekickrequestmessage_ == NULL) votekickrequestmessage_ = new ::VoteKickRequestMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.voteKickRequestMessage)
  return votekickrequestmessage_;
}
inline ::VoteKickRequestMessage* PokerTHMessage::release_votekickrequestmessage() {
  clear_has_votekickrequestmessage();
  ::VoteKickRequestMessage* temp = votekickrequestmessage_;
  votekickrequestmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_votekickrequestmessage(::VoteKickRequestMessage* votekickrequestmessage) {
  delete votekickrequestmessage_;
  votekickrequestmessage_ = votekickrequestmessage;
  if (votekickrequestmessage) {
    set_has_votekickrequestmessage();
  } else {
    clear_has_votekickrequestmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.voteKickRequestMessage)
}

// optional .VoteKickReplyMessage voteKickReplyMessage = 60;
inline bool PokerTHMessage::has_votekickreplymessage() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void PokerTHMessage::set_has_votekickreplymessage() {
  _has_bits_[1] |= 0x08000000u;
}
inline void PokerTHMessage::clear_has_votekickreplymessage() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void PokerTHMessage::clear_votekickreplymessage() {
  if (votekickreplymessage_ != NULL) votekickreplymessage_->::VoteKickReplyMessage::Clear();
  clear_has_votekickreplymessage();
}
inline const ::VoteKickReplyMessage& PokerTHMessage::votekickreplymessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.voteKickReplyMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return votekickreplymessage_ != NULL ? *votekickreplymessage_ : *default_instance().votekickreplymessage_;
#else
  return votekickreplymessage_ != NULL ? *votekickreplymessage_ : *default_instance_->votekickreplymessage_;
#endif
}
inline ::VoteKickReplyMessage* PokerTHMessage::mutable_votekickreplymessage() {
  set_has_votekickreplymessage();
  if (votekickreplymessage_ == NULL) votekickreplymessage_ = new ::VoteKickReplyMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.voteKickReplyMessage)
  return votekickreplymessage_;
}
inline ::VoteKickReplyMessage* PokerTHMessage::release_votekickreplymessage() {
  clear_has_votekickreplymessage();
  ::VoteKickReplyMessage* temp = votekickreplymessage_;
  votekickreplymessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_votekickreplymessage(::VoteKickReplyMessage* votekickreplymessage) {
  delete votekickreplymessage_;
  votekickreplymessage_ = votekickreplymessage;
  if (votekickreplymessage) {
    set_has_votekickreplymessage();
  } else {
    clear_has_votekickreplymessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.voteKickReplyMessage)
}

// optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
inline bool PokerTHMessage::has_kickpetitionupdatemessage() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void PokerTHMessage::set_has_kickpetitionupdatemessage() {
  _has_bits_[1] |= 0x10000000u;
}
inline void PokerTHMessage::clear_has_kickpetitionupdatemessage() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void PokerTHMessage::clear_kickpetitionupdatemessage() {
  if (kickpetitionupdatemessage_ != NULL) kickpetitionupdatemessage_->::KickPetitionUpdateMessage::Clear();
  clear_has_kickpetitionupdatemessage();
}
inline const ::KickPetitionUpdateMessage& PokerTHMessage::kickpetitionupdatemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.kickPetitionUpdateMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return kickpetitionupdatemessage_ != NULL ? *kickpetitionupdatemessage_ : *default_instance().kickpetitionupdatemessage_;
#else
  return kickpetitionupdatemessage_ != NULL ? *kickpetitionupdatemessage_ : *default_instance_->kickpetitionupdatemessage_;
#endif
}
inline ::KickPetitionUpdateMessage* PokerTHMessage::mutable_kickpetitionupdatemessage() {
  set_has_kickpetitionupdatemessage();
  if (kickpetitionupdatemessage_ == NULL) kickpetitionupdatemessage_ = new ::KickPetitionUpdateMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.kickPetitionUpdateMessage)
  return kickpetitionupdatemessage_;
}
inline ::KickPetitionUpdateMessage* PokerTHMessage::release_kickpetitionupdatemessage() {
  clear_has_kickpetitionupdatemessage();
  ::KickPetitionUpdateMessage* temp = kickpetitionupdatemessage_;
  kickpetitionupdatemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_kickpetitionupdatemessage(::KickPetitionUpdateMessage* kickpetitionupdatemessage) {
  delete kickpetitionupdatemessage_;
  kickpetitionupdatemessage_ = kickpetitionupdatemessage;
  if (kickpetitionupdatemessage) {
    set_has_kickpetitionupdatemessage();
  } else {
    clear_has_kickpetitionupdatemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.kickPetitionUpdateMessage)
}

// optional .EndKickPetitionMessage endKickPetitionMessage = 62;
inline bool PokerTHMessage::has_endkickpetitionmessage() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void PokerTHMessage::set_has_endkickpetitionmessage() {
  _has_bits_[1] |= 0x20000000u;
}
inline void PokerTHMessage::clear_has_endkickpetitionmessage() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void PokerTHMessage::clear_endkickpetitionmessage() {
  if (endkickpetitionmessage_ != NULL) endkickpetitionmessage_->::EndKickPetitionMessage::Clear();
  clear_has_endkickpetitionmessage();
}
inline const ::EndKickPetitionMessage& PokerTHMessage::endkickpetitionmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.endKickPetitionMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return endkickpetitionmessage_ != NULL ? *endkickpetitionmessage_ : *default_instance().endkickpetitionmessage_;
#else
  return endkickpetitionmessage_ != NULL ? *endkickpetitionmessage_ : *default_instance_->endkickpetitionmessage_;
#endif
}
inline ::EndKickPetitionMessage* PokerTHMessage::mutable_endkickpetitionmessage() {
  set_has_endkickpetitionmessage();
  if (endkickpetitionmessage_ == NULL) endkickpetitionmessage_ = new ::EndKickPetitionMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endKickPetitionMessage)
  return endkickpetitionmessage_;
}
inline ::EndKickPetitionMessage* PokerTHMessage::release_endkickpetitionmessage() {
  clear_has_endkickpetitionmessage();
  ::EndKickPetitionMessage* temp = endkickpetitionmessage_;
  endkickpetitionmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_endkickpetitionmessage(::EndKickPetitionMessage* endkickpetitionmessage) {
  delete endkickpetitionmessage_;
  endkickpetitionmessage_ = endkickpetitionmessage;
  if (endkickpetitionmessage) {
    set_has_endkickpetitionmessage();
  } else {
    clear_has_endkickpetitionmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endKickPetitionMessage)
}

// optional .StatisticsMessage statisticsMessage = 63;
inline bool PokerTHMessage::has_statisticsmessage() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void PokerTHMessage::set_has_statisticsmessage() {
  _has_bits_[1] |= 0x40000000u;
}
inline void PokerTHMessage::clear_has_statisticsmessage() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void PokerTHMessage::clear_statisticsmessage() {
  if (statisticsmessage_ != NULL) statisticsmessage_->::StatisticsMessage::Clear();
  clear_has_statisticsmessage();
}
inline const ::StatisticsMessage& PokerTHMessage::statisticsmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.statisticsMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return statisticsmessage_ != NULL ? *statisticsmessage_ : *default_instance().statisticsmessage_;
#else
  return statisticsmessage_ != NULL ? *statisticsmessage_ : *default_instance_->statisticsmessage_;
#endif
}
inline ::StatisticsMessage* PokerTHMessage::mutable_statisticsmessage() {
  set_has_statisticsmessage();
  if (statisticsmessage_ == NULL) statisticsmessage_ = new ::StatisticsMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.statisticsMessage)
  return statisticsmessage_;
}
inline ::StatisticsMessage* PokerTHMessage::release_statisticsmessage() {
  clear_has_statisticsmessage();
  ::StatisticsMessage* temp = statisticsmessage_;
  statisticsmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_statisticsmessage(::StatisticsMessage* statisticsmessage) {
  delete statisticsmessage_;
  statisticsmessage_ = statisticsmessage;
  if (statisticsmessage) {
    set_has_statisticsmessage();
  } else {
    clear_has_statisticsmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.statisticsMessage)
}

// optional .ChatRequestMessage chatRequestMessage = 64;
inline bool PokerTHMessage::has_chatrequestmessage() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void PokerTHMessage::set_has_chatrequestmessage() {
  _has_bits_[1] |= 0x80000000u;
}
inline void PokerTHMessage::clear_has_chatrequestmessage() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void PokerTHMessage::clear_chatrequestmessage() {
  if (chatrequestmessage_ != NULL) chatrequestmessage_->::ChatRequestMessage::Clear();
  clear_has_chatrequestmessage();
}
inline const ::ChatRequestMessage& PokerTHMessage::chatrequestmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.chatRequestMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chatrequestmessage_ != NULL ? *chatrequestmessage_ : *default_instance().chatrequestmessage_;
#else
  return chatrequestmessage_ != NULL ? *chatrequestmessage_ : *default_instance_->chatrequestmessage_;
#endif
}
inline ::ChatRequestMessage* PokerTHMessage::mutable_chatrequestmessage() {
  set_has_chatrequestmessage();
  if (chatrequestmessage_ == NULL) chatrequestmessage_ = new ::ChatRequestMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.chatRequestMessage)
  return chatrequestmessage_;
}
inline ::ChatRequestMessage* PokerTHMessage::release_chatrequestmessage() {
  clear_has_chatrequestmessage();
  ::ChatRequestMessage* temp = chatrequestmessage_;
  chatrequestmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_chatrequestmessage(::ChatRequestMessage* chatrequestmessage) {
  delete chatrequestmessage_;
  chatrequestmessage_ = chatrequestmessage;
  if (chatrequestmessage) {
    set_has_chatrequestmessage();
  } else {
    clear_has_chatrequestmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.chatRequestMessage)
}

// optional .ChatMessage chatMessage = 65;
inline bool PokerTHMessage::has_chatmessage() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void PokerTHMessage::set_has_chatmessage() {
  _has_bits_[2] |= 0x00000001u;
}
inline void PokerTHMessage::clear_has_chatmessage() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void PokerTHMessage::clear_chatmessage() {
  if (chatmessage_ != NULL) chatmessage_->::ChatMessage::Clear();
  clear_has_chatmessage();
}
inline const ::ChatMessage& PokerTHMessage::chatmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.chatMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chatmessage_ != NULL ? *chatmessage_ : *default_instance().chatmessage_;
#else
  return chatmessage_ != NULL ? *chatmessage_ : *default_instance_->chatmessage_;
#endif
}
inline ::ChatMessage* PokerTHMessage::mutable_chatmessage() {
  set_has_chatmessage();
  if (chatmessage_ == NULL) chatmessage_ = new ::ChatMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.chatMessage)
  return chatmessage_;
}
inline ::ChatMessage* PokerTHMessage::release_chatmessage() {
  clear_has_chatmessage();
  ::ChatMessage* temp = chatmessage_;
  chatmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_chatmessage(::ChatMessage* chatmessage) {
  delete chatmessage_;
  chatmessage_ = chatmessage;
  if (chatmessage) {
    set_has_chatmessage();
  } else {
    clear_has_chatmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.chatMessage)
}

// optional .ChatRejectMessage chatRejectMessage = 66;
inline bool PokerTHMessage::has_chatrejectmessage() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void PokerTHMessage::set_has_chatrejectmessage() {
  _has_bits_[2] |= 0x00000002u;
}
inline void PokerTHMessage::clear_has_chatrejectmessage() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void PokerTHMessage::clear_chatrejectmessage() {
  if (chatrejectmessage_ != NULL) chatrejectmessage_->::ChatRejectMessage::Clear();
  clear_has_chatrejectmessage();
}
inline const ::ChatRejectMessage& PokerTHMessage::chatrejectmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.chatRejectMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chatrejectmessage_ != NULL ? *chatrejectmessage_ : *default_instance().chatrejectmessage_;
#else
  return chatrejectmessage_ != NULL ? *chatrejectmessage_ : *default_instance_->chatrejectmessage_;
#endif
}
inline ::ChatRejectMessage* PokerTHMessage::mutable_chatrejectmessage() {
  set_has_chatrejectmessage();
  if (chatrejectmessage_ == NULL) chatrejectmessage_ = new ::ChatRejectMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.chatRejectMessage)
  return chatrejectmessage_;
}
inline ::ChatRejectMessage* PokerTHMessage::release_chatrejectmessage() {
  clear_has_chatrejectmessage();
  ::ChatRejectMessage* temp = chatrejectmessage_;
  chatrejectmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_chatrejectmessage(::ChatRejectMessage* chatrejectmessage) {
  delete chatrejectmessage_;
  chatrejectmessage_ = chatrejectmessage;
  if (chatrejectmessage) {
    set_has_chatrejectmessage();
  } else {
    clear_has_chatrejectmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.chatRejectMessage)
}

// optional .DialogMessage dialogMessage = 67;
inline bool PokerTHMessage::has_dialogmessage() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void PokerTHMessage::set_has_dialogmessage() {
  _has_bits_[2] |= 0x00000004u;
}
inline void PokerTHMessage::clear_has_dialogmessage() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void PokerTHMessage::clear_dialogmessage() {
  if (dialogmessage_ != NULL) dialogmessage_->::DialogMessage::Clear();
  clear_has_dialogmessage();
}
inline const ::DialogMessage& PokerTHMessage::dialogmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.dialogMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dialogmessage_ != NULL ? *dialogmessage_ : *default_instance().dialogmessage_;
#else
  return dialogmessage_ != NULL ? *dialogmessage_ : *default_instance_->dialogmessage_;
#endif
}
inline ::DialogMessage* PokerTHMessage::mutable_dialogmessage() {
  set_has_dialogmessage();
  if (dialogmessage_ == NULL) dialogmessage_ = new ::DialogMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dialogMessage)
  return dialogmessage_;
}
inline ::DialogMessage* PokerTHMessage::release_dialogmessage() {
  clear_has_dialogmessage();
  ::DialogMessage* temp = dialogmessage_;
  dialogmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_dialogmessage(::DialogMessage* dialogmessage) {
  delete dialogmessage_;
  dialogmessage_ = dialogmessage;
  if (dialogmessage) {
    set_has_dialogmessage();
  } else {
    clear_has_dialogmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dialogMessage)
}

// optional .TimeoutWarningMessage timeoutWarningMessage = 68;
inline bool PokerTHMessage::has_timeoutwarningmessage() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void PokerTHMessage::set_has_timeoutwarningmessage() {
  _has_bits_[2] |= 0x00000008u;
}
inline void PokerTHMessage::clear_has_timeoutwarningmessage() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void PokerTHMessage::clear_timeoutwarningmessage() {
  if (timeoutwarningmessage_ != NULL) timeoutwarningmessage_->::TimeoutWarningMessage::Clear();
  clear_has_timeoutwarningmessage();
}
inline const ::TimeoutWarningMessage& PokerTHMessage::timeoutwarningmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.timeoutWarningMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return timeoutwarningmessage_ != NULL ? *timeoutwarningmessage_ : *default_instance().timeoutwarningmessage_;
#else
  return timeoutwarningmessage_ != NULL ? *timeoutwarningmessage_ : *default_instance_->timeoutwarningmessage_;
#endif
}
inline ::TimeoutWarningMessage* PokerTHMessage::mutable_timeoutwarningmessage() {
  set_has_timeoutwarningmessage();
  if (timeoutwarningmessage_ == NULL) timeoutwarningmessage_ = new ::TimeoutWarningMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.timeoutWarningMessage)
  return timeoutwarningmessage_;
}
inline ::TimeoutWarningMessage* PokerTHMessage::release_timeoutwarningmessage() {
  clear_has_timeoutwarningmessage();
  ::TimeoutWarningMessage* temp = timeoutwarningmessage_;
  timeoutwarningmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_timeoutwarningmessage(::TimeoutWarningMessage* timeoutwarningmessage) {
  delete timeoutwarningmessage_;
  timeoutwarningmessage_ = timeoutwarningmessage;
  if (timeoutwarningmessage) {
    set_has_timeoutwarningmessage();
  } else {
    clear_has_timeoutwarningmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.timeoutWarningMessage)
}

// optional .ResetTimeoutMessage resetTimeoutMessage = 69;
inline bool PokerTHMessage::has_resettimeoutmessage() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void PokerTHMessage::set_has_resettimeoutmessage() {
  _has_bits_[2] |= 0x00000010u;
}
inline void PokerTHMessage::clear_has_resettimeoutmessage() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void PokerTHMessage::clear_resettimeoutmessage() {
  if (resettimeoutmessage_ != NULL) resettimeoutmessage_->::ResetTimeoutMessage::Clear();
  clear_has_resettimeoutmessage();
}
inline const ::ResetTimeoutMessage& PokerTHMessage::resettimeoutmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.resetTimeoutMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return resettimeoutmessage_ != NULL ? *resettimeoutmessage_ : *default_instance().resettimeoutmessage_;
#else
  return resettimeoutmessage_ != NULL ? *resettimeoutmessage_ : *default_instance_->resettimeoutmessage_;
#endif
}
inline ::ResetTimeoutMessage* PokerTHMessage::mutable_resettimeoutmessage() {
  set_has_resettimeoutmessage();
  if (resettimeoutmessage_ == NULL) resettimeoutmessage_ = new ::ResetTimeoutMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.resetTimeoutMessage)
  return resettimeoutmessage_;
}
inline ::ResetTimeoutMessage* PokerTHMessage::release_resettimeoutmessage() {
  clear_has_resettimeoutmessage();
  ::ResetTimeoutMessage* temp = resettimeoutmessage_;
  resettimeoutmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_resettimeoutmessage(::ResetTimeoutMessage* resettimeoutmessage) {
  delete resettimeoutmessage_;
  resettimeoutmessage_ = resettimeoutmessage;
  if (resettimeoutmessage) {
    set_has_resettimeoutmessage();
  } else {
    clear_has_resettimeoutmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.resetTimeoutMessage)
}

// optional .ReportAvatarMessage reportAvatarMessage = 70;
inline bool PokerTHMessage::has_reportavatarmessage() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void PokerTHMessage::set_has_reportavatarmessage() {
  _has_bits_[2] |= 0x00000020u;
}
inline void PokerTHMessage::clear_has_reportavatarmessage() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void PokerTHMessage::clear_reportavatarmessage() {
  if (reportavatarmessage_ != NULL) reportavatarmessage_->::ReportAvatarMessage::Clear();
  clear_has_reportavatarmessage();
}
inline const ::ReportAvatarMessage& PokerTHMessage::reportavatarmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportAvatarMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reportavatarmessage_ != NULL ? *reportavatarmessage_ : *default_instance().reportavatarmessage_;
#else
  return reportavatarmessage_ != NULL ? *reportavatarmessage_ : *default_instance_->reportavatarmessage_;
#endif
}
inline ::ReportAvatarMessage* PokerTHMessage::mutable_reportavatarmessage() {
  set_has_reportavatarmessage();
  if (reportavatarmessage_ == NULL) reportavatarmessage_ = new ::ReportAvatarMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportAvatarMessage)
  return reportavatarmessage_;
}
inline ::ReportAvatarMessage* PokerTHMessage::release_reportavatarmessage() {
  clear_has_reportavatarmessage();
  ::ReportAvatarMessage* temp = reportavatarmessage_;
  reportavatarmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_reportavatarmessage(::ReportAvatarMessage* reportavatarmessage) {
  delete reportavatarmessage_;
  reportavatarmessage_ = reportavatarmessage;
  if (reportavatarmessage) {
    set_has_reportavatarmessage();
  } else {
    clear_has_reportavatarmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportAvatarMessage)
}

// optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
inline bool PokerTHMessage::has_reportavatarackmessage() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void PokerTHMessage::set_has_reportavatarackmessage() {
  _has_bits_[2] |= 0x00000040u;
}
inline void PokerTHMessage::clear_has_reportavatarackmessage() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void PokerTHMessage::clear_reportavatarackmessage() {
  if (reportavatarackmessage_ != NULL) reportavatarackmessage_->::ReportAvatarAckMessage::Clear();
  clear_has_reportavatarackmessage();
}
inline const ::ReportAvatarAckMessage& PokerTHMessage::reportavatarackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportAvatarAckMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reportavatarackmessage_ != NULL ? *reportavatarackmessage_ : *default_instance().reportavatarackmessage_;
#else
  return reportavatarackmessage_ != NULL ? *reportavatarackmessage_ : *default_instance_->reportavatarackmessage_;
#endif
}
inline ::ReportAvatarAckMessage* PokerTHMessage::mutable_reportavatarackmessage() {
  set_has_reportavatarackmessage();
  if (reportavatarackmessage_ == NULL) reportavatarackmessage_ = new ::ReportAvatarAckMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportAvatarAckMessage)
  return reportavatarackmessage_;
}
inline ::ReportAvatarAckMessage* PokerTHMessage::release_reportavatarackmessage() {
  clear_has_reportavatarackmessage();
  ::ReportAvatarAckMessage* temp = reportavatarackmessage_;
  reportavatarackmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_reportavatarackmessage(::ReportAvatarAckMessage* reportavatarackmessage) {
  delete reportavatarackmessage_;
  reportavatarackmessage_ = reportavatarackmessage;
  if (reportavatarackmessage) {
    set_has_reportavatarackmessage();
  } else {
    clear_has_reportavatarackmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportAvatarAckMessage)
}

// optional .ReportGameMessage reportGameMessage = 72;
inline bool PokerTHMessage::has_reportgamemessage() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void PokerTHMessage::set_has_reportgamemessage() {
  _has_bits_[2] |= 0x00000080u;
}
inline void PokerTHMessage::clear_has_reportgamemessage() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void PokerTHMessage::clear_reportgamemessage() {
  if (reportgamemessage_ != NULL) reportgamemessage_->::ReportGameMessage::Clear();
  clear_has_reportgamemessage();
}
inline const ::ReportGameMessage& PokerTHMessage::reportgamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportGameMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reportgamemessage_ != NULL ? *reportgamemessage_ : *default_instance().reportgamemessage_;
#else
  return reportgamemessage_ != NULL ? *reportgamemessage_ : *default_instance_->reportgamemessage_;
#endif
}
inline ::ReportGameMessage* PokerTHMessage::mutable_reportgamemessage() {
  set_has_reportgamemessage();
  if (reportgamemessage_ == NULL) reportgamemessage_ = new ::ReportGameMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportGameMessage)
  return reportgamemessage_;
}
inline ::ReportGameMessage* PokerTHMessage::release_reportgamemessage() {
  clear_has_reportgamemessage();
  ::ReportGameMessage* temp = reportgamemessage_;
  reportgamemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_reportgamemessage(::ReportGameMessage* reportgamemessage) {
  delete reportgamemessage_;
  reportgamemessage_ = reportgamemessage;
  if (reportgamemessage) {
    set_has_reportgamemessage();
  } else {
    clear_has_reportgamemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportGameMessage)
}

// optional .ReportGameAckMessage reportGameAckMessage = 73;
inline bool PokerTHMessage::has_reportgameackmessage() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void PokerTHMessage::set_has_reportgameackmessage() {
  _has_bits_[2] |= 0x00000100u;
}
inline void PokerTHMessage::clear_has_reportgameackmessage() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void PokerTHMessage::clear_reportgameackmessage() {
  if (reportgameackmessage_ != NULL) reportgameackmessage_->::ReportGameAckMessage::Clear();
  clear_has_reportgameackmessage();
}
inline const ::ReportGameAckMessage& PokerTHMessage::reportgameackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportGameAckMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reportgameackmessage_ != NULL ? *reportgameackmessage_ : *default_instance().reportgameackmessage_;
#else
  return reportgameackmessage_ != NULL ? *reportgameackmessage_ : *default_instance_->reportgameackmessage_;
#endif
}
inline ::ReportGameAckMessage* PokerTHMessage::mutable_reportgameackmessage() {
  set_has_reportgameackmessage();
  if (reportgameackmessage_ == NULL) reportgameackmessage_ = new ::ReportGameAckMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportGameAckMessage)
  return reportgameackmessage_;
}
inline ::ReportGameAckMessage* PokerTHMessage::release_reportgameackmessage() {
  clear_has_reportgameackmessage();
  ::ReportGameAckMessage* temp = reportgameackmessage_;
  reportgameackmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_reportgameackmessage(::ReportGameAckMessage* reportgameackmessage) {
  delete reportgameackmessage_;
  reportgameackmessage_ = reportgameackmessage;
  if (reportgameackmessage) {
    set_has_reportgameackmessage();
  } else {
    clear_has_reportgameackmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportGameAckMessage)
}

// optional .ErrorMessage errorMessage = 74;
inline bool PokerTHMessage::has_errormessage() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void PokerTHMessage::set_has_errormessage() {
  _has_bits_[2] |= 0x00000200u;
}
inline void PokerTHMessage::clear_has_errormessage() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void PokerTHMessage::clear_errormessage() {
  if (errormessage_ != NULL) errormessage_->::ErrorMessage::Clear();
  clear_has_errormessage();
}
inline const ::ErrorMessage& PokerTHMessage::errormessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.errorMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return errormessage_ != NULL ? *errormessage_ : *default_instance().errormessage_;
#else
  return errormessage_ != NULL ? *errormessage_ : *default_instance_->errormessage_;
#endif
}
inline ::ErrorMessage* PokerTHMessage::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == NULL) errormessage_ = new ::ErrorMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.errorMessage)
  return errormessage_;
}
inline ::ErrorMessage* PokerTHMessage::release_errormessage() {
  clear_has_errormessage();
  ::ErrorMessage* temp = errormessage_;
  errormessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_errormessage(::ErrorMessage* errormessage) {
  delete errormessage_;
  errormessage_ = errormessage;
  if (errormessage) {
    set_has_errormessage();
  } else {
    clear_has_errormessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.errorMessage)
}

// optional .AdminRemoveGameMessage adminRemoveGameMessage = 75;
inline bool PokerTHMessage::has_adminremovegamemessage() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void PokerTHMessage::set_has_adminremovegamemessage() {
  _has_bits_[2] |= 0x00000400u;
}
inline void PokerTHMessage::clear_has_adminremovegamemessage() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void PokerTHMessage::clear_adminremovegamemessage() {
  if (adminremovegamemessage_ != NULL) adminremovegamemessage_->::AdminRemoveGameMessage::Clear();
  clear_has_adminremovegamemessage();
}
inline const ::AdminRemoveGameMessage& PokerTHMessage::adminremovegamemessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminRemoveGameMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return adminremovegamemessage_ != NULL ? *adminremovegamemessage_ : *default_instance().adminremovegamemessage_;
#else
  return adminremovegamemessage_ != NULL ? *adminremovegamemessage_ : *default_instance_->adminremovegamemessage_;
#endif
}
inline ::AdminRemoveGameMessage* PokerTHMessage::mutable_adminremovegamemessage() {
  set_has_adminremovegamemessage();
  if (adminremovegamemessage_ == NULL) adminremovegamemessage_ = new ::AdminRemoveGameMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminRemoveGameMessage)
  return adminremovegamemessage_;
}
inline ::AdminRemoveGameMessage* PokerTHMessage::release_adminremovegamemessage() {
  clear_has_adminremovegamemessage();
  ::AdminRemoveGameMessage* temp = adminremovegamemessage_;
  adminremovegamemessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_adminremovegamemessage(::AdminRemoveGameMessage* adminremovegamemessage) {
  delete adminremovegamemessage_;
  adminremovegamemessage_ = adminremovegamemessage;
  if (adminremovegamemessage) {
    set_has_adminremovegamemessage();
  } else {
    clear_has_adminremovegamemessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminRemoveGameMessage)
}

// optional .AdminRemoveGameAckMessage adminRemoveGameAckMessage = 76;
inline bool PokerTHMessage::has_adminremovegameackmessage() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void PokerTHMessage::set_has_adminremovegameackmessage() {
  _has_bits_[2] |= 0x00000800u;
}
inline void PokerTHMessage::clear_has_adminremovegameackmessage() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void PokerTHMessage::clear_adminremovegameackmessage() {
  if (adminremovegameackmessage_ != NULL) adminremovegameackmessage_->::AdminRemoveGameAckMessage::Clear();
  clear_has_adminremovegameackmessage();
}
inline const ::AdminRemoveGameAckMessage& PokerTHMessage::adminremovegameackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminRemoveGameAckMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return adminremovegameackmessage_ != NULL ? *adminremovegameackmessage_ : *default_instance().adminremovegameackmessage_;
#else
  return adminremovegameackmessage_ != NULL ? *adminremovegameackmessage_ : *default_instance_->adminremovegameackmessage_;
#endif
}
inline ::AdminRemoveGameAckMessage* PokerTHMessage::mutable_adminremovegameackmessage() {
  set_has_adminremovegameackmessage();
  if (adminremovegameackmessage_ == NULL) adminremovegameackmessage_ = new ::AdminRemoveGameAckMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminRemoveGameAckMessage)
  return adminremovegameackmessage_;
}
inline ::AdminRemoveGameAckMessage* PokerTHMessage::release_adminremovegameackmessage() {
  clear_has_adminremovegameackmessage();
  ::AdminRemoveGameAckMessage* temp = adminremovegameackmessage_;
  adminremovegameackmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_adminremovegameackmessage(::AdminRemoveGameAckMessage* adminremovegameackmessage) {
  delete adminremovegameackmessage_;
  adminremovegameackmessage_ = adminremovegameackmessage;
  if (adminremovegameackmessage) {
    set_has_adminremovegameackmessage();
  } else {
    clear_has_adminremovegameackmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminRemoveGameAckMessage)
}

// optional .AdminBanPlayerMessage adminBanPlayerMessage = 77;
inline bool PokerTHMessage::has_adminbanplayermessage() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void PokerTHMessage::set_has_adminbanplayermessage() {
  _has_bits_[2] |= 0x00001000u;
}
inline void PokerTHMessage::clear_has_adminbanplayermessage() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void PokerTHMessage::clear_adminbanplayermessage() {
  if (adminbanplayermessage_ != NULL) adminbanplayermessage_->::AdminBanPlayerMessage::Clear();
  clear_has_adminbanplayermessage();
}
inline const ::AdminBanPlayerMessage& PokerTHMessage::adminbanplayermessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminBanPlayerMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return adminbanplayermessage_ != NULL ? *adminbanplayermessage_ : *default_instance().adminbanplayermessage_;
#else
  return adminbanplayermessage_ != NULL ? *adminbanplayermessage_ : *default_instance_->adminbanplayermessage_;
#endif
}
inline ::AdminBanPlayerMessage* PokerTHMessage::mutable_adminbanplayermessage() {
  set_has_adminbanplayermessage();
  if (adminbanplayermessage_ == NULL) adminbanplayermessage_ = new ::AdminBanPlayerMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminBanPlayerMessage)
  return adminbanplayermessage_;
}
inline ::AdminBanPlayerMessage* PokerTHMessage::release_adminbanplayermessage() {
  clear_has_adminbanplayermessage();
  ::AdminBanPlayerMessage* temp = adminbanplayermessage_;
  adminbanplayermessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_adminbanplayermessage(::AdminBanPlayerMessage* adminbanplayermessage) {
  delete adminbanplayermessage_;
  adminbanplayermessage_ = adminbanplayermessage;
  if (adminbanplayermessage) {
    set_has_adminbanplayermessage();
  } else {
    clear_has_adminbanplayermessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminBanPlayerMessage)
}

// optional .AdminBanPlayerAckMessage adminBanPlayerAckMessage = 78;
inline bool PokerTHMessage::has_adminbanplayerackmessage() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void PokerTHMessage::set_has_adminbanplayerackmessage() {
  _has_bits_[2] |= 0x00002000u;
}
inline void PokerTHMessage::clear_has_adminbanplayerackmessage() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void PokerTHMessage::clear_adminbanplayerackmessage() {
  if (adminbanplayerackmessage_ != NULL) adminbanplayerackmessage_->::AdminBanPlayerAckMessage::Clear();
  clear_has_adminbanplayerackmessage();
}
inline const ::AdminBanPlayerAckMessage& PokerTHMessage::adminbanplayerackmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminBanPlayerAckMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return adminbanplayerackmessage_ != NULL ? *adminbanplayerackmessage_ : *default_instance().adminbanplayerackmessage_;
#else
  return adminbanplayerackmessage_ != NULL ? *adminbanplayerackmessage_ : *default_instance_->adminbanplayerackmessage_;
#endif
}
inline ::AdminBanPlayerAckMessage* PokerTHMessage::mutable_adminbanplayerackmessage() {
  set_has_adminbanplayerackmessage();
  if (adminbanplayerackmessage_ == NULL) adminbanplayerackmessage_ = new ::AdminBanPlayerAckMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminBanPlayerAckMessage)
  return adminbanplayerackmessage_;
}
inline ::AdminBanPlayerAckMessage* PokerTHMessage::release_adminbanplayerackmessage() {
  clear_has_adminbanplayerackmessage();
  ::AdminBanPlayerAckMessage* temp = adminbanplayerackmessage_;
  adminbanplayerackmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_adminbanplayerackmessage(::AdminBanPlayerAckMessage* adminbanplayerackmessage) {
  delete adminbanplayerackmessage_;
  adminbanplayerackmessage_ = adminbanplayerackmessage;
  if (adminbanplayerackmessage) {
    set_has_adminbanplayerackmessage();
  } else {
    clear_has_adminbanplayerackmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminBanPlayerAckMessage)
}

// optional .GameListSpectatorJoinedMessage gameListSpectatorJoinedMessage = 79;
inline bool PokerTHMessage::has_gamelistspectatorjoinedmessage() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistspectatorjoinedmessage() {
  _has_bits_[2] |= 0x00004000u;
}
inline void PokerTHMessage::clear_has_gamelistspectatorjoinedmessage() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void PokerTHMessage::clear_gamelistspectatorjoinedmessage() {
  if (gamelistspectatorjoinedmessage_ != NULL) gamelistspectatorjoinedmessage_->::GameListSpectatorJoinedMessage::Clear();
  clear_has_gamelistspectatorjoinedmessage();
}
inline const ::GameListSpectatorJoinedMessage& PokerTHMessage::gamelistspectatorjoinedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListSpectatorJoinedMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamelistspectatorjoinedmessage_ != NULL ? *gamelistspectatorjoinedmessage_ : *default_instance().gamelistspectatorjoinedmessage_;
#else
  return gamelistspectatorjoinedmessage_ != NULL ? *gamelistspectatorjoinedmessage_ : *default_instance_->gamelistspectatorjoinedmessage_;
#endif
}
inline ::GameListSpectatorJoinedMessage* PokerTHMessage::mutable_gamelistspectatorjoinedmessage() {
  set_has_gamelistspectatorjoinedmessage();
  if (gamelistspectatorjoinedmessage_ == NULL) gamelistspectatorjoinedmessage_ = new ::GameListSpectatorJoinedMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListSpectatorJoinedMessage)
  return gamelistspectatorjoinedmessage_;
}
inline ::GameListSpectatorJoinedMessage* PokerTHMessage::release_gamelistspectatorjoinedmessage() {
  clear_has_gamelistspectatorjoinedmessage();
  ::GameListSpectatorJoinedMessage* temp = gamelistspectatorjoinedmessage_;
  gamelistspectatorjoinedmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamelistspectatorjoinedmessage(::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage) {
  delete gamelistspectatorjoinedmessage_;
  gamelistspectatorjoinedmessage_ = gamelistspectatorjoinedmessage;
  if (gamelistspectatorjoinedmessage) {
    set_has_gamelistspectatorjoinedmessage();
  } else {
    clear_has_gamelistspectatorjoinedmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListSpectatorJoinedMessage)
}

// optional .GameListSpectatorLeftMessage gameListSpectatorLeftMessage = 80;
inline bool PokerTHMessage::has_gamelistspectatorleftmessage() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void PokerTHMessage::set_has_gamelistspectatorleftmessage() {
  _has_bits_[2] |= 0x00008000u;
}
inline void PokerTHMessage::clear_has_gamelistspectatorleftmessage() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void PokerTHMessage::clear_gamelistspectatorleftmessage() {
  if (gamelistspectatorleftmessage_ != NULL) gamelistspectatorleftmessage_->::GameListSpectatorLeftMessage::Clear();
  clear_has_gamelistspectatorleftmessage();
}
inline const ::GameListSpectatorLeftMessage& PokerTHMessage::gamelistspectatorleftmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListSpectatorLeftMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamelistspectatorleftmessage_ != NULL ? *gamelistspectatorleftmessage_ : *default_instance().gamelistspectatorleftmessage_;
#else
  return gamelistspectatorleftmessage_ != NULL ? *gamelistspectatorleftmessage_ : *default_instance_->gamelistspectatorleftmessage_;
#endif
}
inline ::GameListSpectatorLeftMessage* PokerTHMessage::mutable_gamelistspectatorleftmessage() {
  set_has_gamelistspectatorleftmessage();
  if (gamelistspectatorleftmessage_ == NULL) gamelistspectatorleftmessage_ = new ::GameListSpectatorLeftMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListSpectatorLeftMessage)
  return gamelistspectatorleftmessage_;
}
inline ::GameListSpectatorLeftMessage* PokerTHMessage::release_gamelistspectatorleftmessage() {
  clear_has_gamelistspectatorleftmessage();
  ::GameListSpectatorLeftMessage* temp = gamelistspectatorleftmessage_;
  gamelistspectatorleftmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamelistspectatorleftmessage(::GameListSpectatorLeftMessage* gamelistspectatorleftmessage) {
  delete gamelistspectatorleftmessage_;
  gamelistspectatorleftmessage_ = gamelistspectatorleftmessage;
  if (gamelistspectatorleftmessage) {
    set_has_gamelistspectatorleftmessage();
  } else {
    clear_has_gamelistspectatorleftmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListSpectatorLeftMessage)
}

// optional .GameSpectatorJoinedMessage gameSpectatorJoinedMessage = 81;
inline bool PokerTHMessage::has_gamespectatorjoinedmessage() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void PokerTHMessage::set_has_gamespectatorjoinedmessage() {
  _has_bits_[2] |= 0x00010000u;
}
inline void PokerTHMessage::clear_has_gamespectatorjoinedmessage() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void PokerTHMessage::clear_gamespectatorjoinedmessage() {
  if (gamespectatorjoinedmessage_ != NULL) gamespectatorjoinedmessage_->::GameSpectatorJoinedMessage::Clear();
  clear_has_gamespectatorjoinedmessage();
}
inline const ::GameSpectatorJoinedMessage& PokerTHMessage::gamespectatorjoinedmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameSpectatorJoinedMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamespectatorjoinedmessage_ != NULL ? *gamespectatorjoinedmessage_ : *default_instance().gamespectatorjoinedmessage_;
#else
  return gamespectatorjoinedmessage_ != NULL ? *gamespectatorjoinedmessage_ : *default_instance_->gamespectatorjoinedmessage_;
#endif
}
inline ::GameSpectatorJoinedMessage* PokerTHMessage::mutable_gamespectatorjoinedmessage() {
  set_has_gamespectatorjoinedmessage();
  if (gamespectatorjoinedmessage_ == NULL) gamespectatorjoinedmessage_ = new ::GameSpectatorJoinedMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameSpectatorJoinedMessage)
  return gamespectatorjoinedmessage_;
}
inline ::GameSpectatorJoinedMessage* PokerTHMessage::release_gamespectatorjoinedmessage() {
  clear_has_gamespectatorjoinedmessage();
  ::GameSpectatorJoinedMessage* temp = gamespectatorjoinedmessage_;
  gamespectatorjoinedmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamespectatorjoinedmessage(::GameSpectatorJoinedMessage* gamespectatorjoinedmessage) {
  delete gamespectatorjoinedmessage_;
  gamespectatorjoinedmessage_ = gamespectatorjoinedmessage;
  if (gamespectatorjoinedmessage) {
    set_has_gamespectatorjoinedmessage();
  } else {
    clear_has_gamespectatorjoinedmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameSpectatorJoinedMessage)
}

// optional .GameSpectatorLeftMessage gameSpectatorLeftMessage = 82;
inline bool PokerTHMessage::has_gamespectatorleftmessage() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void PokerTHMessage::set_has_gamespectatorleftmessage() {
  _has_bits_[2] |= 0x00020000u;
}
inline void PokerTHMessage::clear_has_gamespectatorleftmessage() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void PokerTHMessage::clear_gamespectatorleftmessage() {
  if (gamespectatorleftmessage_ != NULL) gamespectatorleftmessage_->::GameSpectatorLeftMessage::Clear();
  clear_has_gamespectatorleftmessage();
}
inline const ::GameSpectatorLeftMessage& PokerTHMessage::gamespectatorleftmessage() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameSpectatorLeftMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamespectatorleftmessage_ != NULL ? *gamespectatorleftmessage_ : *default_instance().gamespectatorleftmessage_;
#else
  return gamespectatorleftmessage_ != NULL ? *gamespectatorleftmessage_ : *default_instance_->gamespectatorleftmessage_;
#endif
}
inline ::GameSpectatorLeftMessage* PokerTHMessage::mutable_gamespectatorleftmessage() {
  set_has_gamespectatorleftmessage();
  if (gamespectatorleftmessage_ == NULL) gamespectatorleftmessage_ = new ::GameSpectatorLeftMessage;
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameSpectatorLeftMessage)
  return gamespectatorleftmessage_;
}
inline ::GameSpectatorLeftMessage* PokerTHMessage::release_gamespectatorleftmessage() {
  clear_has_gamespectatorleftmessage();
  ::GameSpectatorLeftMessage* temp = gamespectatorleftmessage_;
  gamespectatorleftmessage_ = NULL;
  return temp;
}
inline void PokerTHMessage::set_allocated_gamespectatorleftmessage(::GameSpectatorLeftMessage* gamespectatorleftmessage) {
  delete gamespectatorleftmessage_;
  gamespectatorleftmessage_ = gamespectatorleftmessage;
  if (gamespectatorleftmessage) {
    set_has_gamespectatorleftmessage();
  } else {
    clear_has_gamespectatorleftmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameSpectatorLeftMessage)
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pokerth_2eproto__INCLUDED
